(function() {
    "use strict";


    function BigIntWrapper() {}
    //var BigIntWrapper = typeof BigInt !== 'undefined' ? BigInt : function () {};
    BigIntWrapper.BigInt = function(x) {
        return BigInt(x);
    };
    BigIntWrapper.asIntN = function(bits, bigint) {
        return BigInt.asIntN(bits, bigint);
    };
    BigIntWrapper.asUintN = function(bits, bigint) {
        return BigInt.asUintN(bits, bigint);
    };
    BigIntWrapper.toNumber = function(bigint) {
        return Number(bigint);
    };
    BigIntWrapper.add = function(a, b) {
        return a + b;
    };
    BigIntWrapper.subtract = function(a, b) {
        return a - b;
    };
    BigIntWrapper.multiply = function(a, b) {
        return a * b;
    };
    BigIntWrapper.divide = function(a, b) {
        return a / b;
    };
    BigIntWrapper.remainder = function(a, b) {
        return a % b;
    };
    BigIntWrapper.unaryMinus = function(a) {
        return -a;
    };
    BigIntWrapper.equal = function(a, b) {
        return a === b;
    };
    BigIntWrapper.lessThan = function(a, b) {
        return a < b;
    };
    BigIntWrapper.greaterThan = function(a, b) {
        return a > b;
    };
    BigIntWrapper.notEqual = function(a, b) {
        return a !== b;
    };
    BigIntWrapper.lessThanOrEqual = function(a, b) {
        return a <= b;
    };
    BigIntWrapper.greaterThanOrEqual = function(a, b) {
        return a >= b;
    };
    BigIntWrapper.exponentiate = function(a, b) { // a**b
        if (typeof a !== "bigint" || typeof b !== "bigint") {
            throw new TypeError();
        }
        var n = Number(b);
        if (n < 0) {
            throw new RangeError();
        }
        if (n > Number.MAX_SAFE_INTEGER) {
            var y = Number(a);
            if (y === 0 || y === -1 || y === +1) {
                return y === -1 && Number(b % BigInt(2)) === 0 ? -a : a;
            }
            throw new RangeError();
        }
        if (a === BigInt(2)) {
            return BigInt(1) << b;
        }
        if (n === 0) {
            return BigInt(1);
        }
        var x = a;
        while (n % 2 === 0) {
            n = Math.floor(n / 2);
            x *= x;
        }
        var accumulator = x;
        n -= 1;
        if (n >= 2) {
            while (n >= 2) {
                var t = Math.floor(n / 2);
                if (t * 2 !== n) {
                    accumulator *= x;
                }
                n = t;
                x *= x;
            }
            accumulator *= x;
        }
        return accumulator;
    };
    BigIntWrapper.signedRightShift = function(a, n) {
        return a >> n;
    };
    BigIntWrapper.leftShift = function(a, n) {
        return a << n;
    };
    if (Symbol.hasInstance != undefined) {
        Object.defineProperty(BigIntWrapper, Symbol.hasInstance, {
            value: function(a) {
                return typeof a === 'bigint';
            }
        });
    }

    var supportsBigInt = Symbol.hasInstance != undefined &&
        typeof BigInt !== "undefined" &&
        BigInt(Number.MAX_SAFE_INTEGER) + BigInt(2) - BigInt(2) === BigInt(Number.MAX_SAFE_INTEGER);

    if (supportsBigInt) {
        // https://twitter.com/mild_sunrise/status/1339174371550760961
        if (((-BigInt('0xffffffffffffffffffffffffffffffff')) >> BigInt(0x40)).toString() !== '-18446744073709551616') { // ((-(Math.pow(2, 128) - 1)) >> 64) !== -1 * 2**64
            supportsBigInt = false; // TODO: partial support (?)
        }
    }
    if (supportsBigInt) {
        try {
            BigInt(Number.MAX_SAFE_INTEGER + 1);
        } catch (error) {
            // Chrome 67
            supportsBigInt = false; // TODO: partial support (?)
        }
    }



    (function(global) {
        //TODO:?
        //! copy-pasted from BigInteger.js
        var Internal = null;

        // noinline
        var n = function(f) {
            return function(x, y) {
                return f(x, y);
            };
        };

        var cache = new Array(16 * 2 + 1);
        for (var i = 0; i < cache.length; i += 1) {
            cache[i] = undefined;
        }

        function LastTwoMap() {
            this.a = undefined;
            this.aKey = 0;
            this.b = undefined;
            this.bKey = 0;
            this.last = 0;
        }
        LastTwoMap.prototype.get = function(key) {
            if (this.aKey === key) {
                this.last = 0;
                return this.a;
            }
            if (this.bKey === key) {
                this.last = 1;
                return this.b;
            }
            return undefined;
        };
        LastTwoMap.prototype.set = function(key, value) {
            if (this.last === 0) {
                this.bKey = key;
                this.b = value;
                this.last = 1;
            } else {
                this.aKey = key;
                this.a = value;
                this.last = 0;
            }
        };
        var map = new LastTwoMap(); // to optimize when some number is multiplied by few numbers sequencely
        var toNumber = n(function(a) {
            return Internal.toNumber(a);
        });
        var valueOf = function(x) {
            if (typeof x === "number") {
                if (x >= -16 && x <= +16) {
                    var value = cache[x + 16];
                    if (value == undefined) {
                        value = Internal.BigInt(x);
                        cache[x + 16] = value;
                    }
                    return value;
                }
                var value = map.get(x);
                if (value == undefined) {
                    value = Internal.BigInt(x);
                    map.set(x, value);
                }
                return value;
            }
            return x;
        };
        var toResult = function(x) {
            var value = Internal.toNumber(x);
            if (value >= -9007199254740991 && value <= +9007199254740991) {
                return value;
            }
            return x;
        };
        var add = n(function(x, y) {
            if (typeof x === "number" && x === 0) {
                return y;
            }
            if (typeof y === "number" && y === 0) {
                return x;
            }
            var a = valueOf(x);
            var b = valueOf(y);
            var sum = Internal.add(a, b);
            return typeof x === "number" && typeof y === "number" ? sum : toResult(sum);
        });
        var subtract = n(function(x, y) {
            if (typeof x === "number" && x === 0) {
                return unaryMinus(y);
            }
            // quite good optimization for comparision of big integers
            if (typeof y === "number" && y === 0) {
                return x;
            }
            var a = valueOf(x);
            var b = valueOf(y);
            var difference = Internal.subtract(a, b);
            return typeof x === "number" && typeof y === "number" ? difference : toResult(difference);
        });
        var multiply = n(function(x, y) {
            if (typeof x === "number" && x === 0) {
                return 0;
            }
            if (typeof x === "number" && x === 1) {
                return y;
            }
            if (typeof x === "number" && x === -1) {
                return Internal.unaryMinus(y);
            }
            if (typeof y === "number" && y === 0) {
                return 0;
            }
            if (typeof y === "number" && y === 1) {
                return x;
            }
            if (typeof y === "number" && y === -1) {
                return Internal.unaryMinus(x);
            }
            var a = valueOf(x);
            var b = valueOf(y);
            return Internal.multiply(a, b);
        });
        var divide = n(function(x, y) {
            if (typeof x === "number") {
                return 0;
            }
            if (typeof y === "number" && y === 1) {
                return x;
            }
            if (typeof y === "number" && y === -1) {
                return Internal.unaryMinus(x);
            }
            var a = valueOf(x);
            var b = valueOf(y);
            return toResult(Internal.divide(a, b));
        });
        var remainder = n(function(x, y) {
            if (typeof x === "number") {
                return x;
            }
            if (typeof y === "number" && y === 1) {
                return 0;
            }
            if (typeof y === "number" && y === -1) {
                return 0;
            }
            var a = valueOf(x);
            var b = valueOf(y);
            return toResult(Internal.remainder(a, b));
        });
        var exponentiate = n(function(x, y) {
            if (typeof y === "number") {
                if (y === 0) {
                    return 1;
                }
                if (y === 1) {
                    return x;
                }
                if (y === 2) {
                    return multiply(x, x);
                }
                if (typeof x === "number" && Math.abs(x) > 2 && y >= 0) {
                    if (y > 42 && x % 2 === 0) { //TODO: ?
                        return multiply(exponentiate(2, y), exponentiate(x / 2, y));
                    }
                    var k = Math.floor(Math.log(9007199254740991) / Math.log(Math.abs(x) + 0.5));
                    if (k >= 2) {
                        return multiply(Math.pow(x, y % k), exponentiate(Math.pow(x, k), Math.floor(y / k)));
                    }
                }
            }
            var a = valueOf(x);
            var b = valueOf(y);
            var power = Internal.exponentiate(a, b);
            return typeof x === "number" && Math.abs(x) <= 1 ? toResult(power) : power;
        });
        var unaryMinus = n(function(x) {
            var a = valueOf(x);
            return Internal.unaryMinus(a);
        });
        var equal = n(function(x, y) {
            if (typeof x === "number") {
                return false;
            }
            if (typeof y === "number") {
                return false;
            }
            return Internal.equal(x, y);
        });
        var lessThan = n(function(x, y) {
            if (typeof x === "number") {
                return x < Internal.toNumber(y);
            }
            if (typeof y === "number") {
                return Internal.toNumber(x) < y;
            }
            return Internal.lessThan(x, y);
        });
        var greaterThan = n(function(x, y) {
            if (typeof x === "number") {
                return x > Internal.toNumber(y);
            }
            if (typeof y === "number") {
                return Internal.toNumber(x) > y;
            }
            return Internal.greaterThan(x, y);
        });

        function SmallBigInteger() {}

        // Conversion from String:
        // Conversion from Number:
        SmallBigInteger.BigInt = function(x) {
            if (typeof x === "number" || typeof x === "string" || typeof x === "bigint") {
                var value = 0 + (typeof x === "number" ? x : Number(x));
                if (value >= -9007199254740991 && value <= +9007199254740991) {
                    return value;
                }
            }
            return toResult(Internal.BigInt(x));
        };
        SmallBigInteger.asUintN = function(n, x) {
            if (typeof x === "number" && x >= 0 && n >= 0 && n <= 53) {
                var m = exp(2, n);
                return x - Math.floor(x / m) * m;
            }
            return toResult(Internal.asUintN(n, Internal.BigInt(x)));
        };
        // Conversion to Number:
        SmallBigInteger.toNumber = function(x) {
            if (typeof x === "number") {
                return x;
            }
            return toNumber(x);
        };

        // Arithmetic:
        SmallBigInteger.add = function(x, y) {
            if (typeof x === "string" || typeof y === "string") {
                return x + y;
            }
            if (typeof x === "number" && typeof y === "number") {
                var value = x + y;
                if (value >= -9007199254740991 && value <= +9007199254740991) {
                    return value;
                }
            }
            return add(x, y);
        };
        SmallBigInteger.subtract = function(x, y) {
            if (typeof x === "number" && typeof y === "number") {
                var value = x - y;
                if (value >= -9007199254740991 && value <= +9007199254740991) {
                    return value;
                }
            }
            return subtract(x, y);
        };
        SmallBigInteger.multiply = function(x, y) {
            if (typeof x === "number" && typeof y === "number") {
                var value = 0 + x * y;
                if (value >= -9007199254740991 && value <= +9007199254740991) {
                    return value;
                }
            }
            return multiply(x, y);
        };
        SmallBigInteger.divide = function(x, y) {
            if (typeof x === "number" && typeof y === "number") {
                if (y !== 0) {
                    return x === 0 ? 0 : (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 + Math.floor(x / y) : 0 - Math.floor((0 - x) / y);
                }
            }
            return divide(x, y);
        };
        SmallBigInteger.remainder = function(x, y) {
            if (typeof x === "number" && typeof y === "number") {
                if (y !== 0) {
                    return 0 + x % y;
                }
            }
            return remainder(x, y);
        };
        SmallBigInteger.unaryMinus = function(x) {
            if (typeof x === "number") {
                return 0 - x;
            }
            return unaryMinus(x);
        };

        // Comparison:
        SmallBigInteger.equal = function(x, y) {
            if (typeof x === "number" && typeof y === "number") {
                return x === y;
            }
            return equal(x, y);
        };
        SmallBigInteger.lessThan = function(x, y) {
            if (typeof x === "number" && typeof y === "number") {
                return x < y;
            }
            return lessThan(x, y);
        };
        SmallBigInteger.greaterThan = function(x, y) {
            if (typeof x === "number" && typeof y === "number") {
                return x > y;
            }
            return greaterThan(x, y);
        };
        SmallBigInteger.notEqual = function(x, y) {
            return !SmallBigInteger.equal(x, y);
        };
        SmallBigInteger.lessThanOrEqual = function(x, y) {
            return !SmallBigInteger.greaterThan(x, y);
        };
        SmallBigInteger.greaterThanOrEqual = function(x, y) {
            return !SmallBigInteger.lessThan(x, y);
        };

        SmallBigInteger.exponentiate = function(x, y) {
            if (typeof x === "number" && typeof y === "number") {
                if (y >= 0 && (y < 53 || x >= -1 && x <= 1)) { // 53 === log2(9007199254740991 + 1)
                    var value = 0 + Math.pow(x, y);
                    if (value >= -9007199254740991 && value <= 9007199254740991) {
                        return value;
                    }
                }
            }
            return exponentiate(x, y);
        };
        SmallBigInteger.signedRightShift = function(x, n) {
            return toResult(Internal.signedRightShift(valueOf(x), valueOf(n)));
        };
        SmallBigInteger.leftShift = function(x, n) {
            return toResult(Internal.leftShift(valueOf(x), valueOf(n)));
        };

        (global || globalThis).SmallBigInteger = SmallBigInteger;
        SmallBigInteger._getInternal = function() {
            return Internal;
        };
        SmallBigInteger._setInternal = function(newInternal) {
            Internal = newInternal;
        };
    }(globalThis));

    if (!globalThis.BigInteger) {
        globalThis.BigInteger = globalThis.SmallBigInteger;
    }

    //supportsBigInt = false;//!!!
    if (supportsBigInt) {
        globalThis.JSBI = BigIntWrapper; //!!!
        globalThis.BigInteger._setInternal(BigIntWrapper);
    } else if (globalThis.JSBI == null) {
        globalThis.JSBI = globalThis.BigInteger._getInternal();
    } else {
        globalThis.BigInteger._setInternal(JSBI);
    }

    var SmallBigInt = globalThis.BigInteger;
    self.SmallBigInt = SmallBigInt;
    //self.BigIntWrapper = BigIntWrapper;


})();

(function() {
    "use strict";

    // floor(S**(1/n)), S >= 1, n >= 2
    // https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method
    // https://stackoverflow.com/a/15979957/839199y
    function nthRoot(S, n) {
        if (!(S instanceof JSBI) || typeof n !== 'number' || Math.floor(n) !== n || n < 1 || n > Number.MAX_SAFE_INTEGER) {
            throw new RangeError();
        }
        if (n === 1) {
            return S;
        }
        var s = JSBI.toNumber(JSBI.add(S, JSBI.BigInt(0)));
        if (s === 0) {
            return JSBI.BigInt(0);
        }
        if (s < 0) {
            if (n % 2 === 0) {
                throw new RangeError();
            }
            return JSBI.unaryMinus(JSBI.BigInt(nthRoot(JSBI.unaryMinus(S), n)));
        }
        var B = Number.MAX_SAFE_INTEGER + 1;
        var E = Math.floor(B / (n === 2 ? 2 : Math.pow(2, 1 + Math.ceil(Math.log2(Math.log2(B))))));
        if (s < E) {
            //var test = function (n, f) { var i = 1; while (f(i**n - 1) === i - 1 && f(i**n) === i) { i += 1; } var a = i**n; while (f(a - 1) === i) { a -= Math.pow(2, 25); } console.log(n, Math.log2(a), a); };
            //test(2, function (a) { return Math.floor(Math.sqrt(a + 0.5)); });
            //for (var n = 3; n <= 53; n++) { test(n, function (a) { return Math.floor(Math.exp(Math.log(a + 0.5) / n)); }); }
            var g = n === 2 ? Math.floor(Math.sqrt(s + 0.5)) : Math.floor(Math.exp(Math.log(s + 0.5) / n));
            return JSBI.BigInt(g);
        }
        var g = n === 2 ? Math.sqrt(s) : Math.exp(Math.log(s) / n);
        if (g < E) {
            if (Math.floor(g - g / E) === Math.floor(g + g / E)) {
                return JSBI.BigInt(Math.floor(g));
            }
            var y = JSBI.BigInt(Math.floor(g + 0.5));
            return JSBI.lessThan(S, JSBI.exponentiate(y, JSBI.BigInt(n))) ? JSBI.subtract(y, JSBI.BigInt(1)) : y;
        }
        var size = S.toString(16).length * 4; // TODO: bitLength(S)
        if (size <= n) {
            return JSBI.BigInt(1);
        }
        var half = Math.floor((Math.floor(size / n) + 1) / 2);
        var x = JSBI.leftShift(JSBI.add(JSBI.BigInt(nthRoot(JSBI.signedRightShift(S, JSBI.BigInt(half * n)), n)), JSBI.BigInt(1)), JSBI.BigInt(half));
        var xprev = JSBI.unaryMinus(JSBI.BigInt(1));
        do {
            xprev = x;
            if (n === 2) {
                x = JSBI.signedRightShift(JSBI.add(x, JSBI.divide(S, x)), JSBI.BigInt(1));
            } else {
                x = JSBI.divide(JSBI.add(JSBI.multiply(JSBI.BigInt(n - 1), x), JSBI.divide(S, JSBI.exponentiate(x, JSBI.BigInt(n - 1)))), JSBI.BigInt(n));
            }
        } while (JSBI.lessThan(x, xprev));
        return xprev;
    }
    self.nthRoot = nthRoot;
})();
globalThis.wast2wasm = function(array) {
    return new Uint8Array(array);
};

(function() {
    "use strict";

    /*jshint esversion:11*/
    var MAX_SAFE_INTEGER = JSBI.BigInt(Number.MAX_SAFE_INTEGER);

    //TODO: https://en.wikipedia.org/wiki/Euclidean_algorithm#Method_of_least_absolute_remainders
    function numbersGCD(a, b) {
        while (b > 0) {
            var q = Math.floor(a / b);
            var r = a - q * b;
            a = b;
            b = r;
        }
        return a;
    }
    var wast = function(strings) {
        return String.raw({
            raw: strings
        });
    };
    var wastCode1 = [0, 97, 115, 109, 1, 0, 0, 0, 1, 7, 1, 96, 2, 126, 126, 1, 126, 2, 1, 0, 3, 2, 1, 0, 7, 7, 1, 3, 103, 99, 100, 0, 0, 10, 39, 1, 37, 1, 1, 126, 3, 64, 32, 1, 66, 0, 82, 4, 64, 2, 64, 32, 0, 32, 1, 130, 33, 2, 32, 1, 33, 0, 32, 2, 33, 1, 12, 2, 11, 11, 11, 32, 0, 11];
    var i64gcd = null;
    if (globalThis.WebAssembly != null) {
        try {
            i64gcd = new WebAssembly.Instance(new WebAssembly.Module(wast2wasm(wastCode1))).exports.gcd;
        } catch (error) {
            console.log(error);
        }
    }

    function EuclidsGCD(a, b) {
        while (JSBI.greaterThan(b, MAX_SAFE_INTEGER)) {
            var r = JSBI.remainder(a, b);
            a = b;
            b = r;
        }
        if (JSBI.greaterThan(b, JSBI.BigInt(0))) {
            if (JSBI.greaterThan(a, MAX_SAFE_INTEGER)) {
                var r = JSBI.remainder(a, b);
                a = b;
                b = r;
            }
            return JSBI.BigInt(numbersGCD(JSBI.toNumber(a), JSBI.toNumber(b)));
        }
        return a;
    }

    // https://github.com/tc39/proposal-bigint/issues/205
    // https://github.com/tc39/ecma262/issues/1729
    // floor(log2(a)) + 1 if a > 0
    function bitLength(a) {
        var s = a.toString(16);
        var c = s.charCodeAt(0) - 0 - '0'.charCodeAt(0);
        if (c <= 0) {
            throw new RangeError();
        }
        return (s.length - 1) * 4 + (32 - Math.clz32(Math.min(c, 8)));
    }

    // 1 + floor(log2(x))
    function log2(x) {
        var e = 0;
        while (x > 1 << 30) {
            x = Math.floor(x / (1 << 30));
            e += 30;
        }
        e += 32 - Math.clz32(x);
        return e;
    }
    var LOG2MAX = Math.floor(Math.log2(Number.MAX_SAFE_INTEGER + 1));
    var DIGITSIZE = LOG2MAX;
    var doubleDigitMethod = true;
    var wastCode2 = [0, 97, 115, 109, 1, 0, 0, 0, 1, 12, 1, 96, 4, 126, 126, 126, 126, 4, 126, 126, 126, 126, 2, 1, 0, 3, 2, 1, 0, 7, 10, 1, 6, 104, 101, 108, 112, 101, 114, 0, 0, 10, 144, 3, 1, 141, 3, 16, 1, 126, 1, 126, 1, 126, 1, 126, 1, 127, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 1, 127, 1, 126, 1, 126, 1, 126, 1, 126, 66, 1, 33, 4, 66, 0, 33, 5, 66, 0, 33, 6, 66, 1, 33, 7, 65, 7, 33, 8, 66, 63, 66, 1, 124, 33, 19, 3, 64, 32, 4, 33, 11, 32, 5, 33, 12, 32, 6, 33, 13, 32, 7, 33, 14, 32, 2, 33, 10, 32, 0, 33, 2, 3, 64, 32, 2, 33, 0, 32, 10, 33, 2, 32, 11, 33, 4, 32, 12, 33, 5, 32, 13, 33, 6, 32, 14, 33, 7, 32, 0, 32, 2, 128, 33, 9, 32, 0, 32, 2, 32, 9, 126, 125, 33, 10, 32, 6, 33, 11, 32, 7, 33, 12, 32, 4, 32, 9, 32, 6, 126, 125, 33, 13, 32, 5, 32, 9, 32, 7, 126, 125, 33, 14, 66, 0, 32, 7, 125, 121, 32, 7, 121, 124, 32, 9, 121, 124, 66, 63, 66, 1, 124, 86, 32, 13, 66, 0, 83, 66, 0, 32, 13, 125, 32, 10, 88, 32, 14, 32, 7, 125, 32, 2, 32, 10, 125, 84, 113, 113, 32, 14, 66, 0, 83, 66, 0, 32, 14, 125, 32, 10, 88, 32, 13, 32, 6, 125, 32, 2, 32, 10, 125, 84, 113, 113, 114, 113, 33, 15, 32, 15, 65, 0, 71, 13, 0, 11, 66, 0, 32, 0, 32, 4, 32, 5, 32, 4, 32, 5, 85, 27, 124, 121, 32, 0, 66, 0, 83, 27, 33, 16, 32, 16, 66, 0, 82, 4, 64, 2, 64, 32, 19, 32, 16, 32, 16, 32, 19, 85, 27, 33, 16, 32, 19, 32, 16, 125, 33, 19, 32, 1, 32, 19, 136, 33, 17, 32, 3, 32, 19, 136, 33, 18, 32, 1, 32, 17, 32, 19, 134, 125, 33, 1, 32, 3, 32, 18, 32, 19, 134, 125, 33, 3, 32, 4, 32, 17, 126, 32, 5, 32, 18, 126, 124, 32, 0, 32, 16, 134, 124, 33, 0, 32, 6, 32, 17, 126, 32, 7, 32, 18, 126, 124, 32, 2, 32, 16, 134, 124, 33, 2, 32, 8, 65, 1, 107, 33, 8, 11, 11, 32, 8, 65, 0, 71, 32, 16, 66, 0, 82, 113, 13, 0, 11, 32, 4, 32, 5, 32, 6, 32, 7, 11];
    var wasmHelper = null;
    if (true && globalThis.WebAssembly != null) {
        try {
            wasmHelper = new WebAssembly.Instance(new WebAssembly.Module(wast2wasm(wastCode2))).exports.helper;
            DIGITSIZE = 64;
        } catch (error) {
            console.log(error);
        }
    }
    var previousValue = -1;
    // some terrible optimization as bitLength is slow
    function bitLength2(a) {
        if (previousValue === -1) {
            previousValue = bitLength(a);
            return previousValue;
        }
        if (previousValue <= 1024) {
            var n = JSBI.toNumber(JSBI.BigInt(a));
            var x = Math.log2(n) + 1024 * 4 - 1024 * 4;
            var y = Math.ceil(x);
            if (x !== y) {
                previousValue = y;
                return y;
            }
        }
        var n = JSBI.toNumber(JSBI.signedRightShift(a, JSBI.BigInt(previousValue - DIGITSIZE)));
        if (n < 1 || n >= Number.MAX_SAFE_INTEGER + 1) {
            previousValue = -1;
            return bitLength2(a);
        }
        previousValue = previousValue - DIGITSIZE + log2(n);
        return previousValue;
    }

    // 2**n
    function exp2(n) {
        if (n < 0) {
            throw new RangeError();
        }
        var result = 1;
        while (n > 30) {
            n -= 30;
            result *= 1 << 30;
        }
        result *= 1 << n;
        return result;
    }

    function helper(X, Y) {
        if (!(X instanceof JSBI) || !(Y instanceof JSBI)) {
            throw new TypeError();
        }
        if (!doubleDigitMethod) {
            if (wasmHelper != null) {
                if (JSBI.equal(Y, JSBI.BigInt(0))) {
                    return [JSBI.BigInt(1), JSBI.BigInt(0), JSBI.BigInt(0), JSBI.BigInt(1)];
                }
                return wasmHelper(X, JSBI.BigInt(0), Y, JSBI.BigInt(0));
            }
            return jsHelper(JSBI.toNumber(X), 0, JSBI.toNumber(Y), 0);
        }
        if (wasmHelper != null) {
            if (DIGITSIZE !== 64) {
                throw new RangeError();
            }
            var x = JSBI.asUintN(64, JSBI.signedRightShift(X, JSBI.BigInt(64)));
            var xlo = JSBI.asUintN(64, X);
            var y = JSBI.asUintN(64, JSBI.signedRightShift(Y, JSBI.BigInt(64)));
            var ylo = JSBI.asUintN(64, Y);
            if (JSBI.equal(y, JSBI.BigInt(0))) {
                return [JSBI.BigInt(1), JSBI.BigInt(0), JSBI.BigInt(0), JSBI.BigInt(1)];
            }
            return wasmHelper(x, xlo, y, ylo);
        }
        var x = JSBI.signedRightShift(X, JSBI.BigInt(DIGITSIZE));
        var xlo = JSBI.asUintN(DIGITSIZE, X);
        var y = JSBI.signedRightShift(Y, JSBI.BigInt(DIGITSIZE));
        var ylo = JSBI.asUintN(DIGITSIZE, Y);
        return jsHelper(JSBI.toNumber(x), JSBI.toNumber(xlo), JSBI.toNumber(y), JSBI.toNumber(ylo));
    }

    function jsHelper(x, xlo, y, ylo) {
        // computes the transformation matrix, which is the product of all {{0, 1}, {1, -q}} matrices,
        // where q is the quotient produced by Euclid's algorithm for any pair of integers (a, b),
        // where a within [X << m; ((X + 1) << m) - 1] and b within [Y << m; ((Y + 1) << m) - 1]

        // 2x2-matrix transformation matrix of (x_initial, y_initial) into (x, y):
        var A = 1;
        var B = 0;
        var C = 0;
        var D = 1;
        var lobits = LOG2MAX;
        var bits = 1;
        for (var i = doubleDigitMethod ? 5 : 0; i >= 0 && bits !== 0; i -= 1) {
            var sameQuotient = y !== 0;
            while (sameQuotient) {
                //console.assert(y > 0);
                var q = Math.floor(+x / y);
                var y1 = x - q * y;
                // Multiply matrix augmented by column (x, y) by {{0, 1}, {1, -q}} from the right:
                var A1 = C;
                var B1 = D;
                var C1 = A - q * C;
                var D1 = B - q * D;
                // The quotient for a point (x_initial + alpha, y_initial + beta), where 0 <= alpha < 1 and 0 <= beta < 1:
                // floor((x + A * alpha + B * beta) / (y + C * alpha + D * beta))
                // As the sign(A) === -sign(B) === -sign(C) === sign(D) (ignoring zero entries) the maximum and minimum values are floor((x + A) / (y + C)) and floor((x + B) / (y + D))

                // floor((x + A) / (y + C)) === q  <=>  0 <= (x + A) - q * (y + C) < (y + C)  <=>  0 <= y1 + C1 < y + C
                // floor((x + B) / (y + D)) === q  <=>  0 <= (x + B) - q * (y + D) < (y + D)  <=>  0 <= y1 + D1 < y + D
                sameQuotient = 0 <= y1 + C1 && y1 + C1 < y + C && 0 <= y1 + D1 && y1 + D1 < y + D;
                //sameQuotient = C1 < 0 && -C1 <= y1 && D1 - D < y - y1 ||
                //               D1 < 0 && -D1 <= y1 && C1 - C < y - y1;
                if (sameQuotient) {
                    x = y;
                    y = y1;
                    A = A1;
                    B = B1;
                    C = C1;
                    D = D1;
                    //gcd.debug(q);
                }
            }

            if (i >= 1) {
                var b = LOG2MAX - 0 - log2(x + Math.max(A, B));
                bits = Math.min(Math.max(b, 0), lobits);
                var d = exp2(lobits - bits);
                var xlo1 = Math.floor(xlo / d);
                var ylo1 = Math.floor(ylo / d);
                xlo -= xlo1 * d;
                ylo -= ylo1 * d;
                lobits -= bits;
                var p = exp2(bits);
                x = A * xlo1 + B * ylo1 + x * p;
                y = C * xlo1 + D * ylo1 + y * p;
            }
        }
        return [JSBI.BigInt(A), JSBI.BigInt(B), JSBI.BigInt(C), JSBI.BigInt(D)];
    }
    var SUBQUADRATIC_HALFGCD_THRESHOLD = 4096;

    function matrixMultiply(A1, B1, C1, D1, A, B, C, D) {
        return [JSBI.add(JSBI.multiply(A1, A), JSBI.multiply(B1, C)), JSBI.add(JSBI.multiply(A1, B), JSBI.multiply(B1, D)), JSBI.add(JSBI.multiply(C1, A), JSBI.multiply(D1, C)), JSBI.add(JSBI.multiply(C1, B), JSBI.multiply(D1, D))];
    }

    function halfgcd(a, b, small) {
        //console.assert(a >= b && b >= 0n);

        // the function calculates the transformation matrix for numbers (x, y), where a <= x < a + 1 and b <= y < b + 1
        // seems, this definition is not the same as in https://mathworld.wolfram.com/Half-GCD.html

        // floor((a + 1) / b) < q = floor(a / b) < floor(a / (b + 1))
        // ([A, B], [C, D]) * (a + x, b + y) = (A*(a+x)+B*(b+y), C*(a+x)+D*(b+y)) = (A*a+B*b, C*a+D*b) + (A*x+B*y, C*x+D*y)
        //Note: for debugging it is useful to compare quotients in simple Euclidean algorithms vs quotients here

        if (small) {
            var $tmpA_B_C_D = helper(a, b);
            var A = $tmpA_B_C_D[0];
            var B = $tmpA_B_C_D[1];
            var C = $tmpA_B_C_D[2];
            var D = $tmpA_B_C_D[3];
            return [A, B, C, D, JSBI.BigInt(0), JSBI.BigInt(0)];
        }
        var size = bitLength(a);
        var isSmall = size <= SUBQUADRATIC_HALFGCD_THRESHOLD;
        var $newA = JSBI.BigInt(1);
        var $newB = JSBI.BigInt(0);
        var $newC = JSBI.BigInt(0);
        var $newD = JSBI.BigInt(1);
        var A = $newA;
        var B = $newB;
        var C = $newC;
        var D = $newD; // 2x2 matrix
        var step = 0;
        while (true) {
            // Q(T, a + 1n, b) === Q(T, a, b + 1n)
            step += 1;

            //console.assert(A * D >= 0 && B * C >= 0 && A * B <= 0 && D * C <= 0);//TODO: why - ?

            // A*(X+Y) = A*X+A*Y
            //var $newa1 = a + A; var $newb1 =  b + C; var a1 = $newa1; var b1 = $newb1; // T * (a_initial + 1n, b_initial);
            //var $newa2 = a + B; var $newb2 =  b + D; var a2 = $newa2; var b2 = $newb2; // T * (a_initial, b_initial + 1n);
            //if (!isSmall && n <= size * (2 / 3)) { // TODO: ?, the constant is based on some testing with some example
            //  return [A, B, C, D, a, b];
            //}
            var m = JSBI.BigInt(isSmall ? Math.max(0, bitLength2(a) - DIGITSIZE * (doubleDigitMethod ? 2 : 1)) : Math.floor(size / Math.pow(2, step)));
            if (step !== 1 /* && m1 < size / 2*/ ) {
                //?
                if (JSBI.notEqual(JSBI.signedRightShift(JSBI.add(a, A), m), JSBI.signedRightShift(JSBI.add(a, B), m)) || JSBI.notEqual(JSBI.signedRightShift(JSBI.add(b, C), m), JSBI.signedRightShift(JSBI.add(b, D), m))) {
                    return [A, B, C, D, a, b];
                }
            }
            var $tmpM0_M1_M2_M3_transformedAhi_transformedBhi = halfgcd(JSBI.signedRightShift(a, m), JSBI.signedRightShift(b, m), isSmall);
            var M0 = $tmpM0_M1_M2_M3_transformedAhi_transformedBhi[0];
            var M1 = $tmpM0_M1_M2_M3_transformedAhi_transformedBhi[1];
            var M2 = $tmpM0_M1_M2_M3_transformedAhi_transformedBhi[2];
            var M3 = $tmpM0_M1_M2_M3_transformedAhi_transformedBhi[3];
            var transformedAhi = $tmpM0_M1_M2_M3_transformedAhi_transformedBhi[4];
            var transformedBhi = $tmpM0_M1_M2_M3_transformedAhi_transformedBhi[5];
            var A1 = JSBI.BigInt(M0);
            var B1 = JSBI.BigInt(M1);
            var C1 = JSBI.BigInt(M2);
            var D1 = JSBI.BigInt(M3);
            if (step === 1) {
                var $newA = A1;
                var $newB = B1;
                var $newC = C1;
                var $newD = D1;
                A = $newA;
                B = $newB;
                C = $newC;
                D = $newD;
            } else {
                // T = T1 * T:
                var $tmpM4_M5_M6_M7 = matrixMultiply(A1, B1, C1, D1, A, B, C, D);
                var M4 = $tmpM4_M5_M6_M7[0];
                var M5 = $tmpM4_M5_M6_M7[1];
                var M6 = $tmpM4_M5_M6_M7[2];
                var M7 = $tmpM4_M5_M6_M7[3];
                A = JSBI.BigInt(M4);
                B = JSBI.BigInt(M5);
                C = JSBI.BigInt(M6);
                D = JSBI.BigInt(M7);
            }
            if (isSmall) {
                var $newa = JSBI.add(JSBI.multiply(A1, a), JSBI.multiply(B1, b));
                var $newb = JSBI.add(JSBI.multiply(C1, a), JSBI.multiply(D1, b));
                a = $newa;
                b = $newb; // T1 * (a, b)
            } else {
                var alo = JSBI.asUintN(JSBI.toNumber(m), a);
                var blo = JSBI.asUintN(JSBI.toNumber(m), b);
                var $newa = JSBI.add(JSBI.add(JSBI.multiply(A1, alo), JSBI.multiply(B1, blo)), JSBI.leftShift(transformedAhi, m));
                var $newb = JSBI.add(JSBI.add(JSBI.multiply(C1, alo), JSBI.multiply(D1, blo)), JSBI.leftShift(transformedBhi, m));
                a = $newa;
                b = $newb; // T * (alo, blo) + T * (ahi, bhi) * 2**m
            }

            console.assert(JSBI.greaterThan(a, JSBI.BigInt(0)) && JSBI.greaterThanOrEqual(b, JSBI.BigInt(0)));
            if (JSBI.equal(B1, JSBI.BigInt(0))) {
                console.assert(JSBI.equal(A1, JSBI.BigInt(1)) && JSBI.equal(B1, JSBI.BigInt(0)) && JSBI.equal(C1, JSBI.BigInt(0)) && JSBI.equal(D1, JSBI.BigInt(1)));
                if (JSBI.notEqual(b, JSBI.BigInt(0))) {
                    //TODO: ?
                    var q = JSBI.divide(JSBI.BigInt(a), b);
                    var C2 = JSBI.subtract(A, JSBI.multiply(q, C)),
                        D2 = JSBI.subtract(B, JSBI.multiply(q, D)),
                        b1 = JSBI.subtract(a, JSBI.multiply(q, b));
                    var sameQuotient = JSBI.greaterThanOrEqual(JSBI.add(b1, C2), JSBI.BigInt(0)) && JSBI.lessThan(JSBI.add(b1, C2), JSBI.add(b, C)) && JSBI.greaterThanOrEqual(JSBI.add(b1, D2), JSBI.BigInt(0)) && JSBI.lessThan(JSBI.add(b1, D2), JSBI.add(b, D));
                    if (!sameQuotient) {
                        return [A, B, C, D, a, b];
                    }
                    var $newA = C;
                    var $newB = D;
                    var $newC = C2;
                    var $newD = D2;
                    A = $newA;
                    B = $newB;
                    C = $newC;
                    D = $newD; // {{0, 1}, {1, -q}} * T
                    var $newa = b;
                    var $newb = b1;
                    a = $newa;
                    b = $newb; // {{0, 1}, {1, -q}} * (a, b)
                    //gcd.debug(q);
                } else {
                    return [A, B, C, D, a, b];
                }
            }
        }
        // see "2. General structure of subquadratic gcd algorithms" in “On Schönhage’s algorithm and subquadratic integer GCD computation” by Möller
        return [A, B, C, D, a, b]; // for performance transformedA and transformedB are returned
    }

    var SUBQUADRATIC_GCD_THRESHOLD = 32 * 1024;
    var LEHMERS_ALGORITHM_THRESHOLD = JSBI.BigInt(Math.pow(2, 68));

    // https://en.wikipedia.org/wiki/Lehmer%27s_GCD_algorithm
    // https://www.imsc.res.in/~kapil/crypto/notes/node11.html
    // this implementation is good after ~80 bits (?)
    function LehmersGCD(a, b) {
        if (JSBI.lessThan(a, b)) {
            var tmp = a;
            a = b;
            b = tmp;
        }

        // Subquadratic Lehmer's algorithm:
        while (JSBI.lessThan(JSBI.asUintN(SUBQUADRATIC_GCD_THRESHOLD, b), b)) {
            //console.assert(a >= b);
            var n = bitLength(a);
            var m = JSBI.BigInt(Math.floor(n * 2 / 3)); // 2/3 is somehow faster
            var $tmpA1_B1_C1_D1_transformedAhi_transformedBhi = halfgcd(JSBI.signedRightShift(a, m), JSBI.signedRightShift(b, m), false);
            var A1 = $tmpA1_B1_C1_D1_transformedAhi_transformedBhi[0];
            var B1 = $tmpA1_B1_C1_D1_transformedAhi_transformedBhi[1];
            var C1 = $tmpA1_B1_C1_D1_transformedAhi_transformedBhi[2];
            var D1 = $tmpA1_B1_C1_D1_transformedAhi_transformedBhi[3];
            var transformedAhi = $tmpA1_B1_C1_D1_transformedAhi_transformedBhi[4];
            var transformedBhi = $tmpA1_B1_C1_D1_transformedAhi_transformedBhi[5];
            if (JSBI.equal(B1, JSBI.BigInt(0))) {
                //console.assert(A1 === 1n && B1 === 0n && C1 === 0n && D1 === 1n);
                //gcd.debug(a / b);
                var $newa = b;
                var $newb = JSBI.remainder(a, b);
                a = $newa;
                b = $newb;
            } else {
                var alo = JSBI.asUintN(JSBI.toNumber(m), a);
                var blo = JSBI.asUintN(JSBI.toNumber(m), b);
                var $newa = JSBI.add(JSBI.add(JSBI.multiply(A1, alo), JSBI.multiply(B1, blo)), JSBI.leftShift(transformedAhi, m));
                var $newb = JSBI.add(JSBI.add(JSBI.multiply(C1, alo), JSBI.multiply(D1, blo)), JSBI.leftShift(transformedBhi, m));
                a = $newa;
                b = $newb; // T * (alo, blo) + T * (ahi, bhi) * 2**m
                if (JSBI.lessThan(a, JSBI.BigInt(0)) || JSBI.lessThan(b, JSBI.BigInt(0))) {
                    throw new TypeError("assertion");
                }
            }
        }

        // Lehmer's algorithm:
        while (JSBI.greaterThanOrEqual(b, LEHMERS_ALGORITHM_THRESHOLD)) {
            //console.assert(a >= b);
            var n = bitLength2(a);
            var m = JSBI.BigInt(Math.max(0, n - DIGITSIZE * (doubleDigitMethod ? 2 : 1)));
            var $tmpA1_B1_C1_D1 = helper(JSBI.signedRightShift(a, m), JSBI.signedRightShift(b, m));
            var A1 = $tmpA1_B1_C1_D1[0];
            var B1 = $tmpA1_B1_C1_D1[1];
            var C1 = $tmpA1_B1_C1_D1[2];
            var D1 = $tmpA1_B1_C1_D1[3];
            if (JSBI.equal(B1, JSBI.BigInt(0))) {
                //console.assert(A1 === 1n && B1 === 0n && C1 === 0n && D1 === 1n);
                //gcd.debug(a / b);
                var $newa = b;
                var $newb = JSBI.remainder(a, b);
                a = $newa;
                b = $newb;
            } else {
                var $newa = JSBI.add(JSBI.multiply(A1, a), JSBI.multiply(B1, b));
                var $newb = JSBI.add(JSBI.multiply(C1, a), JSBI.multiply(D1, b));
                a = $newa;
                b = $newb; // T * (a, b)
                if (JSBI.lessThan(a, JSBI.BigInt(0)) || JSBI.lessThan(b, JSBI.BigInt(0))) {
                    throw new TypeError("assertion");
                }
            }
        }
        return EuclidsGCD(a, b);
    }

    function abs(a) {
        return JSBI.lessThan(a, JSBI.BigInt(0)) ? JSBI.unaryMinus(a) : a;
    }

    function numberCTZ(a) {
        return 32 - (Math.clz32(a & -a) + 1);
    }

    function ctz(a) {
        var test = JSBI.asUintN(32, a);
        if (JSBI.notEqual(test, JSBI.BigInt(0))) {
            return numberCTZ(JSBI.toNumber(test));
        }
        var k = 32;
        while (JSBI.equal(JSBI.asUintN(k, a), JSBI.BigInt(0))) {
            k *= 2;
        }
        var n = 0;
        for (var i = Math.floor(k / 2); i >= 32; i = Math.floor(i / 2)) {
            if (JSBI.equal(JSBI.asUintN(i, a), JSBI.BigInt(0))) {
                n += i;
                a = JSBI.signedRightShift(a, JSBI.BigInt(i));
            } else {
                a = JSBI.asUintN(i, a);
            }
        }
        n += numberCTZ(JSBI.toNumber(JSBI.BigInt(JSBI.asUintN(32, a))));
        return n;
    }

    function bigIntGCD(a, b) {
        var A = abs(JSBI.BigInt(a));
        var B = abs(JSBI.BigInt(b));
        var na = JSBI.toNumber(A);
        var nb = JSBI.toNumber(B);
        if (Math.max(na, nb) <= Number.MAX_SAFE_INTEGER) {
            return JSBI.BigInt(numbersGCD(na, nb));
        }
        var abmin = Math.min(na, nb);
        if (abmin <= Number.MAX_SAFE_INTEGER) {
            if (abmin === 0) {
                return JSBI.add(A, B);
            }
            if (abmin === 1) {
                return JSBI.BigInt(1);
            }
            return JSBI.BigInt(numbersGCD(abmin, Math.abs(JSBI.toNumber(na < nb ? JSBI.remainder(B, A) : JSBI.remainder(A, B)))));
        }
        if (i64gcd != null && Math.max(na, nb) < Math.pow(2, 64)) {
            return JSBI.asUintN(64, i64gcd(A, B));
        }
        if (abmin > (Number.MAX_SAFE_INTEGER + 1) * (1 << 11)) {
            var c1 = ctz(A);
            var c2 = ctz(B);
            if (c1 + c2 >= 4) {
                var g = LehmersGCD(c1 === 0 ? A : JSBI.signedRightShift(A, JSBI.BigInt(c1)), c2 === 0 ? B : JSBI.signedRightShift(B, JSBI.BigInt(c2)));
                var c = Math.min(c1, c2);
                return c === 0 ? g : JSBI.leftShift(JSBI.BigInt(g), JSBI.BigInt(c));
            }
        }
        return LehmersGCD(A, B);
    }
    self.bigIntGCD = bigIntGCD;
})();

(function() {
    "use strict";

    function log2(x) {
        return JSBI.BigInt(x.toString(16).length * 4);
    }

    function modPow(base, exponent, modulus) {
        var accumulator = JSBI.BigInt(1);
        while (JSBI.notEqual(exponent, JSBI.BigInt(0))) {
            if (JSBI.equal(JSBI.asUintN(1, exponent), JSBI.BigInt(1))) {
                exponent = JSBI.subtract(exponent, JSBI.BigInt(1));
                accumulator = JSBI.remainder(JSBI.multiply(accumulator, base), modulus);
            }
            exponent = JSBI.signedRightShift(exponent, JSBI.BigInt(1));
            base = JSBI.remainder(JSBI.multiply(base, base), modulus);
        }
        return accumulator;
    }

    function FastModBigInt(a) {
        var array = [];
        while (JSBI.notEqual(a, JSBI.BigInt(0))) {
            var x = JSBI.toNumber(JSBI.asUintN(51, a));
            array.push(x);
            a = JSBI.signedRightShift(a, JSBI.BigInt(51));
        }
        return array;
    }

    function FastMod(array, integer) {
        var n = array.length - 1;
        var result = array[n];
        var v = integer;
        var inv = (1 + Math.pow(2, -52)) / v;
        result -= Math.floor(result * inv) * v;
        if (n > 0) {
            var x = Math.pow(2, 51) - Math.floor(Math.pow(2, 51) * inv) * v;
            var i = n;
            do {
                i -= 1;
                result = result * x + array[i];
                result -= Math.floor(result * inv) * v;
            } while (i !== 0);
        }
        return result;
    }

    function range(start, end) {
        var a = [];
        for (var i = start; i <= end; i += 1) {
            a.push(i);
        }
        return a;
    }

    function isPrime(n) {
        if (!(n instanceof JSBI)) {
            throw new RangeError();
        }
        if (JSBI.lessThan(n, JSBI.BigInt(2))) {
            throw new RangeError();
        }
        var s = JSBI.toNumber(JSBI.remainder(n, JSBI.BigInt(30)));
        if (s % 2 === 0) {
            return JSBI.equal(n, JSBI.BigInt(2));
        }
        if (s % 3 === 0) {
            return JSBI.equal(n, JSBI.BigInt(3));
        }
        if (s % 5 === 0) {
            return JSBI.equal(n, JSBI.BigInt(5));
        }
        var wheel3 = [0, 4, 6, 10, 12, 16, 22, 24, 24];
        var N = FastModBigInt(n);
        for (var i = 7, max = Math.min(1024, Math.floor(Math.sqrt(JSBI.toNumber(n)))); i <= max; i += 30) {
            for (var j = 0; j < wheel3.length; j += 1) {
                var p = i + wheel3[j];
                if (FastMod(N, p) === 0) {
                    return false;
                }
            }
        }
        if (JSBI.toNumber(n) < 1024 * 1024) {
            return true;
        }

        // https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test#Deterministic_variants
        var r = 0;
        var d = JSBI.subtract(n, JSBI.BigInt(1));
        while (JSBI.equal(JSBI.remainder(d, JSBI.BigInt(2)), JSBI.BigInt(0))) {
            d = JSBI.divide(d, JSBI.BigInt(2));
            r += 1;
        }
        // https://en.wikipedia.org/wiki/Miller–Rabin_primality_test#Testing_against_small_sets_of_bases
        var values = [10, 20, 24, 31, 40, 41, 48, 48, 61, 61, 61, 78, 81];
        var primes = [2, 3, 5, 7, 11, 13, 17, 17, 19, 19, 19, 23, 29];
        var i = 0;
        var x = Math.ceil(Math.log2(JSBI.toNumber(n)));
        while (x > values[i] && i < values.length) {
            i += 1;
        }
        var bases = null;
        if (i < values.length) {
            bases = primes.slice(0, i + 1);
        } else {
            // https://primes.utm.edu/prove/prove2_3.html
            var lnN = JSBI.toNumber(log2(n)) * Math.log(2);
            bases = range(2, Math.floor(1 / Math.log(2) * lnN * Math.log(lnN)));
        }
        for (var iteratora = bases[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
            var x = modPow(JSBI.BigInt(a), d, n);
            if (JSBI.notEqual(x, JSBI.BigInt(1))) {
                for (var i = r - 1; i > 0 && JSBI.notEqual(x, JSBI.subtract(n, JSBI.BigInt(1))); i -= 1) {
                    x = JSBI.remainder(JSBI.multiply(x, x), n);
                }
                if (JSBI.notEqual(x, JSBI.subtract(n, JSBI.BigInt(1)))) {
                    return false;
                }
            }
        }
        return true;
    }
    self.isPrime = isPrime;
})();
(function() {
    "use strict";
    /*jshint esversion:6, bitwise:false*/

    var BitSetWordSize = 31; // see https://v8.dev/blog/pointer-compression

    function packedArray(n) {
        // `%DebugPrint(array)` in `node --allow-native-syntax`
        // see https://v8.dev/blog/elements-kinds
        var array = [];
        for (var i = 0; i < n; i++) {
            array.push(0);
        }
        return array.slice(0); // slice to reduce the size of the internal storage
    }

    function BitSet(size) {
        var n = Math.ceil(size / (4 * BitSetWordSize)) * 4;
        this.data = packedArray(n);
        this.size = size;
    }
    BitSet.prototype.nextSetBit = function(index) {
        if ((index | 0) >= (this.size | 0)) {
            return -1;
        }
        var data = this.data;
        var q = Math.floor(index / BitSetWordSize);
        var r = index % BitSetWordSize;
        var x = data[q] >> r;
        while (x === 0) {
            q += 1;
            if (q === data.length) {
                return -1;
            }
            x = data[q];
            r = 0;
        }
        if (x === (-1 << (BitSetWordSize - 1))) {
            // -x overflows
            r += BitSetWordSize - 1;
        } else {
            // https://stackoverflow.com/questions/61442006/whats-the-most-efficient-way-of-getting-position-of-least-significant-bit-of-a
            r += 31 - Math.clz32(x & -(+x));
        }
        return q * BitSetWordSize + r;
    };
    BitSet.prototype.toggle = function(index) {
        if ((index | 0) >= (this.size | 0)) {
            throw new RangeError();
        }
        var q = Math.floor(index / BitSetWordSize);
        var r = index % BitSetWordSize;
        this.data[q] ^= (r === BitSetWordSize - 1 ? ((-1) << r) : (1 << r));
    };
    BitSet.prototype.xor = function(other) {
        var a = this.data;
        var b = other.data;
        var n = a.length | 0;
        if (n !== b.length || n % 4 !== 0) {
            throw new RangeError();
        }
        for (var i = 0; i < n; i += 4) {
            a[i + 0] ^= b[i + 0] | 0;
            a[i + 1] ^= b[i + 1] | 0;
            a[i + 2] ^= b[i + 2] | 0;
            a[i + 3] ^= b[i + 3] | 0;
        }
    };
    BitSet.prototype.clear = function() {
        for (var i = 0; i < this.data.length; i += 1) {
            this.data[i] = 0;
        }
    };
    BitSet.prototype.toString = function() {
        return this.data.map(function(x) {
            return (x >>> 0).toString(2).padStart(BitSetWordSize, '0').split('').reverse().join('');
        }).join('').slice(0, this.size);
    };



    // pass factorizations with associated values to the next call
    // returns linear combinations of vectors which result in zero vector by modulo 2
    // (basis of the kernel of the matrix)
    function solve(matrixSize, bitsetRows) {
        bitsetRows = bitsetRows == undefined ? false : bitsetRows;

        // We build the augmented matrix in row-echelon form with permuted rows, which can grow up to matrixSize rows:
        // The augmented matrix is stored in the lower triangle!
        var M = new Array(matrixSize).fill(null); // We will fill the matrix so pivot elements will be placed on the diagonal
        var associatedValues = new Array(matrixSize).fill(undefined);
        var nextSolution = null;
        var state = 1;
        var iterator = {
            next: function solve(rawRowAndValue) {
                while (true) {
                    if (state === 1) {
                        state = 0;
                        return {
                            value: nextSolution,
                            done: false
                        };
                    }
                    state = 1;
                    var rawRow = rawRowAndValue[0];
                    var associatedValue = rawRowAndValue[1];
                    var row = null;
                    if (bitsetRows) {
                        row = rawRow;
                    } else {
                        row = new BitSet(matrixSize);
                        var reverseColumns = true; // makes it much faster when the data is more dense from the beginning (?)
                        for (var j = 0; j < rawRow.length; j++) {
                            var unitaryColumn = rawRow[j];
                            var c = reverseColumns ? matrixSize - 1 - unitaryColumn : unitaryColumn;
                            row.toggle(c);
                        }
                    }
                    // add row to the matrix maintaining it to be in row-echelon form:
                    for (var pivotColumn = row.nextSetBit(0); pivotColumn !== -1 && row != null; pivotColumn = row == null ? -1 : row.nextSetBit(pivotColumn + 1)) {
                        var pivotRow = M[pivotColumn];
                        if (pivotRow != null) {
                            // row-reduction:
                            row.xor(pivotRow);
                            //console.assert(row.nextSetBit(pivotColumn) > pivotColumn || row.nextSetBit(pivotColumn) === -1);
                            row.toggle(pivotColumn);
                        } else {
                            //row.toggle(matrixSize + pivotColumn);
                            associatedValues[pivotColumn] = associatedValue;
                            M[pivotColumn] = row;
                            row = null;
                        }
                    }
                    if (row != null) {
                        // row has a solution
                        // extract solution from the augmented part of the matrix:
                        var solution = [];
                        for (var i = row.nextSetBit(0); i !== -1; i = row.nextSetBit(i + 1)) {
                            solution.push(associatedValues[i]);
                        }
                        solution.push(associatedValue);
                        nextSolution = solution;
                    } else {
                        nextSolution = null;
                    }
                }
                //console.log(M.filter(function (x) { return x != null; }).map(function (x) { return x.toString(); }).join('\n').replaceAll('0', ' '))
            }
        };
        iterator[globalThis.Symbol.iterator] = function() {
            return this;
        };
        return iterator;
    }

    // sparseColumns,
    // build a matrix, do eliminations, ...
    // keep indexes

    function SparseGF2Matrix(n, m) {
        this.rows = new Array(n).fill(null);
        this.columns = new Array(m).fill(null).map(function(x) {
            return [];
        });
    }
    SparseGF2Matrix.prototype.addRow = function(rawRow, rowIndex) {

        function removePairs(rawRow) {
            var row = rawRow.slice(0);
            row.sort(function(a, b) {
                return a - b;
            });
            var k = -1;
            for (var i = 0; i < row.length; i++) {
                if (i === 0 || row[k] !== row[i]) {
                    k += 1;
                    row[k] = row[i];
                } else {
                    k -= 1;
                }
            }
            return row.slice(0, k + 1);
        }
        var row = removePairs(rawRow);

        this.rows[rowIndex] = row;
        for (var i = 0; i < row.length; i++) {
            this.columns[row[i]].push(rowIndex);
        }
    };
    SparseGF2Matrix.prototype.deleteColumn = function(columnIndex) {
        var column = this.columns[columnIndex];
        if (column != null) {
            for (var i = 0; i < column.length; i++) {
                var rowIndex = column[i];
                var k = this.rows[rowIndex].indexOf(columnIndex);
                console.assert(k !== -1);
                this.rows[rowIndex].splice(k, 1);
            }
            this.columns[columnIndex] = null;
        }
    };

    SparseGF2Matrix.prototype.deleteRow = function(rowIndex) {
        var row = this.rows[rowIndex];
        if (row != null) {
            for (var i = 0; i < row.length; i++) {
                var columnIndex = row[i];
                this.columns[columnIndex] = this.columns[columnIndex].filter(function(r) {
                    return r != rowIndex;
                });
            }
            this.rows[rowIndex] = null;
        }
    };

    SparseGF2Matrix.prototype.reduce = function(rowIndex, xors) {
        var row = this.rows[rowIndex];
        console.assert(row.length === 1);
        var e = row[0];
        var column = this.columns[e];
        for (var i = column.length - 1; i >= 0; i--) {
            if (column[i] !== rowIndex) {
                var j = column[i];
                var a = this.rows[j];
                var k = a.indexOf(e);
                console.assert(k !== -1);
                a.splice(k, 1);
                column.splice(i, 1);
                xors.push({
                    a: j,
                    b: rowIndex
                });
            }
        }
        console.assert(column.length === 1 && column[0] === rowIndex);
        this.columns[e] = null;
        this.rows[rowIndex] = null;
    };


    // structured Gaussian elimination:
    // see The Factorization of the Ninth Fermat Number (Author(s): A. K. Lenstra, H. W. Lenstra, Jr., M. S. Manasse, J. M. Pollard), page 344
    // and Solving Large Sparse Linear Systems Over Finite Fields (B. A. LaMacchia • A.M. Odlyzko)
    function sparseSolve(columnsCount) {
        if (columnsCount < 1024 * 2) {
            return solve(columnsCount);
        }

        function getKthLargest(array, k) {
            array.sort(function(a, b) {
                return a - b;
            });
            return array[Math.max(array.length - k, 0)];
        }

        function deleteNonSparseColumns(sparseMatrix, count) {
            var counts = sparseMatrix.columns.map(function(c) {
                return c == null ? 0 : c.length;
            });
            var t = getKthLargest(counts, count);
            for (var i = 0; i < sparseMatrix.columns.length; i++) {
                var column = sparseMatrix.columns[i];
                if (column != null && column.length >= t) {
                    sparseMatrix.deleteColumn(i);
                }
            }
        }

        function eliminateRowsWithSingleColumn(sparseMatrix, eliminatedColumns) {
            var rows = [];
            for (var i = 0; i < sparseMatrix.rows.length; i++) {
                var row = sparseMatrix.rows[i];
                if (row != null && row.length === 1) {
                    rows.push(i);
                }
            }
            for (var i = 0; i < rows.length; i++) {
                var rowIndex = rows[i];
                var row = sparseMatrix.rows[rowIndex];
                if (row != null && row.length === 1) {
                    sparseMatrix.reduce(rowIndex, xors);
                    eliminatedColumns[row[0]] = true;
                } else {
                    console.assert(row != null && row.length === 0);
                }
            }
            return rows.length;
        }

        var M = [];
        var data = [];
        var xors = [];
        var newMatrix = null;
        var solutions = null;
        var lastJ = -1;

        function calculateNewMatrix() {
            var FIRST_SPARSE_PRIME_INDEX = 2585;

            var sparseMatrix = new SparseGF2Matrix(M.length, columnsCount);
            for (var i = 0; i < M.length; i++) {
                sparseMatrix.addRow(M[i].filter(function(p) {
                    return p >= FIRST_SPARSE_PRIME_INDEX;
                }), i);
            }

            var eliminatedColumns = new Array(columnsCount).fill(false);

            var S = 128;
            var sparseColumns = -1;
            do {
                sparseColumns = sparseMatrix.columns.reduce(function(p, column) {
                    return p + (column == null ? 0 : 1);
                }, 0);
                //console.log('!sparseColumns:', sparseColumns);
                var c = Math.ceil(sparseMatrix.rows.length / S) - eliminateRowsWithSingleColumn(sparseMatrix, eliminatedColumns);
                if (c > 0) {
                    deleteNonSparseColumns(sparseMatrix, c);
                }
            } while (sparseColumns > 0);

            var newColumnIds = new Array(columnsCount).fill(0);
            var k = 0;
            for (var i = 0; i < sparseMatrix.columns.length; i++) {
                if (!eliminatedColumns[i]) {
                    newColumnIds[i] = k;
                    k += 1;
                } else {
                    newColumnIds[i] = -1;
                }
            }
            var newColumnsCount = k;

            var pool = [];

            function getNewRow(row) {
                var newRow = null;
                if (pool.length > 0) {
                    newRow = pool.pop();
                    newRow.clear();
                } else {
                    newRow = new BitSet(newColumnsCount);
                }
                for (var j = 0; j < row.length; j++) {
                    var e = newColumnIds[row[j]];
                    if (e !== -1) {
                        newRow.toggle(newColumnsCount - 1 - e);
                    }
                }
                return newRow;
            }
            //newMatrix = M.map(function (row) { return getNewRow(row); });

            //trying to reduce the memory usage by new rows:
            newMatrix = M.map(function(row) {
                return null;
            });
            var lastUsage = sparseMatrix.rows.map(function(row) {
                return (row != null ? 1 / 0 : -1);
            });
            for (var i = xors.length - 1; i >= 0; i -= 1) {
                if (lastUsage[xors[i].a] !== -1) {
                    if (lastUsage[xors[i].b] === -1) {
                        lastUsage[xors[i].b] = i;
                    }
                } else {
                    xors[i] = null;
                }
            }
            var newRow = function(i, j) {
                if (newMatrix[i] == null) {
                    console.assert(lastUsage[i] >= j);
                    newMatrix[i] = getNewRow(M[i]);
                }
                var result = newMatrix[i];
                return result;
            };

            for (var i = 0; i < xors.length; i++) {
                if (xors[i] != null) {
                    newRow(xors[i].a, i).xor(newRow(xors[i].b, i));
                    if (lastUsage[xors[i].b] <= i) {
                        pool.push(newMatrix[xors[i].b]);
                        newMatrix[xors[i].b] = null;
                    }
                }
            }

            for (var i = 0; i < sparseMatrix.rows.length; i++) {
                if (sparseMatrix.rows[i] != null) {
                    console.assert(sparseMatrix.rows[i].length === 0);
                    newMatrix[i] = newRow(i, 1 / 0);
                } else {
                    newMatrix[i] = null;
                }
            }

            /*console.time('n1');
            var template = packedArray(newColumnsCount);
            newMatrix = newMatrix.map(function (row) {
              if (row == null) {
                return null;
              }
              var k = 0;
              var from = -1;
              from = row.nextSetBit(from + 1);
              while (from !== -1) {
                template[k] = from;
                k += 1;
                from = row.nextSetBit(from + 1);
              }
              return template.slice(0, k);
            });
            console.timeEnd('n1');*/

            //console.log('newMatrix', newMatrix.filter(function (x) { return x != null; }).length);

            //var start = Date.now();
            solutions = solve(newColumnsCount, true); // find products of Y_k = Y, so that Y is a perfect square
            solutions.next();
        }

        var firstTime = true;
        var iterator = {
            next: function sparseSolve(rawRowAndValue) {
                if (firstTime) {
                    firstTime = false;
                    return {
                        value: null,
                        done: false
                    };
                }
                if (solutions == null) {
                    if (M.length < columnsCount + 32) {
                        M.push(rawRowAndValue[0]);
                        data.push(rawRowAndValue[1]);
                        return {
                            value: null,
                            done: false
                        };
                    }
                    calculateNewMatrix();
                }
                for (var j = lastJ + 1; j < newMatrix.length; j++) {
                    lastJ = j;
                    var row = newMatrix[j];
                    if (row != null) {
                        var solution = solutions.next([row, j]).value;
                        if (solution != null) {
                            //console.log('c', c.length);
                            var set = new Array(M.length).fill(0);
                            for (var i = 0; i < solution.length; i++) {
                                if (set[solution[i]] !== 0) {
                                    throw new RangeError();
                                }
                                set[solution[i]] = 1;
                            }
                            for (var i = xors.length - 1; i >= 0; i--) {
                                if (xors[i] != null && set[xors[i].a] === 1) {
                                    set[xors[i].b] = 1 - set[xors[i].b];
                                }
                            }
                            //console.log('solution', solution, Array.from(s));
                            var newSolution = [];
                            for (var i = 0; i < set.length; i++) {
                                if (set[i] === 1) {
                                    newSolution.push(data[i]);
                                }
                            }
                            //console.log('a', Date.now() - start);
                            return {
                                value: newSolution,
                                done: false
                            };
                        }
                    }
                }
            }
        };
        iterator[globalThis.Symbol.iterator] = function() {
            return this;
        };
        return iterator;
    }

    solve.solve = solve;
    solve.sparseSolve = sparseSolve;
    sparseSolve.solve = solve;
    sparseSolve.sparseSolve = sparseSolve;

    self.solve = solve;

})();
(function() {
    "use strict";

    // https://rosettacode.org/wiki/Tonelli-Shanks_algorithm#Python

    function modPowSmall(base, exponent, modulus) {
        var accumulator = 1;
        while (exponent !== 0) {
            if (exponent % 2 === 0) {
                exponent /= 2;
                base = (base * base) % modulus;
            } else {
                exponent -= 1;
                accumulator = (accumulator * base) % modulus;
            }
        }
        return accumulator;
    }

    function legendre(a, p) {
        console.assert((p - 1) % 2 === 0);
        return modPowSmall(a, (p - 1) / 2, p);
    }

    function sqrtMod(n, p) {
        // Tonelli–Shanks algorithm:
        console.assert(p * p <= Number.MAX_SAFE_INTEGER);
        if (legendre(n, p) !== 1) {
            // not a square (mod p)
            return -1;
        }
        var q = p - 1;
        var s = 0;
        while (q % 2 === 0) {
            q /= 2;
            s += 1;
        }
        if (s === 1) {
            return modPowSmall(n, (p + 1) / 4, p);
        }
        var z = 2;
        while (z <= p && p - 1 !== legendre(z, p)) {
            z += 1;
        }
        var c = modPowSmall(z, q, p);
        var r = modPowSmall(n, (q + 1) / 2, p);
        var t = modPowSmall(n, q, p);
        var m = s;
        var t2 = 0;
        while ((t - 1) % p !== 0) {
            t2 = (t * t) % p;
            var i = 1;
            while (i <= m && (t2 - 1) % p !== 0) {
                t2 = (t2 * t2) % p;
                i += 1;
            }
            var b = modPowSmall(c, 1 << (m - i - 1), p);
            r = (r * b) % p;
            c = (b * b) % p;
            t = (t * c) % p;
            m = i;
        }
        return r;
    }

    self.sqrtMod = sqrtMod;

})();
globalThis.wast2wasm = function(array) {
    return new Uint8Array(array);
};

(function() {
    "use strict";

    /*jshint esversion:11, bitwise:false*/
    function modInverse(a, m) {
        if (!(a instanceof JSBI) || !(m instanceof JSBI)) {
            throw new TypeError();
        }
        if (JSBI.lessThan(a, JSBI.BigInt(0)) || JSBI.greaterThanOrEqual(a, m) || JSBI.lessThanOrEqual(m, JSBI.BigInt(0))) {
            throw new RangeError();
        }
        // We use the extended Euclidean algorithm:
        var oldR = a;
        var r = m;
        var oldS = JSBI.BigInt(1);
        var s = JSBI.BigInt(0);
        while (JSBI.notEqual(r, JSBI.BigInt(0))) {
            var q = JSBI.divide(JSBI.subtract(oldR, JSBI.remainder(oldR, r)), r); // floor(oldR / r)
            var newR = JSBI.subtract(oldR, JSBI.multiply(q, r));
            oldR = r;
            r = newR;
            var newS = JSBI.subtract(oldS, JSBI.multiply(q, s));
            oldS = s;
            s = newS;
        }
        if (JSBI.notEqual(oldR, JSBI.BigInt(1))) {
            return JSBI.BigInt(0);
        }
        return JSBI.lessThan(oldS, JSBI.BigInt(0)) ? JSBI.add(oldS, m) : oldS;
    }

    function modInverseSmall(a, m) {
        if (typeof a !== 'number' || typeof m !== 'number') {
            throw new TypeError();
        }
        var maxSMI = ~(-1 << 30);
        if (a < 0 || a >= m || m <= 0 || m > maxSMI) {
            throw new RangeError();
        }
        // We use the extended Euclidean algorithm:
        var oldR = a & maxSMI;
        var r = m & maxSMI;
        var oldS = 1;
        var s = 0;
        while (r !== 0) {
            var q = Math.floor(oldR / r);
            var newR = oldR % r;
            oldR = r;
            r = newR;
            var newS = oldS - q * s;
            oldS = s;
            s = newS;
        }
        if (oldR !== 1) {
            return 0;
        }
        return oldS < 0 ? oldS + m : oldS;
    }

    function ChineseRemainderTheorem(r1, r2, m1, m2) {
        if (!(r1 instanceof JSBI) || !(r2 instanceof JSBI) || !(m1 instanceof JSBI) || !(m2 instanceof JSBI)) {
            throw new TypeError();
        }
        // https://en.wikipedia.org/wiki/Chinese_remainder_theorem#Case_of_two_moduli
        // x = r1 (mod m1)
        // x = r2 (mod m2)
        var c = modInverse(JSBI.remainder(m1, m2), m2);
        return JSBI.add(r1, JSBI.multiply(JSBI.remainder(JSBI.multiply(JSBI.subtract(r2, r1), c), m2), m1));
    }

    function squareRootsModuloOddPrimesProduct(n, primes, e) {
        e = e == undefined ? 1 : e;

        // Chinese Remainder Theorem idea from https://en.wikipedia.org/wiki/Quadratic_residue#Complexity_of_finding_square_roots
        var result = [];
        result.push(JSBI.BigInt(0));
        var P = JSBI.BigInt(1);
        for (var i = 0; i < primes.length; i += 1) {
            var p = JSBI.BigInt(Math.pow(primes[i], e));
            if (JSBI.toNumber(p) > Number.MAX_SAFE_INTEGER) {
                throw new RangeError();
            }
            var x2 = JSBI.BigInt(squareRootModuloOddPrime(JSBI.toNumber(JSBI.remainder(n, p)), primes[i], e));
            var result2 = [];
            for (var j = 0; j < result.length; j += 1) {
                var x1 = result[j];
                result2.push(ChineseRemainderTheorem(x1, x2, P, p));
                result2.push(ChineseRemainderTheorem(x1, JSBI.unaryMinus(x2), P, p));
            }
            P = JSBI.multiply(P, p);
            result = result2;
        }
        return result;
    }

    function squareRootsModuloTwo(n, e) {
        e = e == undefined ? 1 : e;
        if (e >= 3) {
            if (n % 8 === 1) {
                // from Cohen H.
                var m = Math.pow(2, e);
                var candidate = +squareRootsModuloTwo(n, e - 1)[0];
                var candidate2 = m / 4 - candidate;
                var r = candidate * candidate % m !== n ? candidate2 : candidate;
                return [r, m / 2 - r, m / 2 + r, m - r];
            }
            return [];
        }
        if (e >= 2) {
            if (n % 4 === 1) {
                return [1, 3];
            }
            return [];
        }
        if (e >= 1) {
            return [1];
        }
        return [];
    }

    function squareRootModuloOddPrime(n, p, e) {
        e = e == undefined ? 1 : e;
        // slow for non-small p
        if (typeof n !== 'number' || typeof p !== 'number' || typeof e !== 'number') {
            throw new TypeError();
        }
        var m = Math.pow(p, e);
        if (!(n > 0 && n < m && p > 0 && e >= 1 && +n % +p !== 0 && m < Math.floor(Math.sqrt(Number.MAX_SAFE_INTEGER * 4)))) {
            // + p is a prime number
            throw new RangeError();
        }
        if (p % 2 === 0) {
            throw new RangeError();
        }
        // r**2 == n (mod p)
        if (e > 1) {
            var x = squareRootModuloOddPrime(n % Math.pow(p, e - 1), p, e - 1);
            // x**2 = n mod p**(e - 1)
            // x1 = x + a * p**(e-1)
            // x1**2 = x**2 + (a * p**(e-1))**2 + 2*x*a*p**(e-1) = n mod p**e
            // a*p**(e-1) = (n - x**2) * (2*x)**-1 mod p**e
            var inv = modInverseSmall(2 * x, m) % m;
            var v = (n - x * x) % m;
            inv = inv > m / 2 ? inv - m : inv; // use sign bit
            v = v > m / 2 ? v - m : v; // use sign bit
            var x1 = x + v * inv % m;
            if (x1 >= m) {
                x1 -= m;
            }
            if (x1 < 0) {
                x1 += m;
            }
            if (x1 > m - x1) {
                x1 = m - x1;
            }
            return x1;
        }
        if ((p + 1) % 4 === 0) {
            // from https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus :
            var r = modPowSmall(n, (p + 1) / 4, p);
            if (r * r % p === n) {
                if (r > p - r) {
                    r = p - r;
                }
                return r;
            }
        }
        if (true) {
            var r = sqrtMod(n, p) | 0;
            return Math.min(r, p - r);
        }
        var rrmnmodp = 1 - n; // r**2 % p - n
        for (var tworm1 = -1; true; tworm1 += 2) {
            rrmnmodp += tworm1;
            if (rrmnmodp >= p) {
                rrmnmodp -= p;
            }
            if (rrmnmodp === 0) {
                var r = Math.floor((tworm1 + 1) / 2);
                return r;
            }
        }
        throw new RangeError();
    }

    function bitLength(x) {
        return JSBI.BigInt(x.toString(16).length * 4);
    }

    function sqrt(x) {
        if (JSBI.lessThan(x, JSBI.BigInt((Number.MAX_SAFE_INTEGER + 1) / 2))) {
            return JSBI.BigInt(Math.floor(Math.sqrt(JSBI.toNumber(JSBI.BigInt(x)) + 0.5)));
        }
        var q = JSBI.signedRightShift(bitLength(x), JSBI.BigInt(2));
        var initialGuess = JSBI.leftShift(JSBI.add(sqrt(JSBI.signedRightShift(x, JSBI.multiply(q, JSBI.BigInt(2)))), JSBI.BigInt(1)), q);
        var a = initialGuess;
        var b = JSBI.add(a, JSBI.BigInt(1));
        while (JSBI.lessThan(a, b)) {
            b = a;
            a = JSBI.signedRightShift(JSBI.add(b, JSBI.divide(x, b)), JSBI.BigInt(1));
        }
        return b;
    }

    function getSmoothFactorization(a, base) {
        var value = JSBI.BigInt(a);
        if (JSBI.equal(value, JSBI.BigInt(0))) {
            return [0];
        }
        var result = [];
        if (JSBI.lessThan(value, JSBI.BigInt(0))) {
            result.push(-1);
            value = JSBI.unaryMinus(value);
        }
        var i = 0;
        while (i < base.length) {
            var p = base[i];
            while (JSBI.equal(JSBI.remainder(value, JSBI.BigInt(p)), JSBI.BigInt(0))) {
                value = JSBI.divide(value, JSBI.BigInt(p));
                result.push(p);
            }
            i += 1;
        }
        return JSBI.equal(value, JSBI.BigInt(1)) ? result : null;
    }

    //TODO: REMOVE(?)
    function getSmoothFactorizationOld(a, base) {
        var value = JSBI.BigInt(a);
        if (JSBI.equal(value, JSBI.BigInt(0))) {
            return [0];
        }
        var result = [];
        if (JSBI.lessThan(value, JSBI.BigInt(0))) {
            result.push(-1);
            value = JSBI.unaryMinus(value);
        }
        var i = 0;
        var fastValue = FastModBigInt(value);
        var isBig = JSBI.greaterThan(value, JSBI.BigInt(Number.MAX_SAFE_INTEGER));
        while (i < base.length && isBig) {
            var p = base[i];
            while (+FastMod(fastValue, p) === 0) {
                value = JSBI.divide(value, JSBI.BigInt(p));
                fastValue = FastModBigInt(value);
                isBig = JSBI.greaterThan(value, JSBI.BigInt(Number.MAX_SAFE_INTEGER));
                result.push(p);
            }
            i += 1;
        }
        var n = JSBI.toNumber(value);
        while (i < base.length) {
            var p = +base[i];
            while (n - Math.floor(n / p) * p === 0) {
                n /= p;
                result.push(p);
            }
            if (n !== 1 && n < p * p) {
                // n should be prime (?)
                var index = indexOf(base, n);
                if (index === -1) {
                    return null;
                }
                result.push(n);
                return result;
            }
            i += 1;
        }
        return n === 1 ? result : null;
    }

    // (X**2 - Y) % N === 0, where Y is a smooth number
    function CongruenceOfsquareOfXminusYmoduloN(X, Y, N) {
        this.X = X;
        this.Y = Y;
        this.N = N;
    }
    CongruenceOfsquareOfXminusYmoduloN.prototype.toString = function() {
        return 'X**2 ≡ Y (mod N)'.replaceAll('X', this.X).replaceAll('N', this.N).replaceAll('Y', this.Y.join(' * '));
    };

    function isQuadraticResidueModuloPrime(a, p) {
        if (!(a instanceof JSBI) || typeof p !== 'number') {
            throw new TypeError();
        }
        if (p === 2) {
            // "Modulo 2, every integer is a quadratic residue." - https://en.wikipedia.org/wiki/Quadratic_residue#Prime_modulus
            return true;
        }
        // https://en.wikipedia.org/wiki/Euler%27s_criterion
        var amodp = JSBI.toNumber(JSBI.remainder(JSBI.BigInt(a), JSBI.BigInt(p)));
        if (amodp === 0) {
            return true;
        }
        console.assert(p % 2 === 1);
        var value = modPowSmall(amodp, (p - 1) / 2, p);
        console.assert(value === 1 || value === p - 1);
        return value === 1;
    }

    function log(N) {
        var e = Math.max(JSBI.toNumber(bitLength(N)) - 4 * 12, 0);
        var lnn = Math.log(JSBI.toNumber(JSBI.signedRightShift(N, JSBI.BigInt(e)))) + Math.log(2) * e;
        return lnn;
    }

    function L(N) {
        // exp(sqrt(log(n)*log(log(n))))
        var lnn = log(N);
        return Math.exp(Math.sqrt(lnn * Math.log(lnn)));
    }

    function modPowSmall(base, exponent, modulus) {
        if (typeof base !== 'number' || typeof exponent !== 'number' || typeof modulus !== 'number') {
            throw new TypeError();
        }
        if (Math.max(Math.pow(modulus, 2), Math.pow(base, 2)) > Number.MAX_SAFE_INTEGER) {
            throw new RangeError();
        }
        var accumulator = 1;
        while (exponent !== 0) {
            if (exponent % 2 === 0) {
                exponent /= 2;
                base = +base * +base % modulus;
            } else {
                exponent -= 1;
                accumulator = accumulator * base % modulus;
            }
        }
        return accumulator;
    }

    function modPow(base, exponent, modulus) {
        if (!(base instanceof JSBI) || !(exponent instanceof JSBI) || !(modulus instanceof JSBI)) {
            throw new TypeError();
        }
        var e = exponent;
        var b = base;
        var accumulator = JSBI.BigInt(1);
        while (JSBI.notEqual(e, JSBI.BigInt(0))) {
            if (JSBI.equal(JSBI.asUintN(1, e), JSBI.BigInt(1))) {
                e = JSBI.subtract(e, JSBI.BigInt(1));
                accumulator = JSBI.remainder(JSBI.multiply(accumulator, b), modulus);
            }
            e = JSBI.signedRightShift(e, JSBI.BigInt(1));
            b = JSBI.remainder(JSBI.multiply(b, b), modulus);
        }
        return accumulator;
    }

    function primes(MAX) {
        // Note: it is slow in Chrome to create array this way when MAX >= 2**25
        var sieve = new Array(MAX + 1).fill(true);
        var result = [];
        result.push(2);
        for (var i = 3; i <= MAX; i += 2) {
            if (sieve[i]) {
                result.push(i);
                if (i <= Math.floor(MAX / i)) {
                    for (var j = i * i; j <= MAX; j += 2 * i) {
                        sieve[j] = false;
                    }
                }
            }
        }
        return result;
    }

    //!copy-paste

    function FastModBigInt(a) {
        var array = [];
        while (JSBI.notEqual(a, JSBI.BigInt(0))) {
            var x = JSBI.toNumber(JSBI.asUintN(51, a));
            array.push(x);
            a = JSBI.signedRightShift(a, JSBI.BigInt(51));
        }
        return array;
    }

    function FastMod(array, integer) {
        var n = array.length - 1;
        var result = array[n];
        var v = integer;
        var inv = (1 + Math.pow(2, -52)) / v;
        result = result - Math.floor(result * inv) * v;
        if (n > 0) {
            var x = Math.pow(2, 51) - Math.floor(Math.pow(2, 51) * inv) * v;
            var i = n;
            do {
                i -= 1;
                result = result * x + array[i];
                result = result - Math.floor(result * inv) * v;
            } while (i !== 0);
        }
        return result;
    }

    //squareRootModuloOddPrime(4865648, 9749, 2)  // huge size of p**e

    function exp2(x) {
        var y = Math.floor(Math.pow(2, Math.floor(x)) * Math.exp(Math.LN2 * (x - Math.floor(x))));
        if (y % 2 === 0) {
            y += 1;
        }
        return y;
    }
    var useMultiplePolynomials = true;

    // (A * x + B)**2 - N = A * (A * x**2 + 2 * B * x + C), A * C = B**2 - N
    function QuadraticPolynomial(A, B, N, AFactors) {
        if (!(A instanceof JSBI) || !(B instanceof JSBI) || !(N instanceof JSBI)) {
            throw new TypeError();
        }
        var AC = JSBI.subtract(JSBI.multiply(B, B), N);
        if (JSBI.notEqual(JSBI.remainder(AC, A), JSBI.BigInt(0))) {
            throw new TypeError();
        }
        var C = JSBI.divide(AC, A);
        this.A = A;
        this.B = B;
        this.C = C;
        this.AFactors = AFactors;
        var logA = log(A);
        var u = -Math.exp(log(B) - logA);
        var v = Math.exp(log(N) / 2 - logA);
        this.x1 = u - v;
        this.x2 = u + v;
        this.log2a = logA / Math.LN2;
    }
    QuadraticPolynomial.generator = function(M, primes, N) {
        // see https://www.cs.virginia.edu/crab/QFS_Simple.pdf for multiple primes optimization
        var getCombinations = function(elements, k) {
            if (elements.length === 0) {
                return [];
            }
            if (k === 0) {
                return [
                    []
                ];
            }
            if (k === 1) {
                return elements.map(function(e) {
                    return [e];
                });
            }
            return getCombinations(elements.slice(1), k - 1).map(function(c) {
                return [elements[0]].concat(c);
            }).concat(getCombinations(elements.slice(1), k));
        };
        var nthRootApprox = function(A, n) {
            if (!(A instanceof JSBI)) {
                throw new TypeError();
            }
            var e = bitLength(A);
            return Math.round(JSBI.lessThanOrEqual(e, JSBI.BigInt(1023)) ? Math.pow(JSBI.toNumber(A), 1 / n) : Math.pow(JSBI.toNumber(JSBI.signedRightShift(A, JSBI.subtract(e, JSBI.BigInt(1023)))), 1 / n) * Math.pow(2, JSBI.toNumber(JSBI.subtract(e, JSBI.BigInt(1023))) / n));
        };
        var S = JSBI.divide(JSBI.BigInt(sqrt(JSBI.multiply(JSBI.BigInt(2), N))), JSBI.BigInt(M));
        var e = log(S) / Math.log(2);
        if (primes.length < 42) {
            throw new TypeError(); //TODO:
        }

        var max1 = Math.log2(primes[primes.length - 1]);
        var k = Math.max(2, Math.ceil(e / Math.min(14.5, max1) / 2) * 2); // number of small primes
        //console.debug(k);
        var p = nthRootApprox(S, k);
        var s = 0;
        var nextPrime = function() {
            var p3 = 0;
            do {
                p3 = p - p % 2 + 1 + (s % 2 === 0 ? s : -1 - s);
                s += 1;
            } while (indexOf(primes, p3) === -1);
            return p3;
        };
        var combinations = [];
        var polynomials = [];
        var elements = [];
        QuadraticSieveFactorization.polynomialsCounter = 0;
        return {
            next: function generator() {
                while (polynomials.length === 0) {
                    // There must be at least two different primes from previous selections. - from https://www.rieselprime.de/ziki/Self-initializing_quadratic_sieve
                    while (combinations.length === 0) {
                        var p3 = nextPrime();
                        var p4 = nextPrime();
                        console.assert(k % 2 === 0);
                        combinations = getCombinations(elements, k / 2 - 1).map(function(c) {
                            return [
                                [p3, p4]
                            ].concat(c);
                        });
                        elements.push([p3, p4]);
                        //console.log(elements.length, combinations.length, p**k / Number(S));
                    }

                    var qPrimes = combinations.pop().reduce(function(array, pair) {
                        return array.concat(pair);
                    }, []);
                    var q = JSBI.BigInt(qPrimes.reduce(function(p, a) {
                        return JSBI.multiply(p, JSBI.BigInt(a));
                    }, JSBI.BigInt(1)));
                    var qInv = modInverse(JSBI.remainder(q, N), N);
                    if (JSBI.equal(qInv, JSBI.BigInt(0))) {
                        //TODO: what to do here - ?
                        return this.next();
                    }
                    var A = q;
                    var Bs = squareRootsModuloOddPrimesProduct(N, qPrimes, 1);
                    for (var i = 0; i < Bs.length; i += 1) {
                        Bs[i] = JSBI.lessThan(Bs[i], JSBI.BigInt(0)) ? JSBI.subtract(A, Bs[i]) : Bs[i];
                    }
                    Bs.sort(function(a, b) {
                        return JSBI.toNumber(JSBI.subtract(JSBI.BigInt(a), JSBI.BigInt(b)));
                    });
                    for (var i = 0; i < Bs.length / 2; i += 1) {
                        var B = Bs[i];
                        polynomials.push(new QuadraticPolynomial(A, B, N, qPrimes));
                    }
                }
                QuadraticSieveFactorization.polynomialsCounter += 1;
                return polynomials.shift();
            }
        };
    };
    QuadraticPolynomial.prototype.X = function(x) {
        return JSBI.add(JSBI.multiply(this.A, JSBI.BigInt(x)), this.B);
    };
    QuadraticPolynomial.prototype.Y = function(x, s, primes) {
        if (typeof x !== 'number') {
            throw new TypeError();
        }
        var Y = JSBI.add(JSBI.add(JSBI.multiply(this.A, x * x >= Math.pow(2, 53) ? JSBI.multiply(JSBI.BigInt(x), JSBI.BigInt(x)) : JSBI.BigInt(x * x)), JSBI.multiply(this.B, JSBI.BigInt(2 * x))), this.C);
        if (JSBI.notEqual(JSBI.remainder(Y, s), JSBI.BigInt(0))) {
            return null;
        }
        var YFactors = getSmoothFactorization(JSBI.divide(Y, s), primes);
        if (YFactors == null) {
            return null;
        }
        if (YFactors.length === 1 && YFactors[0] === 0) {
            return YFactors;
        }
        return this.AFactors.concat(YFactors);
    };
    QuadraticPolynomial.prototype.log2AbsY = function(x) {
        if (typeof x !== 'number') {
            throw new TypeError();
        }
        //var v1 = Math.log2(Math.abs(Number(this.Y(x))));
        var v2 = Math.log2(Math.abs((x - this.x1) * (x - this.x2))) + this.log2a;
        return v2;
    };

    function thresholdApproximationInterval(polynomial, x, threshold, sieveSize) {
        var w = sieveSize > 2048 ? sieveSize > Math.pow(2, 18) ? 1024 : 256 : 1;
        while (w >= 2 && Math.abs(polynomial.log2AbsY(x + w) - threshold) > 0.5) {
            w = Math.floor(w / 2);
        }
        return x + w;
    }

    // https://ru.wikipedia.org/wiki/Алгоритм_Диксона
    // https://www.youtube.com/watch?v=TvbQVj2tvgc
    // https://www.rieselprime.de/ziki/Self-initializing_quadratic_sieve

    function packedIntArray(n) {
        var array = [];
        for (var i = 0; i < n; i += 1) {
            array.push(0);
        }
        return array.slice(0);
    }

    function AsmModule(stdlib, foreign, heap) {
        "use asm";

        var wheelData = new stdlib.Int32Array(heap);
        var wheelData16 = new stdlib.Uint16Array(heap);
        var SIEVE_SEGMENT = new stdlib.Uint8Array(heap);

        function singleBlockSieve(startWheelData, endWheelData, subsegmentEnd, s, p) {
            startWheelData = startWheelData | 0;
            endWheelData = endWheelData | 0;
            subsegmentEnd = subsegmentEnd | 0;
            s = s | 0;
            p = p | 0;
            //if (subsegmentEnd > SIEVE_SEGMENT.length || endWheel > wheelData.length || startWheel < 0) {
            //  return 1;
            //}
            var step = 0;
            var log2p = 0;
            var kpplusr = 0;
            var kpplusr2 = 0;
            var tmp = 0;
            var wheel = 0;
            var k = 0;
            var k2 = 0;
            step = p;
            for (wheel = startWheelData;
                (wheel | 0) < (endWheelData | 0); wheel = wheel + 12 | 0) {
                kpplusr = wheelData[wheel >> 2] | 0;
                kpplusr2 = wheelData[wheel + 4 >> 2] | 0;
                log2p = wheelData16[wheel + 8 >> 1] | 0;
                step = step + (wheelData16[wheel + 10 >> 1] | 0) | 0;
                while ((kpplusr2 | 0) < (subsegmentEnd | 0)) {
                    SIEVE_SEGMENT[kpplusr] = (SIEVE_SEGMENT[kpplusr] | 0) + log2p | 0;
                    kpplusr = kpplusr + step | 0;
                    SIEVE_SEGMENT[kpplusr2] = (SIEVE_SEGMENT[kpplusr2] | 0) + log2p | 0;
                    kpplusr2 = kpplusr2 + step | 0;
                }
                if ((kpplusr | 0) < (subsegmentEnd | 0)) {
                    SIEVE_SEGMENT[kpplusr] = (SIEVE_SEGMENT[kpplusr] | 0) + log2p | 0;
                    kpplusr = kpplusr + step | 0;
                    tmp = kpplusr;
                    kpplusr = kpplusr2;
                    kpplusr2 = tmp;
                }
                wheelData[wheel >> 2] = kpplusr - s | 0;
                wheelData[wheel + 4 >> 2] = kpplusr2 - s | 0;
            }
            return 0;
        }

        function findSmoothEntry(thresholdApproximation, i) {
            thresholdApproximation = thresholdApproximation | 0;
            i = i | 0;
            while ((thresholdApproximation | 0) >= (SIEVE_SEGMENT[i] | 0)) {
                i = i + 1 | 0;
            }
            return i | 0;
        }
        return {
            singleBlockSieve: singleBlockSieve,
            findSmoothEntry: findSmoothEntry
        };
    }
    var wast = function(strings) {
        return String.raw({
            raw: strings
        });
    };
    var wastCode = [0, 97, 115, 109, 1, 0, 0, 0, 1, 16, 2, 96, 5, 127, 127, 127, 127, 127, 1, 127, 96, 2, 127, 127, 1, 127, 2, 15, 1, 3, 101, 110, 118, 6, 109, 101, 109, 111, 114, 121, 2, 0, 0, 3, 3, 2, 0, 1, 7, 38, 2, 16, 115, 105, 110, 103, 108, 101, 66, 108, 111, 99, 107, 83, 105, 101, 118, 101, 0, 0, 15, 102, 105, 110, 100, 83, 109, 111, 111, 116, 104, 69, 110, 116, 114, 121, 0, 1, 10, 250, 1, 2, 202, 1, 8, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 32, 4, 33, 5, 32, 0, 33, 12, 3, 64, 32, 12, 32, 1, 72, 4, 64, 2, 64, 32, 12, 40, 2, 0, 33, 7, 32, 12, 40, 2, 4, 33, 8, 32, 12, 47, 1, 8, 33, 6, 32, 5, 32, 12, 47, 1, 10, 106, 33, 5, 3, 64, 32, 8, 32, 2, 72, 4, 64, 2, 64, 32, 7, 32, 7, 45, 0, 0, 32, 6, 106, 58, 0, 0, 32, 7, 32, 5, 106, 33, 7, 32, 8, 32, 8, 45, 0, 0, 32, 6, 106, 58, 0, 0, 32, 8, 32, 5, 106, 33, 8, 12, 2, 11, 11, 11, 32, 7, 32, 2, 72, 4, 64, 2, 64, 32, 7, 32, 7, 45, 0, 0, 32, 6, 106, 58, 0, 0, 32, 7, 32, 5, 106, 33, 7, 32, 7, 33, 11, 32, 8, 33, 7, 32, 11, 33, 8, 11, 11, 32, 12, 32, 7, 32, 3, 107, 54, 2, 0, 32, 12, 32, 8, 32, 3, 107, 54, 2, 4, 32, 12, 65, 12, 106, 33, 12, 12, 2, 11, 11, 11, 65, 0, 15, 11, 44, 1, 1, 123, 32, 0, 253, 15, 33, 2, 3, 64, 32, 1, 253, 0, 4, 0, 32, 2, 253, 44, 253, 83, 69, 4, 64, 2, 64, 32, 1, 65, 16, 106, 33, 1, 12, 2, 11, 11, 11, 32, 1, 15, 11];
    var wasmModule = null;

    function instantiateWasm(memorySize) {
        if (wasmModule == null) {
            var code = wast2wasm(wastCode);
            wasmModule = new WebAssembly.Module(code);
        }
        var pages = Math.ceil(memorySize / Math.pow(2, 16));
        var memory = new WebAssembly.Memory({
            initial: pages,
            maximum: pages
        });
        var buffer = memory.buffer;
        var exports = new WebAssembly.Instance(wasmModule, {
            env: {
                memory: memory
            }
        }).exports;
        return Object.assign({}, exports, {
            memory: {
                buffer: buffer
            }
        });
    }

    // TOWO: WebAssembly (~17% faster)
    function instantiate(memorySize) {
        if (true && globalThis.WebAssembly != null) {
            try {
                return instantiateWasm(memorySize);
            } catch (error) {
                console.error(error);
            }
        }
        var buffer = new ArrayBuffer(memorySize);
        var exports = AsmModule(globalThis, null, buffer);
        return Object.assign({}, exports, {
            memory: {
                buffer: buffer
            }
        });
    }

    function congruencesUsingQuadraticSieve(primes, N, sieveSize0) {
        if (!(N instanceof JSBI)) {
            throw new TypeError();
        }
        var sieveSize1 = Number(sieveSize0 || 0);
        if (sieveSize1 === 0) {
            sieveSize1 = 3 * Math.pow(2, 14);
            sieveSize1 = Math.min(sieveSize1, Math.ceil(Math.pow(+primes[primes.length - 1], 1.15)));
            sieveSize1 = Math.max(sieveSize1, primes[primes.length - 1] + 1);
        }
        //console.debug('sieveSize1', Math.log2(sieveSize1));

        var q = Math.ceil(sieveSize1 / (navigator.hardwareConcurrency === 12 ? 2.75 * Math.pow(2, 20) : 6 * Math.pow(2, 20)));
        console.debug('q', q);
        var segmentSize = Math.ceil(Math.ceil(sieveSize1 / q) / 48) * 48;
        var sieveSize = segmentSize * q;
        var SHIFT = 0;
        var MAX = 255;
        var SCALE = Math.pow(2, 0); //TODO:

        var log2B = Math.log2(primes.length === 0 ? Math.sqrt(2) : +primes[primes.length - 1]);
        var twoB = log2B + Math.min(8.5, log2B);
        var largePrimes = new Map(); // faster (?)

        // see https://www.youtube.com/watch?v=TvbQVj2tvgc
        var wheels0 = [];
        for (var i = 0; i < primes.length; i += 1) {
            var p = +primes[i];
            for (var beta = 1, pInBeta = p; pInBeta <= sieveSize || beta === 1; beta += 1, pInBeta *= p) {
                var nmodpInBeta = JSBI.toNumber(JSBI.remainder(N, JSBI.BigInt(pInBeta)));
                if (nmodpInBeta % p === 0) {
                    //console.warn('N has a factor in prime base', N, p);
                } else {
                    if (p === 2) {
                        var roots = squareRootsModuloTwo(nmodpInBeta, beta);
                        for (var j = 0; j < Math.ceil(roots.length / 2); j += 1) {
                            wheels0.push({
                                step: pInBeta,
                                p: p,
                                root: roots[j] | 0
                            });
                        }
                    } else {
                        var root = squareRootModuloOddPrime(nmodpInBeta, p, beta);
                        wheels0.push({
                            step: pInBeta,
                            p: p,
                            root: root | 0
                        });
                    }
                }
            }
        }
        wheels0.sort(function(a, b) {
            return +a.step - +b.step;
        });
        var wheelRoots = packedIntArray(wheels0.length);

        function nextValidHeapSize(size) {
            size = Math.max(size, Math.pow(2, 12));
            if (size <= Math.pow(2, 24)) {
                return Math.pow(2, Math.ceil(Math.log2(size - 0.5)));
            }
            return Math.ceil(size / Math.pow(2, 24)) * Math.pow(2, 24);
        }
        var bufferSize = nextValidHeapSize(segmentSize + wheels0.length * 3 * 4);
        var exports = instantiate(bufferSize);
        var singleBlockSieve = exports.singleBlockSieve;
        var findSmoothEntry = exports.findSmoothEntry;
        var arrayBuffer = exports.memory.buffer;
        var SIEVE_SEGMENT = new Uint8Array(arrayBuffer);
        var wheelData = new Int32Array(arrayBuffer);
        console.assert(segmentSize % 4 === 0);
        var wheelDataOffset = segmentSize / 4;
        var wheelsCount = wheels0.length;
        var wheelLogs = [];
        var previous = 0;
        for (var i = 0; i < wheelsCount; i += 1) {
            var w = wheels0[i];
            var wheel = wheelDataOffset + i * 3;
            var log = Math.round(Math.log2(w.p) * (w.step === 2 ? 0.5 : 1) * SCALE) | 0;
            var gap = (w.step | 0) - previous;
            if (gap >= Math.pow(2, 14) || log >= Math.pow(2, 14)) {
                throw new RangeError();
            }
            previous = w.step;
            wheelData[wheel] = 0;
            wheelData[wheel + 1] = 0;
            wheelData[wheel + 2] = log | gap << 16;
            wheelRoots[i] = w.root | 0;
            wheelLogs.push(Math.log2(w.p) * (w.step === 2 ? 0.5 : 1));
        }
        var lpStrategy = function(p, polynomial, x, pb) {
            // https://ru.wikipedia.org/wiki/Алгоритм_Диксона#Стратегия_LP
            var lp = largePrimes.get(p);
            if (lp == undefined) {
                // storing polynomial + x has smaller memory usage
                largePrimes.set(p, {
                    polynomial: polynomial,
                    x: x,
                    pb: pb
                });
            } else {
                var s = JSBI.BigInt(p);
                var sInverse = modInverse(s, N);
                if (JSBI.equal(sInverse, JSBI.BigInt(0))) {
                    return new CongruenceOfsquareOfXminusYmoduloN(s, [0], N); //?
                } else {
                    var X = polynomial.X(x);
                    var Y = polynomial.Y(x, s, pb);
                    var lpX = lp.polynomial.X(lp.x);
                    var lpY = lp.polynomial.Y(lp.x, s, lp.pb);
                    var X1 = JSBI.remainder(JSBI.multiply(JSBI.multiply(sInverse, lpX), X), N);
                    if (Y != null && lpY != null) {
                        var Y1 = Y.concat(lpY);
                        return new CongruenceOfsquareOfXminusYmoduloN(X1, Y1, N);
                    }
                }
            }
            return null;
        };
        var polynomialGenerator = useMultiplePolynomials ? QuadraticPolynomial.generator(sieveSize / 2, primes, N) : null;
        var polynomial = null;
        var baseOffsets = null;
        if (!useMultiplePolynomials) {
            var baseOffset = JSBI.add(JSBI.BigInt(sqrt(N)), JSBI.BigInt(1));
            polynomial = new QuadraticPolynomial(JSBI.BigInt(1), baseOffset, N, []);
            baseOffsets = packedIntArray(wheels0.length);
            // - Number(baseOffset % BigInt(pInBeta))
            for (var i = 0; i < wheels0.length; i += 1) {
                baseOffsets[i] = JSBI.toNumber(JSBI.remainder(baseOffset, JSBI.BigInt(wheels0[i].step))) | 0;
            }
        }
        var invCacheKey = JSBI.BigInt(0);
        var invCache = packedIntArray(wheels0.length);

        function checkWheels(offset) {
            var p = 0;
            for (var k = 0; k < wheelsCount; k += 1) {
                var wheel = wheelDataOffset + k * 3;
                p += wheelData[wheel + 2] >> 16;
                for (var v = 0; v <= 1; v += 1) {
                    var root = v === 0 ? wheelData[wheel] : wheelData[wheel + 1];
                    if (root !== sieveSize) {
                        var x = JSBI.BigInt(+root + offset);
                        var X = JSBI.add(JSBI.multiply(polynomial.A, x), polynomial.B);
                        var Y = JSBI.subtract(JSBI.multiply(X, X), N);
                        if (JSBI.notEqual(JSBI.remainder(Y, polynomial.A), JSBI.BigInt(0)) || JSBI.notEqual(JSBI.remainder(JSBI.divide(Y, polynomial.A), JSBI.BigInt(p)), JSBI.BigInt(0))) {
                            throw new Error();
                        }
                    }
                }
            }
        }
        var updateWheels = function(polynomial, offset) {
            offset = -0 + offset;
            //recalculate roots based on the formula:
            //proot = ((-B + root) * modInv(A, p)) % p;
            //+some optimizations to minimize bigint usage and modInverseSmall calls
            var AA = FastModBigInt(polynomial.A);
            var BB = FastModBigInt(polynomial.B);
            var useCache = JSBI.equal(JSBI.BigInt(polynomial.A), JSBI.BigInt(invCacheKey));
            var p = -0;
            for (var i = 0; i < wheelsCount; i += 1) {
                var wheel = wheelDataOffset + ((i << 1) + i | 0) | 0;
                p = p + +(wheelData[wheel + 2] >> 16);
                var root = -0 + (wheelRoots[i] | 0);
                if (!useCache) {
                    //var a = Number(polynomial.A % BigInt(p));
                    var a = +FastMod(AA, p);
                    invCache[i] = -0 + modInverseSmall(a, p);
                }
                var invA = +invCache[i];
                //var b = Number(polynomial.B % BigInt(p));
                var pInv = (1 + Math.pow(2, -52)) / p;
                var b = +FastMod(BB, p);
                if (invA === 0) {
                    // single root:
                    // x = (2B)^-1*(-C) (mod p)
                    // skip as the performance is not better
                    wheelData[wheel] = sieveSize;
                    wheelData[wheel + 1] = sieveSize;
                } else {
                    var e = p - b + p;
                    var x1 = (e + root) * invA - offset;
                    var x2 = (e - root) * invA - offset;
                    x1 = x1 - Math.floor(x1 * pInv) * p;
                    x2 = x2 - Math.floor(x2 * pInv) * p;
                    var r1 = x1 | 0; // x1 mod p
                    var r2 = x2 | 0; // x2 mod p
                    var s = r1 - r2 & r1 - r2 >> 31;
                    wheelData[wheel] = r2 + s; // min(r1, r2)
                    wheelData[wheel + 1] = r1 - s; // max(r1, r2)
                }
            }

            invCacheKey = polynomial.A;
            //checkWheels(offset);
        };

        var gcd = function(a, b) {
            while (b !== 0) {
                var r = +a % +b;
                a = b;
                b = r;
            }
            return a;
        };
        var lcm = function(a, b) {
            return Math.floor(a / gcd(a, b)) * b;
        };
        var getSmallWheels = function() {
            var p = 1;
            var i = 0;
            while (i < wheels0.length && lcm(p, wheels0[i].step) <= segmentSize / 5) {
                p = lcm(p, wheels0[i].step);
                i += 1;
            }
            return i;
        };
        var smallWheels = getSmallWheels();
        var copyCycle = function(array, cycleLength, limit) {
            if (typeof limit !== 'number' || typeof cycleLength !== 'number') {
                throw new TypeError();
            }
            if (limit > array.length) {
                throw new RangeError();
            }
            for (var i = cycleLength; i < limit; i += cycleLength) {
                array.copyWithin(i, 0, Math.min(limit - i, cycleLength));
            }
        };
        var updateSieveSegment = function(segmentStart) {
            if (typeof segmentStart !== 'number') {
                throw new TypeError();
            }
            var cycleLength = 1;
            SIEVE_SEGMENT[0] = SHIFT;
            var p = 0;
            for (var j = 0; j < smallWheels; j += 1) {
                var wheel = wheelDataOffset + ((j << 1) + j | 0) | 0;
                var newCycleLength = +lcm(cycleLength, p + (wheelData[wheel + 2] >> 16));
                copyCycle(SIEVE_SEGMENT, cycleLength, newCycleLength);
                cycleLength = newCycleLength;
                p = p + (wheelData[wheel + 2] >> 16) | 0;
                var log2p = wheelData[wheel + 2] & 0xFFFF;
                for (var k = ((wheelData[wheel] | 0) + newCycleLength - segmentStart % newCycleLength) % p; k < newCycleLength; k += p) {
                    SIEVE_SEGMENT[k] = SIEVE_SEGMENT[k] + log2p | 0;
                }
                for (var k = ((wheelData[wheel + 1] | 0) + newCycleLength - segmentStart % newCycleLength) % p; k < newCycleLength; k += p) {
                    SIEVE_SEGMENT[k] = SIEVE_SEGMENT[k] + log2p | 0;
                }
            }
            copyCycle(SIEVE_SEGMENT, cycleLength, segmentSize);
            //for (var j = 0; j < segmentSize; j += 1) {
            //  SIEVE_SEGMENT[j] = SHIFT;
            //}
            // "Block Sieving Algorithms" by Georg Wambach and Hannes Wettig May 1995
            var m = navigator.hardwareConcurrency === 12 ? 1 : 1.5;
            var V = Math.min(0 + wheelsCount - smallWheels, Math.floor(64 * 3 * m * (wheelsCount > Math.pow(2, 18) ? 2 : 1)));
            var S = Math.floor(Math.pow(2, 15) * m - V * 4);
            var subsegmentEnd = 0;
            console.assert(wheelDataOffset % 3 === 0);
            while (subsegmentEnd + S <= segmentSize) {
                subsegmentEnd += S;
                singleBlockSieve(smallWheels * 12 + wheelDataOffset * 4, smallWheels * 12 + V * 12 + wheelDataOffset * 4, subsegmentEnd, 0, p);
            }
            singleBlockSieve(smallWheels * 12 + wheelDataOffset * 4, wheelsCount * 12 + wheelDataOffset * 4, segmentSize, segmentSize, p);
        };
        var smoothEntries = [];
        var smoothEntries2 = [];
        var smoothEntries3 = [];
        var findSmoothEntries = function(offset, polynomial) {
            if (typeof offset !== "number") {
                throw new TypeError();
            }
            var i = 0;
            var thresholdApproximation = 0;
            while (i < segmentSize) {
                // it is slow to compute the threshold on every iteration, so trying to optimize:

                //TODO: the threshold calculation is much more simple in the Youtube videos (?)
                thresholdApproximation = Math.round((polynomial.log2AbsY(i + offset) - twoB) * SCALE + SHIFT) | 0;
                var j = Math.min(segmentSize, thresholdApproximationInterval(polynomial, i + offset, (thresholdApproximation - SHIFT) * (1 / SCALE) + twoB, sieveSize) - offset);
                while (i < j) {
                    if (i < j - 1 && j + 3 < segmentSize) {
                        var tmp = SIEVE_SEGMENT[j - 1];
                        SIEVE_SEGMENT[j - 1] = MAX;
                        i = findSmoothEntry(thresholdApproximation, i);
                        while (thresholdApproximation >= SIEVE_SEGMENT[i]) {
                            i += 1;
                        }
                        SIEVE_SEGMENT[j - 1] = tmp;
                    }
                    if (thresholdApproximation < SIEVE_SEGMENT[i]) {
                        smoothEntries.push(i + offset);
                        smoothEntries2.push((SIEVE_SEGMENT[i] - SHIFT) * (1 / SCALE));
                        smoothEntries3.push([]);
                    }
                    i += 1;
                }
            }
        };

        function checkFactorization(x) {
            var p = 0;
            var step = 0;
            for (var n = 0; n < wheelsCount; n += 1) {
                for (var v = 0; v <= 1; v += 1) {
                    var wheel = wheelDataOffset + n * 3;
                    step += wheelData[wheel + 2] & 0xFF;
                    if ((x - (v === 0 ? wheelData[wheel] | 0 : wheelData[wheel + 1] | 0) - (n < smallWheels ? 0 : segmentSize)) % step === 0) {
                        if (polynomial.AFactors.indexOf(step) === -1) {
                            console.log(step);
                            p += wheelData[wheel + 2] >> 16;
                        }
                    }
                }
            }
            return p;
        }

        function applyOffset(offset) {
            var step = 0;
            for (var j = 0; j < wheelsCount; j += 1) {
                var wheel = wheelDataOffset + j * 3;
                step += wheelData[wheel + 2] >> 16;
                var r1 = (0 + (wheelRoots[j] | 0) - baseOffsets[j] - offset) % step;
                r1 += r1 < 0 ? step : 0;
                var r2 = (0 - (wheelRoots[j] | 0) - baseOffsets[j] - offset) % step;
                r2 += r2 < 0 ? step : 0;
                wheelData[wheel] = Math.min(r1, r2);
                wheelData[wheel + 1] = Math.max(r1, r2);
            }
        }
        var set = new Uint8Array((sieveSize >> 3 + 3) + 1);
        //globalThis.countersFound = [0, 0];
        var findPreciseSmoothEntries = function(offset) {
            if (typeof offset !== "number") {
                throw new TypeError();
            }
            var smoothEntriesX = [];
            for (var i = 0; i < smoothEntries.length; i += 1) {
                smoothEntriesX.push(-0 + (smoothEntries[i] - offset));
            }
            var smoothEntries2A = [];
            for (var i = 0; i < smoothEntriesX.length; i += 1) {
                smoothEntries2A.push(-0);
            }
            for (var i = 0; i < set.length; i += 1) {
                set[i] = 0;
            }
            for (var i = 0; i < smoothEntriesX.length; i += 1) {
                var hash = smoothEntriesX[i] >> 3;
                set[hash >> 3] |= 1 << (hash & 7);
            }

            //var T = Math.max(Math.ceil(sieveSize / smoothEntries.length * 1.5), wheelData[smallWheels * 4]);
            //A: step <= T
            // 512*3 - 3061
            // 768 - 3290
            // 1024 - 3295
            var A = Math.max(smallWheels, Math.min(1024, Math.ceil(wheelsCount / 1)));
            var step = 0;
            for (var j = 0; j < A; j += 1) {
                var wheel = wheelDataOffset + ((j << 1) + j | 0) | 0;
                var proot1 = wheelData[wheel] | 0;
                var proot2 = wheelData[wheel + 1] | 0;
                step = step + (wheelData[wheel + 2] >> 16) | 0;
                if (proot1 === 0 && proot2 === 0) {
                    if (j >= smallWheels) {
                        continue;
                    }
                }
                var s = j < smallWheels ? 0 : sieveSize;
                var step1 = -0 + step;
                var stepInv = (1 + Math.pow(2, -52)) / step1;
                var a = -0 + (proot1 + s) % step;
                var b = -0 + (proot2 + s) % step;
                for (var i = smoothEntriesX.length - 1; i >= 0; i -= 1) {
                    //var x = (smoothEntriesX[i] % step) | 0;
                    var e = smoothEntriesX[i];
                    var x = e - Math.floor(e * stepInv) * step1;
                    if (x === a) {
                        smoothEntries2A[i] += +wheelLogs[j];
                        smoothEntries3[i].push(step);
                    }
                    if (x === b) {
                        smoothEntries2A[i] += +wheelLogs[j];
                        smoothEntries3[i].push(step);
                    }
                }
            }
            var f = function(a, j, step) {
                var ah = a >> 3;
                if ((set[ah >> 3] & 1 << (ah & 7)) !== 0) {
                    var i = indexOf(smoothEntries, 0 + a + offset);
                    if (i !== -1) {
                        smoothEntries2A[i] += +wheelLogs[j];
                        smoothEntries3[i].push(step);
                    }
                }
            };
            console.assert(wheels0.length > 0 && sieveSize >= wheels0[wheels0.length - 1].step);
            for (var j = A; j < wheelsCount; j += 1) {
                var wheel = wheelDataOffset + ((j << 1) + j | 0) | 0;
                var proot1 = wheelData[wheel] | 0;
                var proot2 = wheelData[wheel + 1] | 0;
                step = step + (wheelData[wheel + 2] >> 16) | 0;
                // "rotate" the wheel instead:
                var a = proot1 + (sieveSize - step | 0) | 0;
                var b = proot2 + (sieveSize - step | 0) | 0;
                //if (b < a) throw new Error();
                var found = 0;
                do {
                    found = found | set[b >> 6] | set[a >> 6];
                    a = a - step | 0;
                    b = b - step | 0;
                } while (a >= 0);
                //if (b >= 0) {
                //  found = found | set[b >> 6];
                //}

                b = b + (b >> 31 & step) | 0;
                found = found | set[b >> 6];

                //if (b >= 0) throw new Error();
                //countersFound[found ? 1 : 0] += 1;
                if (found) {
                    if (proot1 !== 0 || proot2 !== 0) {
                        var a = proot1 + sieveSize - step;
                        var b = proot2 + sieveSize - step;
                        while (a >= 0) {
                            if (set[a >> 6]) {
                                f(a, j, step);
                            }
                            a = a - step | 0;
                        }
                        while (b >= 0) {
                            if (set[b >> 6]) {
                                f(b, j, step);
                            }
                            b = b - step | 0;
                        }
                    }
                }
            }
            for (var i = 0; i < smoothEntries2.length; i += 1) {
                var e = Math.abs(smoothEntries2[i] - smoothEntries2A[i]);
                if (e >= 9 && e < 100) {
                    console.error(e);
                }
                smoothEntries2[i] = smoothEntries2A[i];
            }
        };
        QuadraticSieveFactorization.lpCounter = 0;
        var i1 = -1;
        var k = 0;
        var iterator = {
            next: function congruencesUsingQuadraticSieve() {
                while ((useMultiplePolynomials ? 2 : 1 / 16) * k * sieveSize <= Math.pow(primes[primes.length - 1], 2)) {
                    if (i1 === sieveSize) {
                        k += 1;
                        i1 = -1;
                    }
                    var offset = useMultiplePolynomials ? -sieveSize / 2 : (k % 2 === 0 ? 1 : -1) * Math.floor((k + 1) / 2) * sieveSize;
                    if (i1 === -1) {
                        if (useMultiplePolynomials) {
                            polynomial = polynomialGenerator.next();
                            updateWheels(polynomial, offset);
                        } else {
                            applyOffset(offset);
                        }
                        smoothEntries.length = 0;
                        smoothEntries2.length = 0;
                        smoothEntries3.length = 0;
                        for (var segmentStart = 0; segmentStart < sieveSize; segmentStart += segmentSize) {
                            updateSieveSegment(segmentStart);
                            findSmoothEntries(offset + segmentStart, polynomial);
                        }
                        findPreciseSmoothEntries(offset);
                    }

                    //Note: separate loop over "smooth entries" is better for performance, seems
                    for (var i = i1 + 1; i < smoothEntries.length; i += 1) {
                        var x = smoothEntries[i];
                        var value = +smoothEntries2[i];
                        var threshold = +polynomial.log2AbsY(x);
                        if (threshold - value < 1) {
                            var X = polynomial.X(x);
                            var Y = polynomial.Y(x, JSBI.BigInt(1), smoothEntries3[i]);
                            if (Y != null) {
                                i1 = i;
                                return {
                                    value: new CongruenceOfsquareOfXminusYmoduloN(X, Y, N),
                                    done: false
                                };
                            } else {
                                console.count('?');
                                //console.log(threshold, value, checkFactorization(x - offset));
                            }
                        } else {
                            if (threshold - value < twoB) {
                                var p = exp2(threshold - value);
                                var c = lpStrategy(p, polynomial, x, smoothEntries3[i]);
                                if (c != null) {
                                    i1 = i;
                                    QuadraticSieveFactorization.lpCounter += 1;
                                    return {
                                        value: c,
                                        done: false
                                    };
                                }
                            }
                        }
                    }
                    i1 = sieveSize;
                }
                return {
                    value: undefined,
                    done: true
                };
            }
        };
        iterator[globalThis.Symbol.iterator] = function() {
            return this;
        };
        return iterator;
    }

    function gcd(a, b) {
        while (JSBI.notEqual(b, JSBI.BigInt(0))) {
            var r = JSBI.remainder(JSBI.BigInt(a), JSBI.BigInt(b));
            a = b;
            b = r;
        }
        return a;
    }

    function abs(x) {
        if (!(x instanceof JSBI)) {
            throw new TypeError();
        }
        return JSBI.lessThan(x, JSBI.BigInt(0)) ? JSBI.unaryMinus(x) : x;
    }

    function indexOf(sortedArray, x) {
        if (typeof x !== 'number' || (x | 0) !== x) {
            throw new TypeError();
        }
        var min = 0;
        var max = sortedArray.length - 1;
        while (min < max) {
            var mid = Math.ceil((min + max) / 2);
            if ((sortedArray[mid] | 0) > (x | 0)) {
                max = mid - 1;
            } else {
                min = mid;
            }
        }
        if ((sortedArray[min] | 0) === (x | 0)) {
            return min;
        }
        return -1;
    }

    function computeY(primeBase, solution, N) {
        var Y = new Array(primeBase.length + 1).fill(0);
        for (var i = 0; i < solution.length; i += 1) {
            var v = solution[i].v;
            for (var j = 0; j < v.length; j += 1) {
                Y[v[j]] += 1;
            }
        }
        var y = JSBI.BigInt(1);
        for (var i = 0; i < Y.length; i += 1) {
            if (Y[i] % 2 !== 0) {
                throw new RangeError();
            }
            if (i !== 0) {
                var p = primeBase[i - 1];
                var e = Y[i] / 2;
                if (e > 0) {
                    if (e <= 2) {
                        y = JSBI.remainder(JSBI.multiply(y, JSBI.BigInt(Math.pow(p, e))), N);
                    } else {
                        y = JSBI.remainder(JSBI.multiply(y, modPow(JSBI.BigInt(p), JSBI.BigInt(e), N)), N);
                    }
                }
            }
        }
        return y;
    }

    function QuadraticSieveFactorization(N) {
        // N - is not a prime
        if (!(N instanceof JSBI)) {
            throw new TypeError();
        }
        for (var k = JSBI.BigInt(1);; k = JSBI.add(k, JSBI.BigInt(1))) {
            var kN = JSBI.multiply(k, N);
            // https://trizenx.blogspot.com/2018/10/continued-fraction-factorization-method.html#:~:text=optimal%20value :

            // to limit memory usage during "solve" to 2GB:
            var limit = Math.min(Math.floor(navigator.hardwareConcurrency === 12 ? Math.pow(2, 23.5) : Math.pow(2, 23.75)), (1 << 25) - 1);
            var B = Math.max(Math.min(Math.floor(Math.sqrt(L(kN) / (JSBI.toNumber(N) > Math.pow(2, 160) ? 8 : 6))), limit), 1024);
            var primeBase = primes(B).filter(function(p) {
                return isQuadraticResidueModuloPrime(kN, p);
            });
            for (var i = 0; i < primeBase.length; i += 1) {
                if (JSBI.toNumber(JSBI.remainder(N, JSBI.BigInt(primeBase[i]))) === 0) {
                    return JSBI.BigInt(primeBase[i]);
                }
            }
            var congruences = congruencesUsingQuadraticSieve(primeBase, kN); // congruences X_k^2 = Y_k mod N, where Y_k is smooth over the prime base
            var solutions = solve.sparseSolve(1 + primeBase.length); // find products of Y_k = Y, so that Y is a perfect square
            solutions.next();
            var c = null;
            var start = Date.now();
            var congruencesFound = 0;
            var last = start;
            while ((c = congruences.next().value) != undefined) {
                if (c.Y.length === 1 && c.Y[0] === 0) {
                    var g = JSBI.BigInt(gcd(abs(c.X), N));
                    if (JSBI.notEqual(g, JSBI.BigInt(1)) && JSBI.notEqual(g, N)) {
                        return g;
                    }
                } else {
                    var t = function() {
                        throw new TypeError(N);
                    };
                    var v = c.Y.map(function(p) {
                        return p === -1 ? 0 : 1 + indexOf(primeBase, p) || t();
                    });
                    var solution = solutions.next([v, {
                        c: c,
                        v: v
                    }]).value;
                    if (true) {
                        congruencesFound += 1;
                        var now = +Date.now();
                        if (now - last > 5000 || solution != null) {
                            console.debug('congruences found: ', congruencesFound, '/', primeBase.length, 'expected time: ', Math.round((now - start) / congruencesFound * primeBase.length), 'large prime congruences: ', QuadraticSieveFactorization.lpCounter, 'polynomials used: ', QuadraticSieveFactorization.polynomialsCounter);
                            last = now;
                        }
                    }
                    if (solution != null) {
                        var x = JSBI.BigInt(1);
                        for (var i = 0; i < solution.length; i += 1) {
                            x = JSBI.remainder(JSBI.multiply(x, solution[i].c.X), N);
                        }
                        // we cannot just compute product as it is larger 2**(Math.pow(2, 20)) (max BigInt in Firefox)
                        var y = computeY(primeBase, solution, N); // Y mod N === X^2 mod N
                        var g = JSBI.BigInt(gcd(abs(JSBI.add(x, y)), N));
                        if (JSBI.notEqual(g, JSBI.BigInt(1)) && JSBI.notEqual(g, N)) {
                            return g;
                        }
                    }
                }
            }
        }
    }
    QuadraticSieveFactorization.testables = {
        congruencesUsingQuadraticSieve: congruencesUsingQuadraticSieve,
        squareRootModuloOddPrime: squareRootModuloOddPrime,
        isQuadraticResidueModuloPrime: isQuadraticResidueModuloPrime,
        solve: solve,
        QuadraticPolynomial: QuadraticPolynomial,
        thresholdApproximationInterval: thresholdApproximationInterval
    };
    self.QuadraticSieveFactorization = QuadraticSieveFactorization;

    // see also https://github.com/danaj/Math-Prime-Util-GMP
})();
var maybeJSBI = {
    toNumber: function toNumber(a) {
        return typeof a === "object" ? JSBI.toNumber(a) : Number(a);
    },
    add: function add(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.add(a, b) : a + b;
    },
    subtract: function subtract(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.subtract(a, b) : a - b;
    },
    multiply: function multiply(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.multiply(a, b) : a * b;
    },
    divide: function divide(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.divide(a, b) : a / b;
    },
    remainder: function remainder(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.remainder(a, b) : a % b;
    },
    exponentiate: function exponentiate(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.exponentiate(a, b) : typeof a === "bigint" && typeof b === "bigint" ? new Function("a", "b", "return a**b")(a, b) : Math.pow(a, b);
    },
    leftShift: function leftShift(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.leftShift(a, b) : a << b;
    },
    signedRightShift: function signedRightShift(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.signedRightShift(a, b) : a >> b;
    },
    bitwiseAnd: function bitwiseAnd(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.bitwiseAnd(a, b) : a & b;
    },
    bitwiseOr: function bitwiseOr(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.bitwiseOr(a, b) : a | b;
    },
    bitwiseXor: function bitwiseXor(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.bitwiseXor(a, b) : a ^ b;
    },
    lessThan: function lessThan(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.lessThan(a, b) : a < b;
    },
    greaterThan: function greaterThan(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.greaterThan(a, b) : a > b;
    },
    lessThanOrEqual: function lessThanOrEqual(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.lessThanOrEqual(a, b) : a <= b;
    },
    greaterThanOrEqual: function greaterThanOrEqual(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.greaterThanOrEqual(a, b) : a >= b;
    },
    equal: function equal(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.equal(a, b) : a === b;
    },
    notEqual: function notEqual(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.notEqual(a, b) : a !== b;
    },
    unaryMinus: function unaryMinus(a) {
        return typeof a === "object" ? JSBI.unaryMinus(a) : -a;
    },
    bitwiseNot: function bitwiseNot(a) {
        return typeof a === "object" ? JSBI.bitwiseNot(a) : ~a;
    }
};

(function() {
    "use strict";

    //

    // https://github.com/tc39/proposal-bigint/issues/205
    // https://github.com/tc39/ecma262/issues/1729
    // bitLength(a) = floor(log2(a)) + 1 if a > 0
    function bitLength(a) {
        var s = a.toString(16);
        var c = 0 + s.charCodeAt(0) - '0'.charCodeAt(0);
        if (c <= 0) {
            throw new RangeError();
        }
        return (s.length - 1) * 4 + (32 - Math.clz32(Math.min(c, 8)));
    }

    //self.bitLength = bitLength;

    //function min(a, b) {
    //  return a < b ? a : b;
    //}

    var SPLIT = Math.pow(2, Math.ceil(Math.log2((Number.MAX_SAFE_INTEGER + 1) * 2) / 2)) + 1;

    function fma(a, b, p) {
        var at = SPLIT * a;
        var ahi = at - (at - a);
        var alo = a - ahi;
        var bt = SPLIT * b;
        var bhi = bt - (bt - b);
        var blo = b - bhi;
        var e = ahi * bhi + p + ahi * blo + alo * bhi + alo * blo;
        return e;
    }

    function modMultiplySmall(a, b, m) {
        if (typeof a !== 'number' || typeof b !== 'number' || typeof m !== 'number') {
            throw new TypeError();
        }
        if (!(a >= 0 && b >= 0 && a < m && b < m && m <= Number.MAX_SAFE_INTEGER)) {
            throw new RangeError();
        }
        var p = a * b;
        if (p <= Number.MAX_SAFE_INTEGER) {
            return p - Math.floor(p / m) * m;
        }
        var r1 = fma(a, b, -p);
        var q = p / m - (1 + Number.MAX_SAFE_INTEGER) + (1 + Number.MAX_SAFE_INTEGER); // note: this is a confusing line because of the double rounding
        var r2 = 0 - fma(q, m, -p);
        if (r1 > 0) {
            r1 -= m;
        }
        if (r2 < 0) {
            r2 += m;
        }
        var r = r1 + r2;
        if (r < 0) {
            r += m;
        }
        return r;
    }

    function modPowSmall(base, exponent, modulus) {
        // exponent can be huge, use non-recursive variant
        var accumulator = 1;
        while (exponent !== 0) {
            var q = Math.floor(exponent / 2);
            if (exponent !== q + q) {
                accumulator = modMultiplySmall(accumulator, base, modulus);
            }
            exponent = q;
            base = modMultiplySmall(base, base, modulus);
        }
        return accumulator;
    }

    function range(start, end) {
        var a = [];
        for (var i = start; i <= end; i += 1) {
            a.push(i);
        }
        return a;
    }

    // isPrime implementation is stolen from:
    // https://github.com/peterolson/BigInteger.js
    // https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test#Deterministic_variants
    function isPrimeSmall(n) {
        if (typeof n !== 'number') {
            throw new TypeError();
        }
        if (n > Number.MAX_SAFE_INTEGER) {
            throw new RangeError();
        }
        if (n < 2) {
            throw new RangeError();
        }
        if (+primeFactorUsingWheel(n, 2 * 1024) < n) {
            return false;
        }
        if (n < Math.pow(1024, 2)) {
            return true;
        }
        var r = 0;
        var d = n - 1;
        while (d % 2 === 0) {
            d /= 2;
            r += 1;
        }
        // https://en.wikipedia.org/wiki/Miller–Rabin_primality_test#Testing_against_small_sets_of_bases
        var values = [10, 20, 24, 31, 40, 41, 48, 48, 61, 61, 61, 78, 81];
        var primes = [2, 3, 5, 7, 11, 13, 17, 17, 19, 19, 19, 23, 29];
        var i = 0;
        var x = Math.ceil(Math.log2(n));
        while (x > values[i] && i < values.length) {
            i += 1;
        }
        var bases = null;
        if (i < values.length) {
            bases = primes.slice(0, i + 1);
        } else {
            // https://primes.utm.edu/prove/prove2_3.html
            bases = range(2, Math.floor(1 / Math.log(2) * Math.log(n) * Math.log(Math.log(n))));
        }
        console.assert(n > bases[bases.length - 1]);
        for (var iteratora = bases[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
            var adn = modPowSmall(a, d, n);
            if (adn !== 1) {
                for (var i = 0, x = adn; x !== n - 1; i += 1, x = modMultiplySmall(x, x, n)) {
                    if (i === r - 1) {
                        return false;
                    }
                }
            }
        }
        return true;
    }

    // Pollard's rho implementation is stolen from:
    // https://github.com/jiggzson/nerdamer/blob/master/nerdamer.core.js
    // https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm#C_code_sample
    // TODO: library (?)
    function factorByPollardRho(n, x0, c, maxIterations) {
        x0 = x0 == undefined ? JSBI.BigInt(2) : x0;
        c = c == undefined ? JSBI.BigInt(1) : c;
        maxIterations = maxIterations == undefined ? 1 / 0 : maxIterations;
        var zero = maybeJSBI.subtract(n, n);
        var one = maybeJSBI.divide(n, n);

        function abs(a) {
            return maybeJSBI.lessThan(a, maybeJSBI.subtract(a, a)) ? maybeJSBI.unaryMinus(a) : a;
        }

        function modMultiply(a, b, mod) {
            if (typeof mod === "number") {
                return modMultiplySmall(a, b, mod);
            }
            return maybeJSBI.remainder(maybeJSBI.multiply(a, b), mod);
        }

        function gcd(a, b) {
            while (maybeJSBI.notEqual(b, zero)) {
                var r = maybeJSBI.remainder(a, b);
                a = b;
                b = r;
            }
            return a;
        }

        function f(x, c, mod) {
            var y = maybeJSBI.subtract(modMultiply(x, x, mod), c);
            return maybeJSBI.lessThan(y, zero) ? maybeJSBI.add(y, mod) : y;
        }
        if (JSBI.equal(maybeJSBI.remainder(n, x0), JSBI.BigInt(0))) {
            //?
            return x0;
        }
        var xFixed = x0;
        var cycleSize = 2;
        var x = x0;
        while (cycleSize <= Math.pow(2, maxIterations)) {
            var product = one;
            var productStart = x;
            var found = false;
            for (var count = 1; found || count <= cycleSize; count += 1) {
                x = f(x, c, n);
                if (count === cycleSize / 2) {
                    productStart = x;
                }
                if (count > cycleSize / 2) {
                    // see https://maths-people.anu.edu.au/~brent/pd/rpb051i.pdf
                    //factor = gcd(abs(x - xFixed), n);
                    product = found ? abs(maybeJSBI.subtract(x, xFixed)) : modMultiply(product, abs(maybeJSBI.subtract(x, xFixed)), n);
                    if (found || count === cycleSize || count % 128 === 0) {
                        // https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm#Variants
                        var factor = gcd(product, n);
                        if (maybeJSBI.notEqual(factor, one)) {
                            if (!found) {
                                //cycleSize *= 2;
                                x = productStart;
                                found = true;
                            } else {
                                return factor;
                            }
                        }
                        product = one;
                        productStart = x;
                    }
                }
            }
            cycleSize *= 2;
            xFixed = x;
        }
        return one;
    }

    function factorByPollardRhoWrapper(n, maxIterations) {
        maxIterations = maxIterations == undefined ? 1 / 0 : maxIterations;
        var small = typeof n === "number";
        if (small && isPrimeSmall(n) || !small && isPrime(n)) {
            return n;
        }
        var x0 = 2 - 1;
        var g = n;
        do {
            x0 += 1;
            g = small ? factorByPollardRho(n, x0, 1, maxIterations) : factorByPollardRho(n, JSBI.BigInt(x0), JSBI.BigInt(1), maxIterations);
        } while (maybeJSBI.equal(g, n));
        return g;
    }
    var WHEEL3 = [1, 2, 2, 4, 2, 4, 2, 4, 6, 2, 6];

    function remainder(n, i) {
        // `n % i` is slower in Chrome and Firefox ...
        return n - Math.floor(n / i) * i;
    }

    function primeFactorUsingWheel(n, max) {
        max = max == undefined ? undefined : max;
        var steps = WHEEL3;
        var cycle = 3;
        if (max == undefined) {
            max = Math.floor(Math.sqrt(Number(n) + 0.5));
        }
        var i = 2;
        var s = 0;
        while (i <= max) {
            if (remainder(n, i) === 0) {
                return i;
            }
            i += steps[s];
            s += 1;
            if (s === steps.length) {
                s = cycle;
            }
        }
        return n;
    }

    function someFactor(n) {
        var x = maybeJSBI.toNumber(n);
        if (x < 1) {
            throw new TypeError("primeFactor cannot be called for numbers less than 2");
        }
        if (x === 1) {
            return n;
        }
        //var s = gcd(BigInt(n), BigInt(304250263527210)); // a primorial - https://en.wikipedia.org/wiki/Primorial
        //if (s > 1n) {
        //TODO: use-cases - ?
        //  return s === n ? BigInt(primeFactorUsingWheel(Number(s))) : s;
        //}
        if (x <= Number.MAX_SAFE_INTEGER) {
            var pf = primeFactorUsingWheel(x, 1024);
            if (pf < x) {
                return JSBI.BigInt(pf);
            }
            if (x <= 1024 * 1024) {
                return JSBI.BigInt(pf);
            }
            if (x % 2 === 0) {
                return JSBI.BigInt(2);
            }
        }

        //! optimize n = f**2
        var squareRoot = JSBI.BigInt(nthRoot(JSBI.BigInt(n), 2));
        if (JSBI.equal(JSBI.exponentiate(squareRoot, JSBI.BigInt(2)), n)) {
            return squareRoot;
        }
        if (x > 5) {
            // https://en.wikipedia.org/wiki/Fermat%27s_factorization_method
            var a = JSBI.add(squareRoot, JSBI.BigInt(1));
            var b2 = JSBI.subtract(JSBI.multiply(a, a), JSBI.BigInt(n));
            var b = JSBI.BigInt(nthRoot(JSBI.BigInt(b2), 2));
            if (JSBI.equal(JSBI.multiply(b, b), b2)) {
                //console.debug("Fermat's method", n, a - b);
                return JSBI.subtract(a, b);
            }
        }

        //! optimize n = f**3
        var size = bitLength(JSBI.BigInt(n));
        for (var k = 3; k <= size / 10; k += 2) {
            var root = JSBI.BigInt(nthRoot(JSBI.BigInt(n), k));
            if (JSBI.equal(JSBI.exponentiate(root, JSBI.BigInt(k)), JSBI.BigInt(n))) {
                return root;
            }
        }
        if (x <= Number.MAX_SAFE_INTEGER) {
            //return BigInt(primeFactorUsingWheel(x));
            return factorByPollardRhoWrapper(x);
        }
        if (true) {
            var L = function(n) {
                var e = Math.max(0, n.toString(16).length * 4 - 48);
                var lnn = (Math.log2(JSBI.toNumber(JSBI.signedRightShift(JSBI.BigInt(n), JSBI.BigInt(e)))) + e) * Math.LN2;
                return Math.exp(Math.sqrt(lnn * Math.log(lnn)));
            };
            //TODO: estimate new limit
            var limit = Math.floor(Math.log(L(n)));
            if (maybeJSBI.toNumber(n) < Math.pow(2, 64)) {
                limit = 1 / 0;
            }
            if (globalThis.ArrayBuffer == null) {
                // old browsers without typed array support
                limit = 1 / 0;
            }
            if (maybeJSBI.toNumber(n) >= Math.pow(2, 128)) {
                // try 2n**128n + 1n (large factors)
                // try 516580063688473107036756944316883068479010630159425669n (small factor)
                limit -= 3;
            } else if (maybeJSBI.toNumber(n) >= Math.pow(2, 96)) {
                limit -= 2;
            } else {
                limit -= 1;
            }
            var factor = factorByPollardRhoWrapper(n, limit);
            if (JSBI.notEqual(factor, JSBI.BigInt(1))) {
                return factor;
            }
            if (true) {
                if (globalThis.onerror != null) {
                    var size = bitLength(n);
                    var error = new TypeError("big size of " + "someFactor " + "bitLength(" + n + ")" + " === " + size);
                    globalThis.onerror(error.message, "", 0, 0, error);
                }
            }
            return QuadraticSieveFactorization(n);
        }
        return factorByPollardRhoWrapper(n);
    }

    // https://en.wikipedia.org/wiki/Find_first_set#CTZ
    function countTrailingZeros(x, base) {
        //console.log(x, base);
        x = JSBI.BigInt(x);
        base = JSBI.BigInt(base);
        if (JSBI.lessThan(x, JSBI.BigInt(0)) || JSBI.lessThan(base, JSBI.BigInt(0))) {
            throw new RangeError();
        }
        if (maybeJSBI.equal(x, base)) {
            return 1;
        }
        //if (base == 2 && typeof x === "bigint") { return bitLength(x & -x) - 1; } //TODO: ?
        if (JSBI.equal(x, JSBI.BigInt(0))) {
            throw new TypeError();
        }
        if (JSBI.equal(base, JSBI.BigInt(2))) {
            var k = 32;
            while (JSBI.equal(JSBI.asUintN(k, x), JSBI.BigInt(0))) {
                k *= 2;
            }
            var n = 0;
            for (var i = Math.floor(k / 2); i >= 32; i = Math.floor(i / 2)) {
                if (JSBI.equal(JSBI.asUintN(i, x), JSBI.BigInt(0))) {
                    n = maybeJSBI.add(n, i);
                    x = JSBI.signedRightShift(x, JSBI.BigInt(i));
                }
            }
            var ctz4 = function(x) {
                var n = +x;
                return 32 - (Math.clz32(n & -n) + 1);
            };
            n = maybeJSBI.add(n, ctz4(JSBI.toNumber(JSBI.asUintN(32, x))));
            return n;
        }
        var k = 1;
        while (JSBI.equal(JSBI.remainder(x, JSBI.exponentiate(base, JSBI.BigInt(k))), JSBI.BigInt(0))) {
            k *= 2;
        }
        var n = 0;
        for (var i = k / 2; i >= 1; i /= 2) {
            var v = JSBI.exponentiate(base, JSBI.BigInt(i));
            var q = maybeJSBI.divide(x, v);
            var r = maybeJSBI.subtract(x, maybeJSBI.multiply(q, v));
            if (JSBI.equal(r, JSBI.BigInt(0))) {
                n = maybeJSBI.add(n, i);
                x = q;
            }
        }
        return n;
    }
    primeFactor._rationalNumberToDecimalString = function(n, d, rounding) {
        // 1 / denominator
        var getPeriodOfRepeatingDecimalSegment = function(denominator, limit) {
            // https://softwareengineering.stackexchange.com/a/192081
            // https://en.wikipedia.org/wiki/Repeating_decimal#Other_properties_of_repetend_lengths
            // "If k = Math.pow(2, a)*5**b*n where n > 1 and n is not divisible by 2 or 5, then the length of the transient of 1/k is max(a, b), and the period equals r, where r is the smallest integer such that 10r ≡ 1 (mod n)."
            denominator = JSBI.BigInt(denominator);
            if (JSBI.equal(JSBI.remainder(denominator, JSBI.BigInt(2)), JSBI.BigInt(0)) || JSBI.equal(JSBI.remainder(denominator, JSBI.BigInt(5)), JSBI.BigInt(0))) {
                throw new RangeError("should be called with denominator not divible by 2 or 5");
            }
            var n = denominator;
            var period = 0;
            if (JSBI.notEqual(n, JSBI.BigInt(1))) {
                var z = JSBI.BigInt(1);
                do {
                    period += 1;
                    z = JSBI.remainder(JSBI.multiply(JSBI.BigInt(10), z), n);
                } while (period <= limit && JSBI.notEqual(z, JSBI.BigInt(1)));
            }
            return period;
        };
        var bigDecimalToPlainString = function(significand, exponent, minFraction, minSignificant) {
            var e = maybeJSBI.add(exponent, significand.length) - 1;
            significand = significand.replace(/0+$/g, '');
            var zeros = Math.max(0, Math.max(e + 1, minSignificant) - significand.length);
            if (e <= -1) {
                significand = maybeJSBI.add("0".repeat(0 - e), significand);
                e = 0;
            }
            significand = maybeJSBI.add(significand, "0".repeat(zeros));
            significand = maybeJSBI.add(significand, "0".repeat(Math.max(minFraction - (significand.length - (e + 1)), 0)));
            return significand.slice(0, e + 1) + (significand.length > e + 1 ? "." + significand.slice(e + 1) : "");
        };
        // Something like Number#toPrecision: when value is between 10**-6 and Math.pow(10, p)? - to fixed, otherwise - to exponential:
        var toPrecision = function(significand, exponent, minSignificant) {
            var e = maybeJSBI.add(exponent, significand.length) - 1;
            if (e < -6 || e >= minSignificant) {
                return bigDecimalToPlainString(significand, -(significand.length - 1), 0, minSignificant) + 'e' + (e < 0 ? '-' : '') + Math.abs(e).toString();
            }
            return bigDecimalToPlainString(significand, exponent, 0, minSignificant);
        };
        var digitsToDecimalNumber = function(significand, exponent, rounding) {
            // significand * 10**exponent
            if (rounding.significantDigits != undefined) {
                return toPrecision(significand, exponent, rounding.significantDigits);
            }
            return bigDecimalToPlainString(significand, exponent, rounding.fractionDigits, 0);
        };
        n = JSBI.BigInt(n);
        d = JSBI.BigInt(d);
        var sign = +1;
        if (JSBI.lessThan(d, JSBI.BigInt(0))) {
            d = maybeJSBI.unaryMinus(d);
            sign = -sign;
        }
        if (JSBI.lessThan(n, JSBI.BigInt(0))) {
            n = maybeJSBI.unaryMinus(n);
            sign = -sign;
        }
        var floorOfLog10 = function(n, d) {
            //TODO: optimize - ?
            var guess = Math.floor((bitLength(n) - 1 - bitLength(d)) / Math.log2(10));
            while (maybeJSBI.greaterThanOrEqual(guess < 0 ? JSBI.multiply(JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(-guess)), n) : n, guess > 0 ? JSBI.multiply(JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(guess)), d) : d)) {
                guess += 1;
            }
            return guess - 1;
        };
        var a = primeFactor._countTrailingZeros(d, 2);
        var b = primeFactor._countTrailingZeros(d, 5);
        if (a > 0 && JSBI.equal(JSBI.remainder(n, JSBI.BigInt(2)), JSBI.BigInt(0))) {
            throw new RangeError("not implemented");
        }
        if (b > 0 && JSBI.equal(JSBI.remainder(n, JSBI.BigInt(5)), JSBI.BigInt(0))) {
            throw new RangeError("not implemented");
        }
        var d1 = JSBI.divide(d, JSBI.multiply(JSBI.exponentiate(JSBI.BigInt(2), JSBI.BigInt(a)), JSBI.exponentiate(JSBI.BigInt(5), JSBI.BigInt(b))));
        var lengthOfTransient = Math.max(a, b);
        if ((rounding.fractionDigits != undefined && lengthOfTransient <= rounding.fractionDigits || rounding.significantDigits != undefined && lengthOfTransient + (floorOfLog10(n, d) + 1) - primeFactor._countTrailingZeros(n, 10) <= rounding.significantDigits) && JSBI.equal(JSBI.remainder(n, d1), JSBI.BigInt(0))) {
            // exact result
            var scaling = lengthOfTransient;
            var result = JSBI.divide(JSBI.multiply(JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(scaling)), n), d).toString(); //TODO: optimize - ?
            var minRounding = rounding.fractionDigits != undefined ? {
                fractionDigits: lengthOfTransient
            } : {
                significantDigits: lengthOfTransient + (floorOfLog10(n, d) + 1) <= rounding.significantDigits ? lengthOfTransient + (floorOfLog10(n, d) + 1) : lengthOfTransient + (floorOfLog10(n, d) + 1) - primeFactor._countTrailingZeros(n, 10)
            };
            var f = (sign < 0 ? '-' : '') + digitsToDecimalNumber(result, -scaling, minRounding);
            return f;
        } else {
            var scaling = rounding.fractionDigits != undefined ? rounding.fractionDigits : rounding.significantDigits - (floorOfLog10(n, d) + 1);
            var sn = scaling > 0 ? JSBI.multiply(JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(scaling)), n) : n;
            var sd = scaling < 0 ? JSBI.multiply(JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(maybeJSBI.unaryMinus(scaling))), d) : d;
            var result = JSBI.divide(JSBI.add(sn, JSBI.divide(sd, JSBI.BigInt(2))), sd).toString();
            var f = (sign < 0 ? '-' : '') + digitsToDecimalNumber(result, maybeJSBI.unaryMinus(scaling), rounding);
            var period = getPeriodOfRepeatingDecimalSegment(d1, f.length);
            ///^0\.(\d+?)(\d*?)(?:\1\2)*\1$/.exec('0.123123')
            if (period !== 0 && maybeJSBI.lessThanOrEqual(period, f.length)) {
                // a repeating decimal, the result is not exact
                var j = f.indexOf('.'); //?
                var offset = j + 1 + lengthOfTransient - (f.indexOf('e') !== -1 ? -maybeJSBI.toNumber(f.slice(f.indexOf('e') + 1)) - 0 : 0) - primeFactor._countTrailingZeros(n, 10);
                if (offset < j + 1) {
                    //TODO: fix
                    offset = j + 1; //!?
                }

                var lastFractionDigit = f.indexOf('e') !== -1 ? f.indexOf('e') : f.length;
                if (j !== -1 && (offset + period < lastFractionDigit || offset + period === lastFractionDigit && maybeJSBI.lessThan(f.charCodeAt(offset), '5'.charCodeAt(0)))) {
                    f = f.slice(0, offset) + '(' + f.slice(offset, offset + period) + ')' + f.slice(offset + period);
                }
            }
            if (!/[^0\.]/.test(f) && sign >= 0 && JSBI.notEqual(n, JSBI.BigInt(0))) {
                f = '+' + f;
            }
            return f;
        }
    };

    function primeFactor(n) {
        n = JSBI.BigInt(n);
        var factor = JSBI.BigInt(someFactor(n));
        if (JSBI.equal(factor, n)) {
            return factor;
        }
        //var otherFactor = n / factor**BigInt(countTrailingZeros(n, factor));
        //if (otherFactor === 1n) {
        //  return primeFactor(factor);
        //}
        //TODO: divide by gcd (?)
        //if (otherFactor < factor) {
        //  var tmp = factor;
        //  factor = otherFactor;
        //  otherFactor = tmp;
        //}
        var a = primeFactor(factor);
        //var b = a > nthRoot(nthRoot(otherFactor, 2), 2) || a > 1e9 ? primeFactor(otherFactor) : primeFactorUsingWheelBig(otherFactor, a);
        //return min(a, b);
        return a;
    }

    // from https://github.com/juanelas/bigint-mod-arith/blob/master/lib/index.browser.mod.js :
    // x * a + y * b = gcd(a, b)
    function eGCD_N(a, b) {
        var zero = maybeJSBI.subtract(a, a);
        var one = maybeJSBI.divide(a, a);
        var $newoldR = maybeJSBI.lessThan(a, zero) ? maybeJSBI.subtract(zero, a) : a;
        var $newr = maybeJSBI.lessThan(b, zero) ? maybeJSBI.subtract(zero, b) : b;
        var oldR = $newoldR;
        var r = $newr;
        var $newoldX = one;
        var $newx = zero;
        var oldX = $newoldX;
        var x = $newx;
        var $newoldY = zero;
        var $newy = one;
        var oldY = $newoldY;
        var y = $newy;
        while (maybeJSBI.notEqual(r, zero)) {
            var q = maybeJSBI.divide(maybeJSBI.subtract(oldR, maybeJSBI.remainder(oldR, r)), r);
            var $newoldR = r;
            var $newr = maybeJSBI.subtract(oldR, maybeJSBI.multiply(q, r));
            oldR = $newoldR;
            r = $newr;
            var $newoldX = x;
            var $newx = maybeJSBI.subtract(oldX, maybeJSBI.multiply(q, x));
            oldX = $newoldX;
            x = $newx;
            var $newoldY = y;
            var $newy = maybeJSBI.subtract(oldY, maybeJSBI.multiply(q, y));
            oldY = $newoldY;
            y = $newy;
            if (maybeJSBI.greaterThan(r, maybeJSBI.subtract(oldR, r))) {
                // increase q by 1 and negate coefficients
                r = maybeJSBI.subtract(oldR, r);
                x = maybeJSBI.subtract(oldX, x);
                y = maybeJSBI.subtract(oldY, y);
            }
        }
        return {
            gcd: oldR,
            x: oldX,
            y: oldY
        };
    }

    function modInverseN(a, m) {
        var zero = maybeJSBI.subtract(m, m);
        console.assert(maybeJSBI.greaterThanOrEqual(a, zero));
        console.assert(maybeJSBI.greaterThan(m, zero));
        if (maybeJSBI.greaterThan(a, m)) {
            a = maybeJSBI.remainder(a, m);
        }
        var inv = eGCD_N(a, m).x;
        inv = maybeJSBI.lessThan(inv, zero) ? maybeJSBI.add(inv, m) : inv;
        console.assert(maybeJSBI.greaterThanOrEqual(inv, zero) && maybeJSBI.lessThan(inv, m));
        return inv;
    }

    function modInverse(a, m) {
        if (typeof m === "number") {
            if (typeof a === "number") {
                return modInverseN(a, m);
            }
            return modInverseN(JSBI.toNumber(JSBI.remainder(JSBI.BigInt(a), JSBI.BigInt(m))), m);
        }
        return modInverseN(JSBI.BigInt(a), JSBI.BigInt(m));
    }
    primeFactor._bitLength = bitLength;
    primeFactor._isPrime = function(n) {
        var number = maybeJSBI.toNumber(n);
        if (number <= Number.MAX_SAFE_INTEGER) {
            return isPrimeSmall(number);
        }
        return isPrime(n);
    };
    primeFactor._countTrailingZeros = countTrailingZeros;
    primeFactor._someFactor = someFactor;
    primeFactor._modInverse = modInverse;
    primeFactor._integerNthRoot = function(a, n) {
        return nthRoot(JSBI.BigInt(a), n);
    };
    primeFactor.testables = {
        factorByPollardRho: factorByPollardRho,
        factorByPollardRhoWrapper: factorByPollardRhoWrapper
    };
    self.primeFactor = primeFactor;
})();
var maybeJSBI = {
    toNumber: function toNumber(a) {
        return typeof a === "object" ? JSBI.toNumber(a) : Number(a);
    },
    add: function add(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.add(a, b) : a + b;
    },
    subtract: function subtract(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.subtract(a, b) : a - b;
    },
    multiply: function multiply(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.multiply(a, b) : a * b;
    },
    divide: function divide(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.divide(a, b) : a / b;
    },
    remainder: function remainder(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.remainder(a, b) : a % b;
    },
    exponentiate: function exponentiate(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.exponentiate(a, b) : typeof a === "bigint" && typeof b === "bigint" ? new Function("a", "b", "return a**b")(a, b) : Math.pow(a, b);
    },
    leftShift: function leftShift(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.leftShift(a, b) : a << b;
    },
    signedRightShift: function signedRightShift(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.signedRightShift(a, b) : a >> b;
    },
    bitwiseAnd: function bitwiseAnd(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.bitwiseAnd(a, b) : a & b;
    },
    bitwiseOr: function bitwiseOr(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.bitwiseOr(a, b) : a | b;
    },
    bitwiseXor: function bitwiseXor(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.bitwiseXor(a, b) : a ^ b;
    },
    lessThan: function lessThan(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.lessThan(a, b) : a < b;
    },
    greaterThan: function greaterThan(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.greaterThan(a, b) : a > b;
    },
    lessThanOrEqual: function lessThanOrEqual(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.lessThanOrEqual(a, b) : a <= b;
    },
    greaterThanOrEqual: function greaterThanOrEqual(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.greaterThanOrEqual(a, b) : a >= b;
    },
    equal: function equal(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.equal(a, b) : a === b;
    },
    notEqual: function notEqual(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.notEqual(a, b) : a !== b;
    },
    unaryMinus: function unaryMinus(a) {
        return typeof a === "object" ? JSBI.unaryMinus(a) : -a;
    },
    bitwiseNot: function bitwiseNot(a) {
        return typeof a === "object" ? JSBI.bitwiseNot(a) : ~a;
    }
};

(function() {
    "use strict";

    /*jslint bigint: true, vars: true, indent: 2*/

    // https://github.com/tc39/proposal-decimal
    // https://en.wikipedia.org/wiki/Floating-point_arithmetic
    // https://en.wikipedia.org/wiki/Fixed-point_arithmetic

    // Usage:
    // BigDecimal.BigDecimal(bigint)
    // BigDecimal.BigDecimal(string)
    // BigDecimal.BigDecimal(number) (only integers)
    // BigDecimal.toBigInt(a) (not in the spec)
    // BigDecimal.toNumber(a) (not in the spec, only integers)
    // BigDecimal.unaryMinus(a)
    // BigDecimal.add(a, b[, rounding])
    // BigDecimal.subtract(a, b[, rounding])
    // BigDecimal.multiply(a, b[, rounding])
    // BigDecimal.divide(a, b, rounding)
    // BigDecimal.lessThan(a, b)
    // BigDecimal.greaterThan(a, b)
    // BigDecimal.equal(a, b)
    // BigDecimal.round(a, rounding)
    // a.toString()
    // a.toFixed(fractionDigits[, roundingMode = "half-up"])
    // a.toPrecision(precision[, roundingMode = "half-up"])
    // a.toExponential(fractionDigits[, roundingMode = "half-up"])
    // Math: (not in the spec)
    // BigDecimal.log(a, rounding)
    // BigDecimal.exp(a, rounding)
    // BigDecimal.sin(a, rounding)
    // BigDecimal.cos(a, rounding)
    // BigDecimal.atan(a, rounding)
    // BigDecimal.sqrt(a, rounding)
    // "simple" Math functions:
    // BigDecimal.abs(a)
    // BigDecimal.sign(a)
    // BigDecimal.max(a, b)
    // BigDecimal.min(a, b)
    // (!) Note: consider to use only "half-even" rounding mode and rounding to a maximum number of significant digits for floating-point arithmetic,
    // or only "floor" rounding to a maximum number of fraction digits for fixed-point arithmetic.
    // BigFloat may have better performance.
    var factory = function(BASE) {
        var BIGINT_BASE = JSBI.BigInt(BASE);

        function BigDecimal(significand, exponent) {
            this.significand = significand;
            this.exponent = exponent;
        }
        BigDecimal.BigFloat = BigDecimal.BigDecimal = function(value) {
            if (value instanceof BigDecimal) {
                return value;
            }
            if (typeof value === "string") {
                if (BASE !== 10) {
                    throw new Error();
                }
                var match = /^\s*([+\-])?(\d+)?\.?(\d+)?(?:e([+\-]?\d+))?\s*$/.exec(value);
                if (match == null) {
                    throw new RangeError(value);
                }
                var exponent = Number(match[4] || "0");
                return create(JSBI.BigInt((match[1] || "") + (match[2] || "") + (match[3] || "")), diff(Math.abs(exponent) < Number.MAX_SAFE_INTEGER ? exponent : JSBI.BigInt(match[4] || "0"), (match[3] || "").length));
            }
            if (typeof value === "number" && Math.floor(value) !== value) {
                if (BASE === 2) {
                    var e = getExponent(value);
                    var f = value / Math.pow(2, e);
                    var significand = f * (Number.MAX_SAFE_INTEGER + 1) / 2;
                    var exponent = e - (Math.floor(Math.log2(Number.MAX_SAFE_INTEGER + 1)) - 1);
                    return create(JSBI.BigInt(significand), exponent); //TODO: ?
                }
            }

            var a = create(JSBI.BigInt(value), 0);
            // `normalize` will change the exponent which is not good for fixed-point arithmetic (?)
            //var b = normalize(a, null);
            //while (a !== b) {
            //  a = b;
            //  b = normalize(a, null);
            //}
            return a;
        };
        BigDecimal.toNumber = function(a) {
            return maybeJSBI.toNumber(BigDecimal.toBigInt(a));
        };
        BigDecimal.toBigInt = function(a) {
            var exponent = maybeJSBI.toNumber(a.exponent);
            if (exponent === 0) {
                return a.significand;
            }
            if (exponent < 0) {
                var result = bigIntUnscale(a.significand, maybeJSBI.unaryMinus(exponent));
                if (maybeJSBI.notEqual(bigIntScale(result, maybeJSBI.unaryMinus(exponent)), a.significand)) {
                    throw new RangeError("The BigDecimal " + a.toString() + " cannot be converted to a BigInt because it is not an integer");
                }
                return result;
            }
            return bigIntScale(a.significand, exponent);
        };

        function create(significand, exponent) {
            return ( /*Object.freeze(*/ new BigDecimal(significand, exponent) /*)*/ );
        }

        function bigIntMax(a, b) {
            return maybeJSBI.lessThan(a, b) ? b : a;
        }

        function bigIntMin(a, b) {
            return maybeJSBI.lessThan(a, b) ? a : b;
        }

        function bigIntAbs(a) {
            return JSBI.lessThan(a, JSBI.BigInt(0)) ? maybeJSBI.unaryMinus(a) : a;
        }
        // https://github.com/tc39/proposal-bigint/issues/205
        // https://github.com/tc39/ecma262/issues/1729
        // floor(log2(a)) + 1 if a > 0
        function bitLength(a) {
            var s = a.toString(16);
            var c = maybeJSBI.subtract(s.charCodeAt(0), "0".charCodeAt(0));
            if (c <= 0) {
                throw new RangeError();
            }
            return (s.length - 1) * 4 + (32 - Math.clz32(Math.min(c, 8)));
        }

        function bigIntLog2(n) {
            var k = bitLength(n) - Math.floor(Math.log2(Number.MAX_SAFE_INTEGER + 1));
            var leadingDigits = JSBI.toNumber(JSBI.signedRightShift(n, JSBI.BigInt(k)));
            return Math.log2(leadingDigits) + k;
        }

        function digits(a) {
            // floor(log(abs(a)) / log(BASE)) + 1
            a = bigIntAbs(a);
            if (BASE === 2) {
                return bitLength(a);
            }
            var number = maybeJSBI.toNumber(a);
            if (number < (Number.MAX_SAFE_INTEGER + 1) / 16) {
                return Math.floor(Math.log2(number + 0.5) / Math.log2(BASE)) + 1;
            }
            var e = (number < 1 / 0 ? Math.log2(number) : bigIntLog2(a)) / Math.log2(BASE);
            if (Math.floor(e * (1 - 32 / (Number.MAX_SAFE_INTEGER + 1))) === Math.floor(e) && Math.floor(e * (1 + 32 / (Number.MAX_SAFE_INTEGER + 1))) === Math.floor(e)) {
                return Math.floor(e) + 1;
            }
            var i = Math.floor(e + 0.5);
            return maybeJSBI.greaterThanOrEqual(a, cachedPower(i)) ? i + 1 : i;
        }

        function sum(a, b) {
            if (typeof a === "number" && typeof b === "number") {
                var value = a + b;
                if (value >= maybeJSBI.unaryMinus(Number.MAX_SAFE_INTEGER) && value <= +Number.MAX_SAFE_INTEGER) {
                    return value;
                }
            }
            var v = JSBI.add(JSBI.BigInt(a), JSBI.BigInt(b));
            var nv = JSBI.toNumber(v);
            if (nv >= maybeJSBI.unaryMinus(Number.MAX_SAFE_INTEGER) && nv <= +Number.MAX_SAFE_INTEGER) {
                return nv;
            }
            return v;
        }

        function diff(a, b) {
            return sum(a, maybeJSBI.unaryMinus(b));
        }
        var E = Math.ceil(0.5 * Math.log2(Number.MAX_SAFE_INTEGER + 1) / Math.log2(BASE) - 1);
        var N = JSBI.BigInt(Math.pow(BASE, E));

        function normalize(a, rounding) {
            if (rounding == null || rounding.maximumSignificantDigits != null) {
                if (JSBI.equal(a.significand, JSBI.BigInt(0))) {
                    return a.exponent === 0 ? a : create(JSBI.BigInt(0), 0);
                }
                var dividend = a.significand;
                var e = E;
                var divisor = N;
                if (JSBI.equal(JSBI.remainder(dividend, divisor), JSBI.BigInt(0))) {
                    while (JSBI.equal(JSBI.remainder(dividend, JSBI.multiply(divisor, divisor)), JSBI.BigInt(0))) {
                        divisor = JSBI.multiply(divisor, divisor);
                        e *= 2;
                    }
                    var quotient = JSBI.divide(dividend, divisor);
                    return create(quotient, sum(a.exponent, e));
                }
            }
            return a;
        }

        function cachedFunction(f) {
            var cache = {};
            var cacheSize = 0;
            return function(k) {
                var lastValue = cache[k];
                if (lastValue == null) {
                    if (cacheSize > 100) {
                        cache = {};
                        cacheSize = 0;
                    }
                    lastValue = f(k);
                    cache[k] = lastValue;
                    cacheSize += 1;
                }
                return lastValue;
            };
        }
        var cachedBigInt = cachedFunction(function(k) {
            // k === maximumFractionDigits
            return JSBI.BigInt(k);
        });
        var cachedPower = cachedFunction(function(k) {
            return JSBI.exponentiate(BIGINT_BASE, JSBI.BigInt(k));
        });

        function round(a, rounding) {
            if (rounding != null) {
                var k = 0;
                var dividend = a.significand;
                var exponent = a.exponent;
                var maximumSignificantDigits = rounding.maximumSignificantDigits;
                if (maximumSignificantDigits != null) {
                    if (!(maximumSignificantDigits > 0)) {
                        throw new RangeError("maximumSignificantDigits should be positive");
                    }
                    if (JSBI.equal(dividend, JSBI.BigInt(0))) {
                        return create(JSBI.BigInt(0), 0);
                    }
                    k = digits(dividend) - maximumSignificantDigits;
                }
                var maximumFractionDigits = rounding.maximumFractionDigits;
                if (maximumFractionDigits != null) {
                    if (!(maximumFractionDigits >= 0)) {
                        throw new RangeError("maximumFractionDigits should be non-negative");
                    }
                    k = 0 - maybeJSBI.toNumber(sum(exponent, maximumFractionDigits));
                    //k = Math.min(k, digits(a.significand) + 1);
                    //if (k < 0 && k >= -1024 && BASE === 2) {
                    //  return create(a.significand << BigInt(-k), 0 - maximumFractionDigits);
                    //}
                }

                if (k > 0) {
                    var roundingMode = rounding.roundingMode;
                    var quotient = JSBI.BigInt(0);
                    if (roundingMode === "floor") {
                        if (BASE === 2) {
                            quotient = maybeJSBI.signedRightShift(dividend, cachedBigInt(k));
                        } else {
                            if (JSBI.greaterThanOrEqual(dividend, JSBI.BigInt(0))) {
                                quotient = maybeJSBI.divide(dividend, cachedPower(k));
                            } else {
                                quotient = JSBI.subtract(JSBI.divide(JSBI.add(dividend, JSBI.BigInt(1)), cachedPower(k)), JSBI.BigInt(1));
                            }
                        }
                    } else if (roundingMode === "ceil") {
                        if (BASE === 2) {
                            quotient = maybeJSBI.unaryMinus(maybeJSBI.signedRightShift(maybeJSBI.unaryMinus(dividend), cachedBigInt(k)));
                        } else {
                            if (JSBI.lessThan(dividend, JSBI.BigInt(0))) {
                                quotient = maybeJSBI.divide(dividend, cachedPower(k));
                            } else {
                                quotient = JSBI.add(JSBI.divide(JSBI.subtract(dividend, JSBI.BigInt(1)), cachedPower(k)), JSBI.BigInt(1));
                            }
                        }
                    } else {
                        var divisor = BASE === 2 ? JSBI.leftShift(JSBI.BigInt(1), cachedBigInt(k)) : cachedPower(k);
                        quotient = maybeJSBI.divide(dividend, divisor);
                        var twoRemainders = JSBI.multiply(maybeJSBI.subtract(dividend, maybeJSBI.multiply(divisor, quotient)), JSBI.BigInt(2));
                        if (JSBI.notEqual(twoRemainders, JSBI.BigInt(0))) {
                            if (roundingMode === "half-up") {
                                twoRemainders = JSBI.add(twoRemainders, JSBI.lessThan(twoRemainders, JSBI.BigInt(0)) ? JSBI.unaryMinus(JSBI.BigInt(1)) : JSBI.BigInt(1));
                            } else if (roundingMode === "half-down") {
                                twoRemainders = JSBI.add(twoRemainders, JSBI.BigInt(0));
                            } else if (roundingMode === "half-even") {
                                twoRemainders = JSBI.add(twoRemainders, JSBI.remainder(quotient, JSBI.BigInt(2)));
                            } else {
                                throw new RangeError("supported roundingMode (floor/ceil/half-even/half-up/half-down) is not given");
                            }
                            if (JSBI.greaterThan(twoRemainders, divisor)) {
                                quotient = JSBI.add(quotient, JSBI.BigInt(1));
                            }
                            if (JSBI.greaterThan(JSBI.unaryMinus(twoRemainders), divisor)) {
                                quotient = JSBI.subtract(quotient, JSBI.BigInt(1));
                            }
                        }
                    }
                    return create(quotient, sum(exponent, k));
                }
            }
            return a;
        }
        BigDecimal.unaryMinus = function(a) {
            return create(maybeJSBI.unaryMinus(a.significand), a.exponent);
        };
        BigDecimal.add = function(a, b, rounding) {
            rounding = rounding == undefined ? null : rounding;
            var bd = diff(a.exponent, b.exponent);
            var d = maybeJSBI.toNumber(bd);
            if (d !== 0) {
                // optimization
                if (JSBI.equal(a.significand, JSBI.BigInt(0))) {
                    return round(b, rounding);
                }
                if (JSBI.equal(b.significand, JSBI.BigInt(0))) {
                    return round(a, rounding);
                }
                if (d > 0) {
                    if (rounding != null && rounding.maximumSignificantDigits != null && d > digits(b.significand) + (rounding.maximumSignificantDigits + 1)) {
                        return round(create(JSBI.add(bigIntScale(a.significand, rounding.maximumSignificantDigits + 1), JSBI.lessThan(b.significand, JSBI.BigInt(0)) ? JSBI.unaryMinus(JSBI.BigInt(1)) : JSBI.BigInt(1)), diff(a.exponent, rounding.maximumSignificantDigits + 1)), rounding);
                    }
                    return round(create(maybeJSBI.add(bigIntScale(a.significand, bd), b.significand), b.exponent), rounding);
                }
                if (d < 0) {
                    if (rounding != null && rounding.maximumSignificantDigits != null && 0 - d > digits(a.significand) + (rounding.maximumSignificantDigits + 1)) {
                        return round(create(JSBI.add(JSBI.lessThan(a.significand, JSBI.BigInt(0)) ? JSBI.unaryMinus(JSBI.BigInt(1)) : JSBI.BigInt(1), bigIntScale(b.significand, rounding.maximumSignificantDigits + 1)), diff(b.exponent, rounding.maximumSignificantDigits + 1)), rounding);
                    }
                    return round(create(maybeJSBI.add(a.significand, bigIntScale(b.significand, maybeJSBI.unaryMinus(bd))), a.exponent), rounding);
                }
            }
            return round(create(maybeJSBI.add(a.significand, b.significand), a.exponent), rounding);
        };
        BigDecimal.subtract = function(a, b, rounding) {
            rounding = rounding == undefined ? null : rounding;
            return BigDecimal.add(a, BigDecimal.unaryMinus(b), rounding);
        };
        BigDecimal.multiply = function(a, b, rounding) {
            rounding = rounding == undefined ? null : rounding;
            return normalize(round(create(maybeJSBI.multiply(a.significand, b.significand), sum(a.exponent, b.exponent)), rounding), rounding);
        };

        function bigIntScale(a, scaling) {
            return BASE === 2 ? maybeJSBI.leftShift(a, cachedBigInt(scaling)) : maybeJSBI.multiply(cachedPower(scaling), a);
        }

        function bigIntUnscale(a, unscaling) {
            return BASE === 2 ? maybeJSBI.signedRightShift(a, cachedBigInt(unscaling)) : maybeJSBI.divide(a, cachedPower(unscaling));
        }
        BigDecimal.divide = function(a, b, rounding) {
            rounding = rounding == undefined ? null : rounding;
            if (JSBI.equal(a.significand, JSBI.BigInt(0))) {
                return a;
            }
            var exponent = diff(a.exponent, b.exponent);
            var scaling = 0;
            if (rounding != null && rounding.maximumSignificantDigits != null) {
                scaling = rounding.maximumSignificantDigits + (digits(b.significand) - digits(a.significand));
            } else if (rounding != null && rounding.maximumFractionDigits != null) {
                //scaling = BigInt(rounding.maximumFractionDigits) + bigIntMax(a.exponent, 0n) + bigIntMax(0n - b.exponent, 0n) - bigIntMin(a.exponent - b.exponent + BigInt(digits(a.significand) - digits(b.significand)), 0n);
                scaling = sum(rounding.maximumFractionDigits, exponent);
            } else {
                // Try to do exact division:
                scaling = Math.ceil(digits(b.significand) * Math.log2(BASE)) + 1;
            }
            var dividend = scaling > 0 ? bigIntScale(a.significand, scaling) : a.significand;
            var divisor = scaling < 0 ? bigIntScale(b.significand, maybeJSBI.unaryMinus(scaling)) : b.significand;
            if (JSBI.lessThan(divisor, JSBI.BigInt(0))) {
                dividend = maybeJSBI.unaryMinus(dividend);
                divisor = maybeJSBI.unaryMinus(divisor);
            }
            var quotient = JSBI.BigInt(0);
            if (rounding != null && rounding.roundingMode === "floor") {
                if (JSBI.greaterThanOrEqual(dividend, JSBI.BigInt(0))) {
                    quotient = maybeJSBI.divide(dividend, divisor);
                } else {
                    quotient = JSBI.subtract(JSBI.divide(JSBI.add(dividend, JSBI.BigInt(1)), divisor), JSBI.BigInt(1));
                }
            } else if (rounding != null && rounding.roundingMode === "ceil") {
                if (JSBI.lessThanOrEqual(dividend, JSBI.BigInt(0))) {
                    quotient = maybeJSBI.divide(dividend, divisor);
                } else {
                    quotient = JSBI.add(JSBI.divide(JSBI.subtract(dividend, JSBI.BigInt(1)), divisor), JSBI.BigInt(1));
                }
            } else {
                if (JSBI.lessThan(dividend, JSBI.BigInt(0))) {
                    quotient = JSBI.subtract(JSBI.divide(JSBI.add(dividend, JSBI.BigInt(1)), divisor), JSBI.BigInt(1));
                } else {
                    quotient = maybeJSBI.divide(dividend, divisor);
                }
                var remainder = maybeJSBI.subtract(dividend, maybeJSBI.multiply(divisor, quotient));
                console.assert(JSBI.greaterThanOrEqual(remainder, JSBI.BigInt(0)));
                if (JSBI.notEqual(remainder, JSBI.BigInt(0))) {
                    if (rounding == null) {
                        throw new RangeError("rounding is not given for inexact operation");
                    }
                    quotient = JSBI.multiply(quotient, JSBI.exponentiate(BIGINT_BASE, JSBI.BigInt(2)));
                    scaling = sum(scaling, 2);
                    if (JSBI.lessThan(JSBI.multiply(remainder, JSBI.BigInt(2)), divisor)) {
                        quotient = JSBI.add(quotient, JSBI.BigInt(1));
                    } else if (JSBI.equal(JSBI.multiply(remainder, JSBI.BigInt(2)), divisor)) {
                        quotient = JSBI.add(quotient, JSBI.divide(JSBI.exponentiate(BIGINT_BASE, JSBI.BigInt(2)), JSBI.BigInt(2)));
                    } else {
                        quotient = JSBI.add(quotient, JSBI.add(JSBI.divide(JSBI.exponentiate(BIGINT_BASE, JSBI.BigInt(2)), JSBI.BigInt(2)), JSBI.BigInt(1)));
                    }
                }
            }
            return round(create(quotient, diff(exponent, scaling)), rounding);
        };

        function compare(a, b) {
            if (maybeJSBI.equal(a.exponent, b.exponent)) {
                return maybeJSBI.lessThan(a.significand, b.significand) ? -1 : maybeJSBI.greaterThan(a.significand, b.significand) ? +1 : 0;
            }
            if (JSBI.lessThanOrEqual(a.significand, JSBI.BigInt(0)) && JSBI.greaterThanOrEqual(b.significand, JSBI.BigInt(0))) {
                return !(JSBI.equal(a.significand, JSBI.BigInt(0)) && JSBI.equal(b.significand, JSBI.BigInt(0))) ? -1 : 0;
            }
            if (JSBI.greaterThanOrEqual(a.significand, JSBI.BigInt(0)) && JSBI.lessThanOrEqual(b.significand, JSBI.BigInt(0))) {
                return JSBI.equal(a.significand, JSBI.BigInt(0)) && JSBI.equal(b.significand, JSBI.BigInt(0)) ? 0 : +1;
            }
            if (BASE !== 2) {
                var differenceOfLogarithms = maybeJSBI.toNumber(sum(diff(a.exponent, b.exponent), digits(a.significand) - digits(b.significand)));
                if (differenceOfLogarithms !== 0) {
                    return JSBI.lessThan(a.significand, JSBI.BigInt(0)) && JSBI.lessThan(b.significand, JSBI.BigInt(0)) ? differenceOfLogarithms > 0 ? -1 : +1 : differenceOfLogarithms < 0 ? -1 : +1;
                }
            } else {
                //TODO: remove when bitLength is fast
                var x = maybeJSBI.greaterThanOrEqual(a.exponent, b.exponent) ? a.significand : maybeJSBI.signedRightShift(a.significand, cachedBigInt(diff(b.exponent, a.exponent)));
                var y = maybeJSBI.greaterThanOrEqual(b.exponent, a.exponent) ? b.significand : maybeJSBI.signedRightShift(b.significand, cachedBigInt(diff(a.exponent, b.exponent)));
                if (maybeJSBI.lessThan(x, y)) {
                    return -1;
                }
                if (maybeJSBI.lessThan(y, x)) {
                    return +1;
                }
                //return x < y ? -1 : (x > y ? +1 : 0);
            }

            var x = maybeJSBI.lessThanOrEqual(a.exponent, b.exponent) ? a.significand : bigIntScale(a.significand, diff(a.exponent, b.exponent));
            var y = maybeJSBI.lessThanOrEqual(b.exponent, a.exponent) ? b.significand : bigIntScale(b.significand, diff(b.exponent, a.exponent));
            return maybeJSBI.lessThan(x, y) ? -1 : maybeJSBI.greaterThan(x, y) ? +1 : 0;
        }
        BigDecimal.lessThan = function(a, b) {
            return compare(a, b) < 0;
        };
        BigDecimal.greaterThan = function(a, b) {
            return compare(a, b) > 0;
        };
        BigDecimal.equal = function(a, b) {
            return compare(a, b) === 0;
        };
        BigDecimal.round = function(a, rounding) {
            //TODO: quick round algorithm (?)
            return round(a, rounding);
        };
        BigDecimal.prototype.toString = function() {
            //! https://tc39.es/ecma262/#sec-number.prototype.tostring
            if (BASE !== 10) {
                throw new Error();
            }
            if (arguments.length !== 0) {
                throw new RangeError("not implemented");
            }
            var x = BigDecimal.BigDecimal(this);
            //! https://tc39.es/ecma262/#sec-numeric-types-number-tostring
            if (BigDecimal.equal(x, BigDecimal.BigDecimal(0))) {
                return "0";
            }
            var sign = "";
            if (BigDecimal.lessThan(x, BigDecimal.BigDecimal(0))) {
                x = BigDecimal.unaryMinus(x);
                sign = "-";
            }
            var getSignificand = function(a, log10) {
                //var s = BigDecimal.multiply(exponentiate(10, -log10), a);
                //var m = BigDecimal.BigDecimal(Math.pow(10, 15));
                //while (!BigDecimal.equal(BigDecimal.round(BigDecimal.multiply(s, m), {maximumFractionDigits: 0, roundingMode: "half-even"}), BigDecimal.multiply(s, m))) {
                //  m = BigDecimal.multiply(m, m);
                //}
                //return BigDecimal.toBigInt(BigDecimal.multiply(s, m)).toString().replace(/0+$/g, "") || "0";
                return a.significand.toString().replace(/0+$/g, "") || "0";
            };
            var e = getCountOfDigits(x);
            var significand = getSignificand(x, e);
            if (!BigDecimal.greaterThan(exponentiate(10, JSBI.unaryMinus(JSBI.BigInt(6))), x) && BigDecimal.lessThan(x, exponentiate(10, JSBI.BigInt(21)))) {
                return sign + bigDecimalToPlainString(significand, JSBI.toNumber(JSBI.subtract(e, JSBI.BigInt(significand.length))), 0, 0);
            }
            return sign + bigDecimalToPlainString(significand, -(significand.length - 1), 0, 0) + "e" + (JSBI.greaterThanOrEqual(JSBI.subtract(e, JSBI.BigInt(1)), JSBI.BigInt(0)) ? "+" : "") + JSBI.subtract(e, JSBI.BigInt(1)).toString();
        };

        function bigDecimalToPlainString(significand, exponent, minFraction, minSignificant) {
            var e = maybeJSBI.add(exponent, significand.length) - 1;
            var i = significand.length - 1;
            while (i >= 0 && maybeJSBI.equal(significand.charCodeAt(i), "0".charCodeAt(0))) {
                i -= 1;
            }
            significand = significand.slice(0, i + 1);
            var zeros = Math.max(0, Math.max(e + 1, minSignificant) - significand.length);
            if (e <= -1) {
                significand = maybeJSBI.add("0".repeat(0 - e), significand);
                e = 0;
            }
            significand = maybeJSBI.add(significand, "0".repeat(zeros));
            significand = maybeJSBI.add(significand, "0".repeat(Math.max(minFraction - (significand.length - (e + 1)), 0)));
            return significand.slice(0, e + 1) + (significand.length > e + 1 ? "." + significand.slice(e + 1) : "");
        }
        // Something like Number#toPrecision: when value is between 10**-6 and Math.pow(10, p)? - to fixed, otherwise - to exponential:
        function toPrecision(significand, exponent, minSignificant) {
            var e = JSBI.add(exponent, JSBI.BigInt(significand.length - 1));
            if (JSBI.lessThan(e, JSBI.unaryMinus(JSBI.BigInt(6))) || JSBI.greaterThanOrEqual(e, JSBI.BigInt(minSignificant))) {
                return bigDecimalToPlainString(significand, -(significand.length - 1), 0, minSignificant) + "e" + (JSBI.lessThan(e, JSBI.BigInt(0)) ? "-" : "+") + bigIntAbs(e).toString();
            }
            return bigDecimalToPlainString(significand, maybeJSBI.toNumber(exponent), 0, minSignificant);
        }

        function toFixed(significand, exponent, minFraction) {
            return bigDecimalToPlainString(significand, exponent, minFraction, 0);
        }

        function toExponential(significand, exponent, minFraction) {
            var e = JSBI.add(exponent, JSBI.BigInt(significand.length - 1));
            return bigDecimalToPlainString(significand, -(significand.length - 1), 0, minFraction + 1) + "e" + (JSBI.lessThan(e, JSBI.BigInt(0)) ? "-" : "+") + bigIntAbs(e).toString();
        }
        BigDecimal.prototype.toFixed = function(fractionDigits, roundingMode) {
            roundingMode = roundingMode == undefined ? "half-up" : roundingMode;
            var value = BigDecimal.multiply(BigDecimal.BigDecimal(JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(fractionDigits))), this);
            var sign = BigDecimal.lessThan(value, BigDecimal.BigDecimal(0)) ? "-" : "";
            var rounded = BigDecimal.round(value, {
                maximumFractionDigits: 0,
                roundingMode: roundingMode
            });
            var a = BigDecimal.abs(rounded);
            return sign + toFixed(BigDecimal.toBigInt(a).toString(), maybeJSBI.unaryMinus(fractionDigits), fractionDigits);
        };

        function getDecimalSignificantAndExponent(value, precision, roundingMode) {
            //TODO: fix performance, test
            var exponentiate = function(x, n, rounding) {
                if (JSBI.lessThan(n, JSBI.BigInt(0))) {
                    return BigDecimal.divide(BigDecimal.BigDecimal(1), exponentiate(x, maybeJSBI.unaryMinus(n), rounding), rounding);
                }
                var y = undefined;
                while (JSBI.greaterThanOrEqual(n, JSBI.BigInt(1))) {
                    if (JSBI.equal(JSBI.remainder(n, JSBI.BigInt(2)), JSBI.BigInt(0))) {
                        x = BigDecimal.multiply(x, x, rounding);
                        n = JSBI.divide(n, JSBI.BigInt(2));
                    } else {
                        y = y == undefined ? x : BigDecimal.multiply(x, y, rounding);
                        n = JSBI.subtract(n, JSBI.BigInt(1));
                    }
                }
                return y == undefined ? BigDecimal.BigDecimal(1) : y;
            };
            var logarithm = function(x, b, rounding) {
                if (!BigDecimal.greaterThan(x, BigDecimal.BigDecimal(0))) {
                    throw new RangeError();
                }
                if (BigDecimal.lessThan(x, BigDecimal.BigDecimal(1))) {
                    return maybeJSBI.unaryMinus(logarithm(BigDecimal.divide(BigDecimal.BigDecimal(1), x, rounding), b, rounding));
                }
                var digits = getCountOfDigits(x);
                var v = JSBI.BigInt(bitLength(digits) - Math.floor(Math.log2(Number.MAX_SAFE_INTEGER + 1)));
                var log = JSBI.leftShift(JSBI.BigInt(Math.floor(JSBI.toNumber(JSBI.signedRightShift(digits, v)) / Math.log2(b) * Math.log2(BASE))), v);
                /*var ten = BigDecimal.BigDecimal(10);
                var b = 1n;
                while (!BigDecimal.lessThan(x, exponentiate(ten, b, rounding))) {
                  b *= 2n;
                }
                var e = 0n;
                while (b >= 1n) {
                  var u = exponentiate(ten, b, rounding);
                  if (!BigDecimal.lessThan(x, u)) {
                    e += b;
                    x = BigDecimal.divide(x, u, rounding);
                  }
                  b /= 2n;
                }
                return e;*/
                if (JSBI.lessThan(log, JSBI.BigInt(3))) {
                    return log;
                }
                return JSBI.add(log, logarithm(BigDecimal.divide(x, exponentiate(BigDecimal.BigDecimal(b), log, rounding), rounding), b, rounding));
            };
            var sign = BigDecimal.lessThan(value, BigDecimal.BigDecimal(0)) ? -1 : +1;
            var roundToInteger = function(a) {
                if (BigDecimal.greaterThan(a, BigDecimal.BigDecimal(0)) && BigDecimal.lessThan(a, BigDecimal.BigDecimal(1)) && BigDecimal.greaterThan(BigDecimal.multiply(BigDecimal.subtract(BigDecimal.BigDecimal(1), a), BigDecimal.BigDecimal(2 * 10)), BigDecimal.BigDecimal(1))) {
                    return BigDecimal.BigDecimal(0);
                }
                return BigDecimal.round(sign >= 0 ? a : BigDecimal.unaryMinus(a), {
                    maximumFractionDigits: 0,
                    roundingMode: roundingMode
                });
            };
            if (BigDecimal.equal(value, BigDecimal.BigDecimal(0))) {
                return {
                    significand: "0",
                    exponent: JSBI.BigInt(0)
                };
            }
            var ten = BigDecimal.BigDecimal(10);
            var minimumSignificantDigits = Math.pow(2, Math.ceil(Math.log2(bitLength(JSBI.add(bigIntAbs(JSBI.BigInt(value.exponent)), JSBI.BigInt(1))) / Math.log2(BASE))));
            var rounding = {
                maximumSignificantDigits: Math.max(minimumSignificantDigits, 8),
                roundingMode: "half-even"
            };
            var result = undefined;
            var fd = JSBI.BigInt(0);
            do {
                var x = BigDecimal.abs(value);
                fd = JSBI.subtract(JSBI.BigInt(0), logarithm(x, 10, rounding));
                x = BigDecimal.multiply(exponentiate(ten, fd, rounding), x, rounding);
                if (!BigDecimal.lessThan(x, ten)) {
                    fd = JSBI.subtract(fd, JSBI.BigInt(1));
                    x = BigDecimal.divide(x, ten, rounding);
                }
                if (BigDecimal.lessThan(x, BigDecimal.BigDecimal(1))) {
                    fd = JSBI.add(fd, JSBI.BigInt(1));
                    x = BigDecimal.multiply(x, ten, rounding);
                }
                if (!BigDecimal.lessThan(x, BigDecimal.BigDecimal(1)) && BigDecimal.lessThan(x, ten)) {
                    fd = JSBI.subtract(fd, JSBI.BigInt(1));
                    fd = JSBI.add(fd, JSBI.BigInt(precision));
                    x = BigDecimal.multiply(exponentiate(ten, fd, rounding), value, rounding);
                    x = BigDecimal.abs(x);
                    //x = BigDecimal.multiply(x, exponentiate(ten, BigInt(precision - 1), rounding), rounding);
                    var error = BigDecimal.multiply(BigDecimal.multiply(BigDecimal.BigDecimal(JSBI.add(bigIntAbs(fd), JSBI.BigInt(precision))), exponentiate(BigDecimal.BigDecimal(BASE), JSBI.unaryMinus(JSBI.BigInt(rounding.maximumSignificantDigits)))), x);
                    //TODO: ?
                    if (rounding.maximumSignificantDigits > (Math.abs(JSBI.toNumber(fd)) + precision) * Math.log2(10) + digits(value.significand) || BigDecimal.equal(roundToInteger(BigDecimal.add(x, error)), roundToInteger(BigDecimal.subtract(x, error)))) {
                        result = BigDecimal.toBigInt(BigDecimal.abs(roundToInteger(x))).toString();
                    }
                }
                rounding = {
                    maximumSignificantDigits: rounding.maximumSignificantDigits * 2,
                    roundingMode: "half-even"
                };
            } while (result == undefined);
            return {
                significand: result,
                exponent: JSBI.unaryMinus(fd)
            };
        }
        BigDecimal.prototype.toPrecision = function(precision, roundingMode) {
            roundingMode = roundingMode == undefined ? "half-up" : roundingMode;
            var tmp = getDecimalSignificantAndExponent(this, precision, roundingMode);
            return (BigDecimal.lessThan(this, BigDecimal.BigDecimal(0)) ? "-" : "") + toPrecision(tmp.significand, tmp.exponent, precision);
        };
        BigDecimal.prototype.toExponential = function(fractionDigits, roundingMode) {
            roundingMode = roundingMode == undefined ? "half-up" : roundingMode;
            var tmp = getDecimalSignificantAndExponent(this, fractionDigits + 1, roundingMode);
            return (BigDecimal.lessThan(this, BigDecimal.BigDecimal(0)) ? "-" : "") + toExponential(tmp.significand, tmp.exponent, fractionDigits);
        };

        function exponentiate(a, n) {
            if (maybeJSBI.notEqual(a, BASE)) {
                throw new RangeError("a should be BASE"); //?
            }

            return create(JSBI.BigInt(1), n);
        }

        function getCountOfDigits(a) {
            // floor(log(abs(a))/log(BASE)) + 1
            if (JSBI.equal(a.significand, JSBI.BigInt(0))) {
                throw new RangeError();
            }
            return JSBI.add(JSBI.BigInt(digits(a.significand)), JSBI.BigInt(a.exponent));
        }
        BigDecimal.abs = function(a) {
            return BigDecimal.lessThan(a, BigDecimal.BigDecimal(0)) ? BigDecimal.unaryMinus(a) : a;
        };
        BigDecimal.sign = function(a) {
            var zero = BigDecimal.BigDecimal(0);
            return BigDecimal.lessThan(a, zero) ? -1 : BigDecimal.greaterThan(a, zero) ? +1 : 0;
        };
        BigDecimal.max = function(a, b) {
            if (arguments.length > 2) {
                throw new RangeError("not implemented");
            }
            return BigDecimal.lessThan(a, b) ? b : a;
        };
        BigDecimal.min = function(a, b) {
            if (arguments.length > 2) {
                throw new RangeError("not implemented");
            }
            return BigDecimal.greaterThan(a, b) ? b : a;
        };

        function significandDigits(a) {
            var maximumSignificantDigits = 1;
            while (!BigDecimal.equal(BigDecimal.round(a, {
                    maximumSignificantDigits: maximumSignificantDigits,
                    roundingMode: "half-even"
                }), a)) {
                maximumSignificantDigits *= 2;
            }
            var from = maximumSignificantDigits / 2;
            var to = maximumSignificantDigits;
            while (to - 1 > from) {
                var middle = from + Math.floor((to - from) / 2);
                if (!BigDecimal.equal(BigDecimal.round(a, {
                        maximumSignificantDigits: middle,
                        roundingMode: "half-even"
                    }), a)) {
                    from = middle;
                } else {
                    to = middle;
                }
            }
            return to;
        }

        function getExponent(number) {
            var e = Math.floor(Math.log(Math.abs(number)) / Math.log(2)) - 1;
            return Math.abs(number) / Math.pow(2, e) >= 2 ? e + 1 : e;
        }

        function tryToMakeCorrectlyRounded(specialValue, f, name) {
            function getExpectedResultIntegerDigits(x) {
                if (name === "exp") {
                    // e**x <= Math.pow(BASE, k)
                    // k >= x / log(BASE)
                    return Math.ceil(maybeJSBI.toNumber(BigDecimal.toBigInt(BigDecimal.round(x, {
                        maximumFractionDigits: 0,
                        roundingMode: "half-even"
                    }))) / Math.log(BASE));
                }
                if (name === "log") {
                    // log(x) <= Math.pow(BASE, k)
                    // log(log(x))/log(BASE) <= k
                    return Math.ceil(Math.log2(Math.ceil(Math.max(JSBI.toNumber(getCountOfDigits(x)), 1) * Math.log(BASE))) / Math.log2(BASE));
                }
                return 1;
            }
            // (?) https://en.wikipedia.org/wiki/Rounding#Table-maker's_dilemma
            return function(x, rounding) {
                if (BigDecimal.equal(x, BigDecimal.BigDecimal(specialValue))) {
                    return f(x, {
                        maximumSignificantDigits: 1,
                        roundingMode: "half-even"
                    });
                }
                var result = BigDecimal.BigDecimal(0);
                var i = 0;
                var error = BigDecimal.BigDecimal(0);
                do {
                    if (i > 4 * ((9 + 1) / BASE) && rounding.maximumSignificantDigits != null && rounding.roundingMode === "half-even" && name !== "sin" && name !== "cos") {
                        console.error(x, rounding);
                        throw new Error();
                    }
                    i += 1;
                    var internalRounding = {
                        maximumSignificantDigits: Math.ceil(Math.max(rounding.maximumSignificantDigits || rounding.maximumFractionDigits + 1 + getExpectedResultIntegerDigits(x) - 1, significandDigits(x)) * Math.pow(2, Math.ceil((i - 1) / 3))) + 2 + (BASE === 2 ? 1 : 0),
                        roundingMode: "half-even"
                    };
                    result = undefined;
                    if (Math.max(internalRounding.maximumSignificantDigits + 2, significandDigits(x) + 1) <= Math.log2(Number.MAX_SAFE_INTEGER + 1) && BASE === 2) {
                        // Hm... https://www.gnu.org/software/libc/manual/html_node/Errors-in-Math-Functions.html
                        var exponent = maybeJSBI.toNumber(x.exponent);
                        var v = maybeJSBI.toNumber(x.significand) * Math.pow(BASE, exponent);
                        // some browsers have inaccurate results for Math.sin, Math.cos, Math.tan outside of [-pi/4;pi/4] range
                        if (name !== "sin" && name !== "cos" && name !== "tan" || Math.abs(v) <= Math.PI / 4) {
                            var numberValue = Math[name](v);
                            var MIN_NORMALIZED_VALUE = (Number.MIN_VALUE * 1.25 > Number.MIN_VALUE ? Number.MIN_VALUE : Number.MIN_VALUE * (Number.MAX_SAFE_INTEGER + 1) / 2) || Math.pow(2, -1022);
                            var a = Math.abs(numberValue);
                            if (a < 1 / 0 && a > MIN_NORMALIZED_VALUE) {
                                result = BigDecimal.BigDecimal(numberValue);
                            }
                        }
                    }
                    if (result == undefined) {
                        result = f(x, internalRounding);
                    }
                    // round(result - error) === round(result + error)
                    error = BigDecimal.multiply(exponentiate(BASE, JSBI.unaryMinus(JSBI.BigInt(internalRounding.maximumSignificantDigits))), BigDecimal.abs(result));
                    //if (i > 0) {
                    //console.log(i, f.name, x + "", result + "", error + "", BigDecimal.round(BigDecimal.subtract(result, error), rounding) + "", BigDecimal.round(BigDecimal.add(result, error), rounding) + "");
                    //}
                } while (!BigDecimal.equal(BigDecimal.round(BigDecimal.subtract(result, error), rounding), BigDecimal.round(BigDecimal.add(result, error), rounding)));
                if (i > 1) {
                    //console.debug(i, name);
                }
                return BigDecimal.round(result, rounding);
            };
        }

        function sqrt(x, rounding) {
            // from https://en.wikipedia.org/wiki/Square_root#Computation
            var lastResult = BigDecimal.add(x, BigDecimal.BigDecimal(1));
            var result = x;
            while (BigDecimal.lessThan(result, lastResult)) {
                lastResult = result;
                result = BigDecimal.divide(BigDecimal.add(BigDecimal.divide(x, result, rounding), result), BigDecimal.BigDecimal(2), rounding);
            }
            return result;
        }
        BigDecimal.log = tryToMakeCorrectlyRounded(1, function log(x, rounding) {
            if (!BigDecimal.greaterThan(x, BigDecimal.BigDecimal(0))) {
                throw new RangeError();
            }
            // https://ru.wikipedia.org/wiki/Логарифм#Разложение_в_ряд_и_вычисление_натурального_логарифма
            var internalRounding = {
                maximumSignificantDigits: rounding.maximumSignificantDigits + Math.ceil(Math.log2(rounding.maximumSignificantDigits + 0.5) / Math.log2(BASE)),
                roundingMode: "half-even"
            };
            if (true) {
                //! ln(f * Math.pow(BASE, k)) = ln(f) + k * ln(BASE), where (1/BASE) <= f <= BASE
                var k = JSBI.subtract(getCountOfDigits(x), JSBI.BigInt(1));
                var f = BigDecimal.multiply(exponentiate(BASE, JSBI.unaryMinus(k)), x);
                var ff = BigDecimal.round(BigDecimal.multiply(f, f), {
                    maximumSignificantDigits: 3,
                    roundingMode: "half-even"
                });
                if (BigDecimal.greaterThan(ff, exponentiate(BASE, JSBI.BigInt(1)))) {
                    k = JSBI.add(k, JSBI.BigInt(1));
                    f = BigDecimal.multiply(exponentiate(BASE, JSBI.unaryMinus(JSBI.BigInt(1))), f);
                }
                if (BigDecimal.lessThan(ff, exponentiate(BASE, JSBI.unaryMinus(JSBI.BigInt(1))))) {
                    k = JSBI.subtract(k, JSBI.BigInt(1));
                    f = BigDecimal.multiply(exponentiate(BASE, JSBI.BigInt(1)), f);
                }
                if (JSBI.notEqual(k, JSBI.BigInt(0))) {
                    return BigDecimal.add(BigDecimal.log(f, internalRounding), BigDecimal.multiply(BigDecimal.BigDecimal(JSBI.multiply(JSBI.BigInt(2), k)), BigDecimal.log(sqrt(BigDecimal.BigDecimal(BASE), internalRounding), internalRounding)));
                }
            }
            //! log(x) = log((1 + g) / (1 - g)) = 2*(g + g**3/3 + g**5/5 + ...)
            var g = BigDecimal.divide(BigDecimal.subtract(x, BigDecimal.BigDecimal(1)), BigDecimal.add(x, BigDecimal.BigDecimal(1)), internalRounding);
            var n = 1;
            var term = BigDecimal.BigDecimal(1);
            var sum = term;
            var lastSum = BigDecimal.BigDecimal(0);
            var gg = BigDecimal.multiply(g, g, internalRounding);
            while (!BigDecimal.equal(lastSum, sum)) {
                n += 2;
                term = BigDecimal.multiply(term, BigDecimal.BigDecimal(n - 2));
                term = BigDecimal.multiply(term, gg);
                term = BigDecimal.divide(term, BigDecimal.BigDecimal(n), internalRounding);
                lastSum = sum;
                sum = BigDecimal.add(sum, term, internalRounding);
            }
            return BigDecimal.multiply(BigDecimal.multiply(BigDecimal.BigDecimal(2), g), sum);
        }, "log");

        function fromNumberApproximate(number) {
            return BigDecimal.divide(BigDecimal.BigDecimal(Math.floor(number * (Number.MAX_SAFE_INTEGER + 1))), BigDecimal.add(BigDecimal.BigDecimal(Number.MAX_SAFE_INTEGER), BigDecimal.BigDecimal(1)), {
                maximumSignificantDigits: Math.floor(Math.log2(Number.MAX_SAFE_INTEGER + 1) / Math.log2(BASE) + 0.5),
                roundingMode: "half-even"
            });
        }
        BigDecimal.exp = tryToMakeCorrectlyRounded(0, function exp(x, rounding) {
            //! k = round(x / ln(BASE));
            //! exp(x) = exp(x - k * ln(BASE) + k * ln(BASE)) = exp(x - k * ln(BASE)) * BASE**k
            var internalRounding = {
                maximumSignificantDigits: rounding.maximumSignificantDigits + Math.ceil(Math.log2(rounding.maximumSignificantDigits + 0.5) / Math.log2(BASE)),
                roundingMode: "half-even"
            };
            if (!BigDecimal.equal(x, BigDecimal.BigDecimal(0))) {
                var logBASEApproximate = fromNumberApproximate(Math.log(BASE));
                var kApproximate = BigDecimal.round(BigDecimal.divide(x, logBASEApproximate, {
                    maximumSignificantDigits: Math.max(JSBI.toNumber(getCountOfDigits(x)), 1),
                    roundingMode: "half-even"
                }), {
                    maximumFractionDigits: 0,
                    roundingMode: "half-even"
                });
                if (!BigDecimal.equal(kApproximate, BigDecimal.BigDecimal(0))) {
                    var logBASE = BigDecimal.log(BigDecimal.BigDecimal(BASE), {
                        maximumSignificantDigits: internalRounding.maximumSignificantDigits + JSBI.toNumber(getCountOfDigits(kApproximate)),
                        roundingMode: "half-even"
                    });
                    var k = BigDecimal.round(BigDecimal.divide(x, logBASE, {
                        maximumSignificantDigits: Math.max(JSBI.toNumber(getCountOfDigits(x)), 1),
                        roundingMode: "half-even"
                    }), {
                        maximumFractionDigits: 0,
                        roundingMode: "half-even"
                    });
                    if (!BigDecimal.equal(k, BigDecimal.BigDecimal(0))) {
                        var r = BigDecimal.subtract(x, BigDecimal.multiply(k, logBASE));
                        return BigDecimal.multiply(exponentiate(BASE, BigDecimal.toBigInt(k)), BigDecimal.exp(r, internalRounding));
                    }
                }
            }
            // https://en.wikipedia.org/wiki/Exponential_function#Computation
            var n = 0;
            var term = BigDecimal.BigDecimal(1);
            var sum = term;
            var lastSum = BigDecimal.BigDecimal(0);
            while (!BigDecimal.equal(lastSum, sum)) {
                n += 1;
                term = BigDecimal.multiply(term, x);
                term = BigDecimal.divide(term, BigDecimal.BigDecimal(n), internalRounding);
                lastSum = sum;
                sum = BigDecimal.add(sum, term, internalRounding);
            }
            return sum;
        }, "exp");

        function divideByHalfOfPI(x, rounding) {
            // x = k*pi/2 + r + 2*pi*n, where |r| < pi/4
            var quarterOfPiApproximated = fromNumberApproximate(Math.PI / 4);
            if (BigDecimal.greaterThan(BigDecimal.abs(x), quarterOfPiApproximated)) {
                //TODO: FIX
                var internalRounding = {
                    maximumSignificantDigits: rounding.maximumSignificantDigits + significandDigits(x) + JSBI.toNumber(getCountOfDigits(x)) + 1 + Math.ceil(42 / Math.log2(BASE)),
                    roundingMode: "half-even"
                };
                var halfOfPi = BigDecimal.multiply(BigDecimal.BigDecimal(2), BigDecimal.atan(BigDecimal.BigDecimal(1), internalRounding));
                var i = BigDecimal.round(BigDecimal.divide(x, halfOfPi, {
                    maximumSignificantDigits: Math.max(JSBI.toNumber(getCountOfDigits(x)), 1),
                    roundingMode: "half-even"
                }), {
                    maximumFractionDigits: 0,
                    roundingMode: "half-even"
                });
                var remainder = BigDecimal.subtract(x, BigDecimal.multiply(i, halfOfPi));
                return {
                    remainder: remainder,
                    k: (JSBI.toNumber(JSBI.remainder(BigDecimal.toBigInt(i), JSBI.BigInt(4))) + 4) % 4
                };
            }
            return {
                remainder: x,
                k: 0
            };
        }

        function _cos(x, rounding, subtractHalfOfPi) {
            var tmp = divideByHalfOfPI(x, rounding);
            var a = tmp.remainder;
            var k = (tmp.k + (subtractHalfOfPi ? -1 + 4 : 0)) % 4;
            // https://en.wikipedia.org/wiki/Lookup_table#Computing_sines
            // https://en.wikipedia.org/wiki/Trigonometric_functions#Power_series_expansion
            var internalRounding = {
                maximumSignificantDigits: rounding.maximumSignificantDigits + Math.ceil(Math.log2(rounding.maximumSignificantDigits + 0.5) / Math.log2(BASE)),
                roundingMode: "half-even"
            };
            var n = k === 1 || k === 3 ? 1 : 0;
            var term = BigDecimal.BigDecimal(1);
            var sum = term;
            var lastSum = BigDecimal.BigDecimal(0);
            var aa = BigDecimal.multiply(a, a);
            while (!BigDecimal.equal(lastSum, sum)) {
                n += 2;
                term = BigDecimal.multiply(term, aa);
                term = BigDecimal.divide(term, BigDecimal.BigDecimal(-n * (n - 1)), internalRounding);
                lastSum = sum;
                sum = BigDecimal.add(sum, term, internalRounding);
            }
            if (k === 1 || k === 2) {
                sum = BigDecimal.unaryMinus(sum);
            }
            return k === 1 || k === 3 ? BigDecimal.multiply(a, sum) : sum;
        }
        BigDecimal.sin = tryToMakeCorrectlyRounded(0, function(x, rounding) {
            return _cos(x, rounding, true);
        }, "sin");
        BigDecimal.cos = tryToMakeCorrectlyRounded(0, function(x, rounding) {
            return _cos(x, rounding, false);
        }, "cos");
        BigDecimal.atan = tryToMakeCorrectlyRounded(0, function(x, rounding) {
            if (BigDecimal.greaterThan(BigDecimal.abs(x), BigDecimal.BigDecimal(1))) {
                //Note: rounding to maximumFractionDigits
                var internalRounding = {
                    maximumFractionDigits: rounding.maximumSignificantDigits + 1,
                    roundingMode: "half-even"
                };
                var halfOfPi = BigDecimal.multiply(BigDecimal.atan(BigDecimal.BigDecimal(1), internalRounding), BigDecimal.BigDecimal(2));
                return BigDecimal.multiply(BigDecimal.BigDecimal(BigDecimal.lessThan(x, BigDecimal.BigDecimal(0)) ? -1 : +1), BigDecimal.subtract(halfOfPi, BigDecimal.atan(BigDecimal.divide(BigDecimal.BigDecimal(1), BigDecimal.abs(x), internalRounding), internalRounding)));
            }
            // https://en.wikipedia.org/wiki/Inverse_trigonometric_functions#:~:text=Alternatively,%20this%20can%20be%20expressed%20as
            var internalRounding = {
                maximumSignificantDigits: rounding.maximumSignificantDigits + Math.ceil(Math.log2(rounding.maximumSignificantDigits + 0.5) / Math.log2(BASE)),
                roundingMode: "half-even"
            };
            var n = 0;
            var xx = BigDecimal.multiply(x, x);
            var xxplus1 = BigDecimal.add(BigDecimal.BigDecimal(1), xx);
            var term = BigDecimal.divide(BigDecimal.BigDecimal(1), xxplus1, internalRounding);
            var sum = term;
            var lastSum = BigDecimal.BigDecimal(0);
            while (!BigDecimal.equal(lastSum, sum)) {
                n += 1;
                term = BigDecimal.multiply(term, BigDecimal.multiply(BigDecimal.BigDecimal(2 * n), xx));
                term = BigDecimal.divide(term, BigDecimal.multiply(BigDecimal.BigDecimal(2 * n + 1), xxplus1), internalRounding);
                lastSum = sum;
                sum = BigDecimal.add(sum, term, internalRounding);
            }
            return BigDecimal.multiply(x, sum);
        }, "atan");
        BigDecimal.sqrt = function(x, rounding) {
            if (BigDecimal.lessThan(x, BigDecimal.BigDecimal(0))) {
                throw new RangeError();
            }
            if (BigDecimal.equal(x, BigDecimal.BigDecimal(0))) {
                return x;
            }
            // https://en.wikipedia.org/wiki/Nth_root#Using_Newton's_method
            var e = JSBI.divide(getCountOfDigits(x), JSBI.BigInt(2));
            var t = exponentiate(BASE, e);
            var y = BigDecimal.multiply(x, exponentiate(BASE, JSBI.unaryMinus(JSBI.multiply(JSBI.BigInt(2), e))));
            var k = Math.floor(Math.log2(Number.MAX_SAFE_INTEGER + 1) / Math.log2(BASE)) - 1;
            var xn = BigDecimal.toNumber(BigDecimal.round(BigDecimal.multiply(y, exponentiate(BASE, k)), {
                maximumFractionDigits: 0,
                roundingMode: "half-even"
            })) / Math.pow(BASE, k);
            var r = Math.sqrt(xn);
            //TODO: fix
            var resultSignificantDigits = 2 * (rounding.maximumSignificantDigits || rounding.maximumFractionDigits + Math.ceil(significandDigits(x) / 2) || 1);
            var result = BigDecimal.multiply(BigDecimal.BigDecimal(Math.sign(r) * Math.floor(Math.abs(r) * Math.pow(BASE, k) + 0.5)), exponentiate(BASE, -k));
            var iteration = function(result, internalRounding) {
                return BigDecimal.divide(BigDecimal.add(y, BigDecimal.multiply(result, result)), BigDecimal.multiply(BigDecimal.BigDecimal(2), result), internalRounding);
            };
            for (var i = Math.max(k - 1, 1); i <= resultSignificantDigits; i *= 2) {
                var internalRounding = {
                    maximumSignificantDigits: i,
                    roundingMode: "half-even"
                };
                result = iteration(result, internalRounding);
            }
            result = iteration(result, rounding);
            return BigDecimal.multiply(result, t);
        };
        return BigDecimal;
    };
    var BigDecimal = factory(10);
    var BigFloat = factory(2);
    self.BigDecimal = BigDecimal;
    self.BigFloat = BigFloat;
})();
(function() {
    "use strict";

    // Example:
    // var N = NewtonInterpolation();
    // N.next();
    // console.log(N.next([1,1]).value); // y = 1
    // console.log(N.next([2,4]).value); // y = 3x - 2
    // console.log(N.next([3,9]).value); // y = x^2

    var DefaultYField = {
        ONE: 1,
        sub: function(a, b) {
            return a - b;
        },
        mul: function(a, b) {
            return a * b;
        },
        div: function(a, b) {
            return a / b;
        },
        scale: function(a, s) {
            return a * Number(s);
        }
    };

    var yField = DefaultYField;

    // An iterator which returns an updated Newton interpolation polynomial
    // Polynomial is returned as an array of coefficients
    function NewtonInterpolation() {
        var coefficients = function() {
            var x = [];
            var diagonal = []; // [y_k], [y_(k-1), y_k], ..., [y_0, y_1, ..., y_k]
            var equidistantly = true;
            var hInKTimeskFactorial = yField.ONE; // h**k * k!
            var c = yField.ONE;
            var firstTime = true;
            var iterator = {
                next: function(point) {
                    while (true) {
                        if (firstTime) {
                            firstTime = false;
                            return {
                                value: c,
                                done: false
                            };
                        }
                        var $tmpxi_yi = point;
                        var xi = $tmpxi_yi[0];
                        var yi = $tmpxi_yi[1];
                        if (equidistantly && x.length >= 2 && x[x.length - 1] - x[x.length - 2] !== xi - x[x.length - 1]) {
                            // https://en.wikipedia.org/wiki/Divided_differences#:~:text=The%20relationship%20between%20divided%20differences%20and%20forward%20differences%20is[4]
                            var h = x[x.length - 1] - x[x.length - 2];
                            hInKTimeskFactorial = yField.ONE;
                            for (var k = 1; k < diagonal.length; k += 1) {
                                hInKTimeskFactorial = yField.scale(hInKTimeskFactorial, h * k);
                                diagonal[k] = yField.div(diagonal[k], hInKTimeskFactorial);
                            }
                            equidistantly = false;
                        }
                        var value = yi;
                        for (var i = 0; i < diagonal.length; i += 1) {
                            // https://en.wikipedia.org/wiki/Divided_differences#Example
                            var difference = yField.sub(value, diagonal[i]);
                            if (!equidistantly) {
                                difference = yField.div(difference, yField.scale(yField.ONE, xi - x[x.length - 1 - i]));
                            }
                            diagonal[i] = value;
                            value = difference;
                        }
                        diagonal.push(value);
                        x.push(xi);
                        c = diagonal[diagonal.length - 1];
                        if (equidistantly && x.length >= 2) {
                            var k = diagonal.length - 1;
                            var h = x[x.length - 1] - x[x.length - 2];
                            hInKTimeskFactorial = yField.scale(hInKTimeskFactorial, h * k);
                            c = yField.div(c, hInKTimeskFactorial);
                        }
                        return {
                            value: c,
                            done: false
                        };
                    }
                }
            };
            iterator[globalThis.Symbol.iterator] = function() {
                return this;
            };
            return iterator;
        };
        var yZERO = yField.sub(yField.ONE, yField.ONE);
        var yONE = yField.ONE;
        var a = coefficients();
        a.next();
        // https://en.wikipedia.org/wiki/Newton_polynomial#Definition
        var basisPolynomial = [yONE]; // n_j(x)
        var N = [];
        var firstTime = true;
        var iterator = {
            next: function(point) {
                while (true) {
                    if (firstTime) {
                        firstTime = false;
                        return {
                            value: N,
                            done: false
                        };
                    }
                    var $tmpxi_yi = point;
                    var xi = $tmpxi_yi[0];
                    var yi = $tmpxi_yi[1];
                    var c = yField.sub(yZERO, a.next([xi, yi]).value);
                    // N = N + c * basisPolynomial
                    N.push(yZERO);
                    for (var i = basisPolynomial.length - 1; i >= 0; i -= 1) {
                        N[i] = yField.sub(N[i], yField.mul(basisPolynomial[i], c));
                    }
                    //console.log(N.join(" "));
                    // basisPolynomial = basisPolynomial * (x - xi)
                    basisPolynomial.push(yZERO);
                    for (var i = basisPolynomial.length - 1; i >= 0; i -= 1) {
                        basisPolynomial[i] = yField.sub(i >= 1 ? basisPolynomial[i - 1] : yZERO, yField.scale(basisPolynomial[i], xi));
                    }
                    return {
                        value: N,
                        done: false
                    };
                }
            }
        };
        iterator[globalThis.Symbol.iterator] = function() {
            return this;
        };
        return iterator;
    }

    NewtonInterpolation.setField = function(newYField) {
        yField = newYField || DefaultYField;
    };

    globalThis.NewtonInterpolation = NewtonInterpolation;
    self.NewtonInterpolation = NewtonInterpolation;

})();
(function() {
    "use strict";
    /*jslint plusplus: true, vars: true, indent: 2 */

    // Thanks to Eduardo Cavazos
    // see also https://github.com/dharmatech/Symbolism/blob/master/Symbolism/Symbolism.cs
    // see also "Computer Algebra and Symbolic Computation: Elementary Algorithms" by Joel S. Cohen

    // public API:
    // Expression.prototype.add
    // Expression.prototype.subtract
    // Expression.prototype.multiply
    // ...
    // protected API:
    // Expression.prototype.addExpression
    // Expression.prototype.addInteger

    //









    function gcdOfSafeIntegers(a, b) {
        a = Math.abs(a);
        b = Math.abs(b);
        while (b !== 0) {
            var r = a - Math.floor(a / b) * b;
            a = b;
            b = r;
        }
        return a;
    }

    Math.gcd = function(a, b) {
        if (typeof a !== "number" &&
            typeof b !== "number") {
            throw new RangeError();
        }
        var maxSMI = 1073741823;
        if ((a | 0) === a && Math.abs(a) <= maxSMI &&
            (b | 0) === b && Math.abs(b) <= maxSMI) {
            var A = Math.abs(a);
            var B = Math.abs(b);
            while (B !== 0) {
                var R = A % B;
                A = B;
                B = R;
            }
            return A;
        }
        return gcdOfSafeIntegers(a, b);
    };

    function integerMin(a, b) {
        return a.compareTo(b) < 0 ? a : b;
    }

    function bigIntGCDWrapper2(a, b) {
        if (Math.abs(SmallBigInt.toNumber(a)) >= 1 / 0 && Math.abs(SmallBigInt.toNumber(b)) >= 1 / 0) {
            var size = integerMin(Expression.Integer.fromBigInt(a).abs(), Expression.Integer.fromBigInt(b).abs()).bitLength();
            size = Math.pow(2, Math.ceil(Math.log2(size)));
            if (size >= 128 * 1024) {
                if (size > lastMaxSize) {
                    lastMaxSize = size;
                    var error = new TypeError("big size of " + "gcd" + " " + size);
                    if (globalThis.onerror != null) {
                        globalThis.onerror(error.message, "", 0, 0, error);
                    }
                }
            }
        }
        return bigIntGCD(SmallBigInt.BigInt(a), SmallBigInt.BigInt(b));
    }

    function bigIntGCDWrapper(a, b) {
        if (typeof a === "number" && typeof b === "number") {
            return Math.gcd(a, b);
        }
        return bigIntGCDWrapper2(a, b);
    }

    var pow = function(x, count, accumulator) {
        if (!(count >= 0)) {
            throw new RangeError();
        }
        if (count > Number.MAX_SAFE_INTEGER) {
            throw new RangeError("NotSupportedError");
        }
        return (count < 1 ? accumulator : (2 * Math.floor(count / 2) !== count ? pow(x, count - 1, accumulator.multiply(x)) : pow(x.multiply(x), Math.floor(count / 2), accumulator)));
    };

    // https://stackoverflow.com/a/15302448/839199
    var binomialCoefficient = function(n, k) { // binomail coefficient
        return k === 0 ? Expression.ONE : n.multiply(binomialCoefficient(n.subtract(Expression.ONE), k - 1)).divide(Integer.fromNumber(k));
    };

    /*
      var powerOfJordanForm = function (J, N) {
        return J.map(function (e, i, j) {
          if (i > j) {
            return Expression.ZERO;
          }
          if (i === j) {
            return J.e(i, i).equals(Expression.ZERO) ? Expression.ZERO : J.e(i, i).pow(N);
          }
          if (J.e(i, i + 1).equals(Expression.ZERO)) {
            return Expression.ZERO;
          }
          var m = j - i;
          for (var k = 0; k < m; k += 1) {
            if (!J.e(j - 1 - k, j - k).equals(Expression.ONE)) { // outside of a block
              return Expression.ZERO;
            }
          }
          return J.e(i, i).equals(Expression.ZERO) ? Expression.ZERO : binomialCoefficient(N, m).multiply(J.e(i, i).pow(N.subtract(Expression.Integer.fromNumber(m))));
        });
      };
    */

    var matrixInN = function(matrix, n) {
        var condition = -1;
        /*
        if (matrix.isDiagonal()) {
          for (var i = 0; i < matrix.cols(); i += 1) {
            if (matrix.e(i, i).equals(Expression.ZERO)) {
              condition = 0;//?
            }
          }
          var result = matrix.map(function (e, i, j) {
            return i === j ? (e.equals(Expression.ZERO) ? Expression.ZERO : e.pow(n)) : Expression.ZERO;
          });
          var an = new Expression.Matrix(result);
          return condition !== -1 ? new ExpressionWithCondition(an, Condition.TRUE.andGreaterZero(n.subtract(Expression.Integer.fromNumber(condition)))) : an;
        }
        */
        /*
        if (matrix.isJordanMatrix()) {
          for (var i = 0; i < matrix.cols(); i += 1) {
            if (matrix.e(i, i).equals(Expression.ZERO)) {
              condition = Math.max(condition, 0);
              // should be Jordan block size minus one (?)
              for (var j = 0; i + j + 1 < matrix.cols(); j += 1) {
                if (matrix.e(i + j, i + j + 1).equals(Expression.ONE)) {
                  condition = Math.max(condition, j + 1);
                }
              }
            }
          }
          var an = new Expression.Matrix(powerOfJordanForm(matrix, n));
          if (condition > 0) {//TODO: remove(merge)
            var cases = [];
            cases.push(new ExpressionWithCondition(an, Condition.TRUE.andGreaterZero(n.subtract(Integer.fromNumber(condition)))));
            for (var i = 1; i <= condition; i += 1) {
              cases.push(new ExpressionWithCondition(new Expression.Matrix(matrix.pow(i)), Condition.TRUE.andZero(n.subtract(Integer.fromNumber(i)))));
            }
            return new Expression.Cases(cases);
          }
          return condition !== -1 ? new ExpressionWithCondition(an, Condition.TRUE.andGreaterZero(n.subtract(Integer.fromNumber(condition)))) : an;
        }
        */
        //!
        var D = matrix.map(function(e, i, j) {
            return i === j ? e : Expression.ZERO;
        });
        var N = matrix.subtract(D);
        if (N.isNilpotent()) { //TODO: fix Matrix#isNilpotent
            if (D.multiply(N).eql(N.multiply(D))) { // D and N commute
                //Note: covers diagonal matrices and Jordan matrices
                for (var k = 0; k < D.cols(); k += 1) {
                    if (D.e(k, k).equals(Expression.ZERO)) {
                        var index = 1;
                        while (!N.pow(index).map(function(e, i, j) {
                                return i !== k ? Expression.ZERO : e;
                            }).isZero()) {
                            if (index >= N.cols()) {
                                throw new TypeError("assertion");
                            }
                            index += 1;
                        }
                        condition = Math.max(condition, index - 1); //?
                    }
                }
                var result = Matrix.Zero(N.cols(), N.cols());
                for (var k = 0; k < N.cols() && (k === 0 || !N.isZero()); k += 1) {
                    var Dnmk = D.map(function(e, i, j) {
                        return i === j ? (e.equals(Expression.ZERO) ? Expression.ZERO : e.pow(n.subtract(Expression.Integer.fromNumber(k)))) : Expression.ZERO;
                    });
                    result = result.add(Dnmk.multiply(N.pow(k)).scale(binomialCoefficient(n, k)));
                }
                var an = new Expression.Matrix(result);
                if (condition > 0) { //TODO: remove(merge)
                    var cases = [];
                    cases.push(new ExpressionWithCondition(an, Condition.TRUE.andGreaterZero(n.subtract(Integer.fromNumber(condition)))));
                    for (var i = 1; i <= condition; i += 1) {
                        cases.push(new ExpressionWithCondition(new Expression.Matrix(matrix.pow(i)), Condition.TRUE.andZero(n.subtract(Integer.fromNumber(i)))));
                    }
                    return new Expression.Cases(cases);
                }
                return condition !== -1 ? new ExpressionWithCondition(an, Condition.TRUE.andGreaterZero(n.subtract(Integer.fromNumber(condition)))) : an;
            }
        }
        //!
        var canExponentiate = function(k) {
            if (enableAN && k instanceof Expression.Symbol) {
                return true;
            }
            if (k instanceof Exponentiation && getBase(k) instanceof Integer && getBase(k).compareTo(Expression.ONE) > 0 && isIntegerOrN(getExponent(k).inverse())) { //TODO: remove (no need if to change other codes) of fix `isConstant`?
                return true;
            }
            return isConstant(k) || isConstant(k.divide(Expression.E));
        };
        //Note: experimental
        // {{1,0,0},{0,1,1},{0,0,1}}^n === {{1,0,0},{0,1,n},{0,0,1}}
        // A
        var a = matrix;
        // A^(n-1)
        var symbolName = "aa";
        var anm1 = matrix.map(function(e, i, j) {
            return new Expression.Symbol(symbolName + "_(" + i + "," + j + ")");
        });
        var anm1previous = anm1.map(function(e, i, j) {
            return Expression.ZERO;
        });
        var an = undefined;
        var iteration = -1;
        while (!anm1.eql(anm1previous)) {
            iteration += 1;
            anm1previous = anm1;
            // A^(n) = A^(n-1) * A;
            an = anm1.multiply(a);
            anm1 = an.map(function(e, i, j) {
                var isSymbol = anm1.e(i, j) instanceof Expression.Symbol && anm1.e(i, j).symbol.slice(0, symbolName.length) === symbolName;
                if (!isSymbol) {
                    return anm1.e(i, j); //?
                }
                // an: {{1,0,0},{0,1,1+aa_23},{0,0,1}}
                // a_n = n + a_(n-1)
                // a_n = k * a_(n-1) + c * k**(n-(m+1)) * choose(n-1, m)
                // =>
                // a_n = c * k**(n-(m+1)) * choose(n, m+1)
                // Note: choose(n-1, m) + choose(n-2, m) + choose(n-3, m) + ... = choose(n, m+1)
                // choose(n-1, m+1) + choose(n-1, m) = choose(n, m+1)
                if (!(e instanceof Integer)) {
                    var m = Polynomial.toPolynomial(e.getNumerator(), n).getDegree();
                    var previous = anm1.e(i, j);
                    var p = Polynomial.toPolynomial(e.getNumerator(), previous);
                    var k = p.getLeadingCoefficient().divide(e.getDenominator());
                    if (m !== 0 &&
                        p.getDegree() === 1 &&
                        a.e(i, j).equals(Expression.ZERO) && //TODO: remove
                        (k instanceof Integer || k instanceof Expression.Complex || canExponentiate(k))) { //TODO: fix
                        var f = k.pow(n).divide(k.pow(Integer.fromNumber(m + 1))).multiply(binomialCoefficient(n.subtract(Expression.ONE), m));
                        var c = e.subtract(k.multiply(previous)).divide(f);
                        //TODO: remove `k instanceof Integer`
                        if (c instanceof Integer) { //?TODO: ?
                            console.log("!", e.toString());
                            // a.e(i, j).add()
                            return c.multiply(k.pow(n).divide(k.pow(Integer.fromNumber(m + 2))).multiply(binomialCoefficient(n.subtract(Expression.ONE), m + 1)));
                        }
                    }
                }
                // a_n = a_(n-1)
                if (e.equals(anm1.e(i, j))) {
                    return a.e(i, j);
                }
                // a_n = k * a_(n-1) + function (b) { return a_n = k**(n - 1) * a_1 + b * (1-k**(n-2))/(1-k); }
                if (anm1.e(i, j) instanceof Expression.Symbol && anm1.e(i, j).symbol === symbolName + "_(" + i + "," + j + ")" && !e.equals(Expression.ZERO)) {
                    var previous = anm1.e(i, j);
                    var p = Polynomial.toPolynomial(e.getNumerator(), previous);
                    var k = p.getLeadingCoefficient().divide(e.getDenominator());
                    var b = p.getCoefficient(0).divide(e.getDenominator());
                    if (!Expression.has(b, Expression.Symbol) && //TODO: !!!
                        e.equals(k.multiply(previous).add(b))) {
                        var s = k.equals(Expression.ONE) ? b.multiply(n.subtract(Expression.TWO)) : b.multiply(Expression.ONE.subtract(k.pow(n.subtract(Expression.TWO))).divide(Expression.ONE.subtract(k)));
                        return k.pow(n.subtract(Expression.TWO)).multiply(a.e(i, j)).add(s);
                    }
                }
                if (anm1.e(i, j) instanceof Expression.Symbol && anm1.e(i, j).symbol === symbolName + "_(" + i + "," + j + ")" && e.equals(Expression.ZERO)) {
                    //!TODO: conditions.push(iteration); //? n > 0 && n <= 3 , n > 3 - ?
                    condition = iteration;
                    return Expression.ZERO;
                }
                // a_n = a_(n-1) + function (b) { return a_n = a_1 + b*(n-1); }
                var sub = e.subtract(anm1.e(i, j));
                if (sub instanceof Integer) {
                    return a.e(i, j).add(sub.multiply(n.subtract(Expression.TWO)));
                }
                var dpnm1pda = function(k) { // k**(n-1) + k * a_(n-1)
                    if (!canExponentiate(k)) { //TODO: remove
                        return Expression.ZERO; // cannot do k.pow(n)
                    }
                    var previous = anm1.e(i, j);
                    return k.pow(n.subtract(Expression.ONE)).add(k.multiply(previous));
                };
                // a_n = d**(n-1) + d * a_(n-1)
                // a_n = d**(n-1) + d * a_(n-1) = 2 * d**(n-1) + d**2 * a_(n-2) = ... = n * d**(n-1) + d**n
                if (!e.equals(Expression.ZERO)) {
                    var previous = anm1.e(i, j);
                    var p = Polynomial.toPolynomial(e.getNumerator(), previous);
                    var k = p.getLeadingCoefficient().divide(e.getDenominator());
                    var d = k;
                    if (e.equals(dpnm1pda(d))) {
                        return d.pow(n.subtract(Expression.TWO)).multiply(n.subtract(Expression.TWO).add(a.e(i, j)));
                    }
                    var d = k.negate();
                    if (e.equals(dpnm1pda(d))) {
                        return d.pow(n.subtract(Expression.TWO)).multiply(n.subtract(Expression.TWO).add(a.e(i, j)));
                    }
                }

                return anm1.e(i, j);
            });
        }
        for (var i = 0; i < anm1.rows(); i += 1) {
            for (var j = 0; j < anm1.cols(); j += 1) {
                var e = anm1.e(i, j);
                if (e instanceof Expression.Symbol && e.symbol.slice(0, symbolName.length) === symbolName) {
                    return undefined;
                }
            }
        }
        if (condition > 0) {
            var cases = [];
            cases.push(new ExpressionWithCondition(new Expression.Matrix(an), Condition.TRUE.andGreaterZero(n.subtract(Integer.fromNumber(condition)))));
            for (var i = 1; i <= condition; i += 1) {
                cases.push(new ExpressionWithCondition(new Expression.Matrix(a.pow(i)), Condition.TRUE.andZero(n.subtract(Integer.fromNumber(i)))));
            }
            return new Expression.Cases(cases);
        }
        var e = new Expression.Matrix(an);
        return condition !== -1 ? new ExpressionWithCondition(e, Condition.TRUE.andGreaterZero(n.subtract(Integer.fromNumber(condition)))) : e;
    };

    var enableEX = true;
    var enable2X = true;
    var enableEC = true;
    var enableAN = true;

    var isPositiveQuick = function(x) {
        if (x instanceof Integer) {
            return x.compareTo(Expression.ZERO) > 0;
        }
        if (x instanceof NthRoot) {
            return isPositiveQuick(x.a); //?
        }
        if ((x instanceof Multiplication || x instanceof Division) && !x.a.equals(Expression.ONE.negate()) && !x.b.equals(Expression.ONE.negate())) {
            return (isPositiveQuick(x.a) && isPositiveQuick(x.b)) || (isPositiveQuick(x.a.negate()) && isPositiveQuick(x.b.negate())); //? bug - ?
        }
        if (x instanceof Addition) {
            return isPositiveQuick(x.a) && isPositiveQuick(x.b);
        }
        if (x instanceof Expression.PolynomialRootSymbol) {
            return isPositiveQuick(x.interval.a) && isPositiveQuick(x.interval.b);
        }
        if (x instanceof Expression.Multiplication && x.a.equals(Expression.ONE.negate()) && x.b instanceof Expression.PolynomialRootSymbol) {
            return !isPositiveQuick(x.b.interval.a) && !isPositiveQuick(x.b.interval.b);
        }
        //TODO: ?
        /*if (x instanceof Expression.ExpressionPolynomialRoot) {
          return isPositiveQuick(x.root.interval.a) && isPositiveQuick(x.root.interval.b);
        }
        if (x instanceof Expression.Multiplication && x.a.equals(Expression.ONE.negate()) && x.b instanceof Expression.ExpressionPolynomialRoot) {
          return !isPositiveQuick(x.b.root.interval.a) && !isPositiveQuick(x.b.root.interval.b);
        }
        if (x instanceof Expression.ExpressionWithPolynomialRoot) {
          return isPositiveQuick(x.e);
        }*/
        if (x instanceof Expression.Abs) {
            return true;
        }
        return false;
    };

    var isPositive = function(x) {
        if (x.equals(Expression.ZERO)) {
            return false;
        }
        if (isPositiveQuick(x)) {
            return true;
        }
        if (isPositiveQuick(x.negate())) {
            return false;
        }
        if (x instanceof Expression.Symbol && !(x instanceof Expression.PolynomialRootSymbol) && !(x instanceof Expression.ExpressionPolynomialRoot) && !(x instanceof Expression.ExpressionWithPolynomialRoot)) {
            if (x === Expression.PI || x === Expression.E) {
                return true;
            }
            return false;
        }
        if (x instanceof Expression.Complex) {
            return false;
        }
        if (Expression.has(x, Expression.Complex)) { //???
            return false;
        }
        //TODO:
        //if (x instanceof ExpressionPolynomialRoot) {
        //  var tmp = x.sign();
        //  return tmp > 0;
        //}
        if (x instanceof Addition || x instanceof Expression.Cos || x instanceof Expression.Sin || x instanceof Expression.Exponentiation || x instanceof Expression.Multiplication || x instanceof Expression.PolynomialRootSymbol || x instanceof Expression.ExpressionPolynomialRoot || x instanceof Expression.ExpressionWithPolynomialRoot || x instanceof Expression.Division) {
            var tmp = toDecimalStringInternal(x, {
                significantDigits: 1
            });
            var value = tmp == undefined ? 0 / 0 : Number(tmp.replace(/\((\d+)\)/g, '$1').replace(/\*10\^/g, 'e'));
            if (!Number.isNaN(value)) {
                return value > 0;
            }
        }
        if (x instanceof Expression.ExponentiationOfMinusOne) {
            return false;
        }
        if (x instanceof Expression.Exponentiation && getExponent(x) instanceof Expression.Integer) {
            return isPositive(x.a); // x**2
        }
        if (Expression.has(x, Expression.Symbol)) {
            return false; //?
        }
        //TODO: tests, fix for algebraic numbers (?)
        if (x instanceof Expression.Logarithm) {
            return isPositive(x.a.subtract(Expression.ONE));
        }
        throw new TypeError("!" + x);
    };

    Expression._isPositive = isPositive;




    var isIntegerOrN = function(e) {
        if (e instanceof Integer) {
            return true;
        }
        if (e instanceof Expression.Symbol && (e.symbol === "n" || e.symbol === "k")) {
            return true;
        }
        if (e instanceof Expression.Addition || e instanceof Expression.Multiplication || e instanceof Expression.Exponentiation) {
            return isIntegerOrN(e.a) && isIntegerOrN(e.b);
        }
        //TODO: factorial - ?
        //TODO: n*(n+1)/2
        return false;
    };

    var isGoodPolynomial = function(x) {
        if (x instanceof Expression.Exponentiation) {
            return false;
        }
        var v = getVariableInternal(getLastMultiplicationOperand(getFirstAdditionOperand(x))).next().value.v; // avoid square roots
        if (v instanceof Expression.Symbol) {
            var p = Polynomial.toPolynomial(x, v);
            if (p.getDegree() === 1 && p.getCoefficient(0) instanceof Expression.Integer && p.getCoefficient(1) instanceof Expression.Integer) {
                if (p.getContent().equals(Expression.ONE)) {
                    return true;
                }
            }
        }
        return false;
    };

    var isMatrixSymbolTranspose = function(e) {
        if (e instanceof Expression.Exponentiation) {
            if (getBase(e) instanceof Expression.MatrixSymbol) {
                var exp = getExponent(e);
                if (exp instanceof Expression.Symbol && exp.symbol === "T") {
                    return true;
                }
                if (exp instanceof Expression.Multiplication && exp.a instanceof Expression.Integer && exp.b instanceof Expression.Symbol && exp.b.symbol === "T") {
                    return true;
                }
            }
        }
        return false;
    };

    Expression.prototype.powExpression = function(x) {
        var y = this;

        if (y === Expression.INFINITY) {
            if (Expression.isReal(x)) {
                if (x.compareTo(Expression.ONE) > 0) {
                    //TODO: !? more arithmetic support for infinities (?)
                    //return Expression.INFINITY;
                    throw new RangeError("NotSupportedError");
                }
                if (x.compareTo(Expression.ONE) === 0) {
                    return Expression.ONE;
                }
                if (x.compareTo(Expression.ONE.negate()) > 0) {
                    return Expression.ZERO;
                }
                throw new RangeError("NotSupportedError");
            }
            var tmp = Expression.getComplexNumberParts(x);
            if (Expression.isReal(tmp.real) && Expression.isReal(tmp.imaginary)) {
                var rhorho = tmp.real._pow(2).add(tmp.imaginary._pow(2));
                if (rhorho.compareTo(Expression.ONE) < 0) {
                    return Expression.ZERO;
                }
            }
        }

        if (y instanceof Expression.Symbol && (y.symbol === "t" || y.symbol === "T")) {
            if (Expression.has(x, MatrixSymbol) || Expression.has(x, Expression.Matrix)) { //TODO: fix
                return x.transpose();
            }
        }
        if (y instanceof Expression.Multiplication && y.a instanceof Expression.Integer && y.b instanceof Expression.Symbol && (y.b.symbol === "t" || y.b.symbol === "T")) {
            if (Expression.has(x, MatrixSymbol) || Expression.has(x, Expression.Matrix)) { //TODO: fix
                return x.pow(y.a).transpose();
            }
        }

        //!
        if (y instanceof Division && y.a instanceof Integer && y.b instanceof Integer && x !== Expression.E && !(x instanceof Expression.Symbol) && !Expression.has(x, Expression.Symbol)) {
            if (typeof hit === "function") {
                hit({
                    powExpression: y.toString()
                });
            }
            var n = y.b.toNumber();
            //if (n >= 2 && n <= Number.MAX_SAFE_INTEGER) {//TODO:
            var q = y.a.truncatingDivide(y.b);
            var r = y.a.subtract(q.multiply(y.b));
            if (q.equals(Expression.ZERO)) { // to avoid multiplication event
                return x.pow(r)._nthRoot(n);
            }
            return x.pow(q).multiply(x.pow(r)._nthRoot(n));
            //}
        }
        //!

        if (x instanceof Expression.Integer && y === Expression.CIRCLE) {
            return new Expression.Degrees(x);
        }

        //!new 2017-05-08
        if (enableEX) {
            if (x === Expression.E || (enable2X && x instanceof Integer && x.compareTo(Expression.ONE) > 0 && integerPrimeFactor(x).compareTo(x) === 0)) {
                var isValid = function(y) {
                    if (y instanceof Expression.Symbol) {
                        return true;
                    }
                    if (y instanceof Addition) {
                        return isValid(y.a) && isValid(y.b);
                    }
                    if ((y instanceof Integer || y instanceof NthRoot) && (x === Expression.E || (x instanceof Integer && y instanceof NthRoot))) { //TODO: fix
                        return true;
                    }
                    if (y instanceof Multiplication || y instanceof Exponentiation) {
                        for (var iteratorf = y.factors()[globalThis.Symbol.iterator](), f = iteratorf.next().value; f != null; f = iteratorf.next().value) {
                            var b = getBase(f);
                            if (!(b instanceof Integer || b instanceof NthRoot || b instanceof Expression.Symbol)) {
                                if (!isValid(b)) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    }
                    if ((x === Expression.E || x instanceof Integer && x.compareTo(Expression.ONE) > 0) && y instanceof Division && y.b instanceof Integer) { //!new 2019-08-08
                        return isValid(y.a); //?
                    }
                    return false;
                };
                if (y.getNumerator() instanceof Addition && (y.getNumerator().a.isNegative() || y.getNumerator().b.isNegative())) { // e**(x-y)
                    return Expression.ONE.divide(x.pow(y.getNumerator().a.negate().divide(y.getDenominator())).divide(x.pow(y.getNumerator().b.divide(y.getDenominator()))));
                }
                if (isValid(y)) {
                    if (y.isNegative()) {
                        return Expression.ONE.divide(new Expression.Exponentiation(x, y.negate()));
                    }
                    //!new
                    if (y instanceof Expression.ExpressionWithPolynomialRoot) {
                        return x.pow(y.upgrade());
                    }
                    return new Expression.Exponentiation(x, y);
                }
            }
            if (enable2X && x instanceof Integer && x.compareTo(Expression.ONE) > 0) {
                if (y instanceof Addition && (y.a instanceof Integer || y.b instanceof Integer)) {
                    return x.pow(y.a).multiply(x.pow(y.b));
                }
                var xf = integerPrimeFactor(x);
                if (xf.equals(x)) {
                    if (y instanceof Division && y.b instanceof Integer) {
                        var n = y.b.toNumber();
                        if (n >= 2 && n <= Number.MAX_SAFE_INTEGER) {
                            return x.pow(y.a)._nthRoot(n);
                        }
                    }
                    //!new 2020-18-01
                    if (y instanceof Division && isIntegerOrN(y.a) && isIntegerOrN(y.b)) {
                        if (x.compareTo(Expression.ONE) > 0) {
                            return new Expression.Exponentiation(x, y); //?
                        }
                    }
                    //!
                } else {
                    if (!Expression.has(y, Expression.Logarithm)) { //TODO: ?
                        var ctz = primeFactor._countTrailingZeros(x.toBigInt(), xf.toBigInt());
                        return xf.pow(y.multiply(Integer.fromNumber(ctz))).multiply(x.divide(xf._pow(ctz)).pow(y));
                    }
                }
            }
        }
        //!

        if (enableEX) {
            //TODO: - ?
            if (x instanceof Integer && x.equals(Expression.ONE)) {
                return Expression.ONE;
            }
            if (x instanceof Division || x instanceof Multiplication && (y.getDenominator().equals(Expression.ONE) || isPositive(x.a) || isPositive(x.b))) {
                if (x instanceof Division) {
                    return x.a.pow(y).divide(x.b.pow(y));
                }
                if (enable2X) {
                    if (x instanceof Multiplication) {
                        return x.a.pow(y).multiply(x.b.pow(y));
                    }
                }
            }
        }

        var yn = y.getNumerator();
        var yd = y.getDenominator();
        if (x === Expression.E && yn instanceof Multiplication && yn.a instanceof Expression.Complex && yn.a.real.equals(Expression.ZERO) && yn.b instanceof Expression.Symbol) {
            var t = y.multiply(Expression.I.negate());
            return t.cos().add(Expression.I.multiply(t.sin()));
        }
        if (x === Expression.E && getConstant(yn) instanceof Expression.Complex && yd instanceof Expression.Integer) {
            var c = getConstant(yn);
            if (c.real.equals(Expression.ZERO)) {
                var t = y.multiply(Expression.I.negate());
                t = Expression.has(y, Expression.Symbol) ? t : new Expression.Radians(t);
                return t.cos().add(Expression.I.multiply(t.sin()));
            }
            return x.pow(c.real.divide(yd)).multiply(x.pow(c.imaginary.multiply(Expression.I).multiply(yn.divide(c)).divide(yd)));
        }
        if (x === Expression.E && yn instanceof Expression.Addition && yd instanceof Expression.Integer) {
            return x.pow(yn.a.divide(yd)).multiply(x.pow(yn.b.divide(yd)));
        }

        //TODO:
        if (x instanceof Expression.Matrix && (isIntegerOrN(y) || y === Expression.INFINITY)) {
            if (!x.matrix.isSquare()) {
                throw new RangeError("NonSquareMatrixException");
            }
            var an = matrixInN(x.matrix, y);
            if (an != undefined) {
                //?
                var D = x.matrix.map(function(e, i, j) {
                    return i === j ? e : Expression.ZERO;
                });
                var N = x.matrix.subtract(D);
                if (x.matrix.isDiagonal()) {
                    //  if (Expression.callback != undefined) {
                    //    Expression.callback(new Expression.Event("diagonal-matrix-pow", x));
                    //  }
                    //} else if (x.matrix.isJordanMatrix()) {
                    //  if (Expression.callback != undefined) {
                    //    Expression.callback(new Expression.Event("Jordan-matrix-pow", x));
                    //  }
                } else if (N.isNilpotent() && D.multiply(N).eql(N.multiply(D))) {
                    if (Expression.callback != undefined) {
                        Expression.callback(new Expression.Event("DpN-matrix-pow", x));
                    }
                }

                return an;
            }

            //! 2018-08-26
            if (true) {
                var eigenvalues = Expression.getEigenvalues(x.matrix);
                if (eigenvalues.length === x.matrix.cols()) {
                    var eigenvectors = Expression.getEigenvectors(x.matrix, eigenvalues);
                    if (eigenvectors.filter(function(v) {
                            return v != null;
                        }).length === x.matrix.cols()) {
                        var tmp = Expression.diagonalize(x.matrix, eigenvalues, eigenvectors);
                        var L = tmp.L;
                        var SL = matrixInN(L, y);
                        if (SL != undefined) {
                            if (Expression.callback != undefined) {
                                Expression.callback(new Expression.Event("pow-using-diagonalization", x));
                            }
                            if (Expression.callback != undefined) {
                                //TODO more details (A=P*D*P^-function (1) { return A^n=P*D*P^-1 * ... * P*D*P^-1=P*D^n*P^1; }
                                Expression.callback(new Expression.Event("diagonalize", x));
                            }
                            return new Expression.Matrix(tmp.T).multiply(SL).multiply(new Expression.Matrix(tmp.T_INVERSED));
                        }
                    } else {
                        var tmp = Expression.getFormaDeJordan(x.matrix, eigenvalues);
                        var JN = matrixInN(tmp.J, y);
                        if (JN != undefined) {
                            if (Expression.callback != undefined) {
                                Expression.callback(new Expression.Event("pow-using-Jordan-normal-form", x));
                            }
                            if (Expression.callback != undefined) {
                                //TODO more details (A=P*D*P^-function (1) { return A^n=P*D*P^-1 * ... * P*D*P^-1=P*D^n*P^1; }
                                Expression.callback(new Expression.Event("Jordan-decomposition", x));
                            }
                            //TODO: details !!!
                            return new Expression.Matrix(tmp.P).multiply(JN).multiply(new Expression.Matrix(tmp.P_INVERSED));
                        }
                    }
                }
            }
            //!
        }

        if (Expression.ExponentiationOfMinusOne != null) {
            if (x instanceof Integer && x.compareTo(Expression.ZERO) < 0 || x.equals(Expression.E.negate())) {
                if (y instanceof Expression.Symbol && (y.symbol === "n" || y.symbol === "k")) {
                    return new Expression.ExponentiationOfMinusOne(Expression.ONE.negate(), y).multiply(x.negate().pow(y));
                }
                if (y instanceof Addition && y.a instanceof Expression.Symbol && (y.a.symbol === "n" || y.a.symbol === "k") && y.b instanceof Integer) {
                    return new Expression.ExponentiationOfMinusOne(Expression.ONE.negate(), y.a).multiply(Expression.ONE.negate().pow(y.b)).multiply(x.negate().pow(y));
                }
                if (y instanceof Multiplication) {
                    return x.pow(y.a).pow(y.b);
                }
                if (y instanceof Addition && y.b instanceof Integer) {
                    return x.pow(y.a).multiply(x.pow(y.b));
                }
            }
        }

        if (Expression.ExponentiationOfImaginaryUnit != null) {
            if (x instanceof Expression.Complex && x.equals(Expression.I.negate())) {
                return Expression.ONE.negate().pow(y).multiply(x.negate().pow(y));
            }
            if (x instanceof Expression.Complex && (x.equals(Expression.I) || x.real.compareTo(Expression.ZERO) > 0 && x.primeFactor().equals(x))) { //TODO: -i, other complex numbers - ?
                if (y instanceof Expression.Symbol && (y.symbol === "n" || y.symbol === "k")) {
                    return new Expression.ExponentiationOfImaginaryUnit(x, y);
                }
                if (y instanceof Addition && y.a instanceof Expression.Symbol && (y.a.symbol === "n" || y.a.symbol === "k") && y.b instanceof Integer) {
                    //var t = x.pow(y.b);
                    //return new Expression.ExponentiationOfImaginaryUnit(x, t instanceof Expression.Complex ? y.a.add(Expression.ONE) : y.a).multiply(t instanceof Expression.Complex ? t.divide(x) : t);
                    return x.pow(y.a).multiply(x.pow(y.b));
                }
                if (y instanceof Multiplication) {
                    return x.pow(y.a).pow(y.b);
                }
                if (y instanceof Addition && y.b instanceof Integer) {
                    return x.pow(y.a).multiply(x.pow(y.b));
                }
            }
            if (x instanceof Expression.Complex && x.real.equals(Expression.ZERO) && !x.imaginary.equals(Expression.ONE)) { //TODO: -i, other complex numbers - ?
                if (y instanceof Expression.Symbol && (y.symbol === "n" || y.symbol === "k")) {
                    return x.imaginary.pow(y).multiply(Expression.I.pow(y));
                }
                if (y instanceof Multiplication) {
                    return x.pow(y.a).pow(y.b);
                }
                if (y instanceof Addition) {
                    return x.pow(y.a).multiply(x.pow(y.b));
                }
            }
            if (x instanceof Expression.Complex) { //TODO: ?
                var pf = x.primeFactor();
                return x.divide(pf).pow(y).multiply(pf.pow(y)); //TODO: test ?
            }

            //TODO:
            if (x instanceof Expression.Integer && y instanceof Division && y.getDenominator() instanceof Integer && y.getNumerator() instanceof Expression.Symbol &&
                (y.getNumerator().symbol === "n" || y.getNumerator().symbol === "k")) {
                return x.pow(Expression.ONE.divide(y.getDenominator())).pow(y.getNumerator());
            }
            //?
            if (x instanceof Expression.Integer && y instanceof Division && y.getDenominator() instanceof Integer && y.getNumerator() instanceof Addition) {
                return x.pow(Expression.ONE.divide(y.getDenominator())).pow(y.getNumerator());
            }
        }

        if (x === Expression.E && y instanceof Expression.Matrix) {
            if (!y.matrix.isSquare()) {
                throw new RangeError("NonSquareMatrixException");
            }
            // https://en.wikipedia.org/wiki/Matrix_exponential#Using_the_Jordan_canonical_form
            var eigenvalues = Expression.getEigenvalues(y.matrix);
            if (eigenvalues.length === y.matrix.cols()) {
                var tmp = Expression.getFormaDeJordan(y.matrix, eigenvalues);
                // exp(A) = exp(P*J*P^-1) = P*exp(D + N)*P^-1 = P*exp(D)*exp(N)*P^-1
                var D = tmp.J.map(function(e, i, j) {
                    return i === j ? e : Expression.ZERO;
                });
                var N = tmp.J.map(function(e, i, j) {
                    return i !== j ? e : Expression.ZERO;
                });
                var exp = function(N) {
                    // https://en.wikipedia.org/wiki/Matrix_exponential#Nilpotent_case
                    var z = Matrix.Zero(N.cols(), N.cols());
                    var s = z;
                    var p = Matrix.I(N.cols());
                    var k = 0;
                    var f = 1;
                    while (!p.eql(z)) {
                        var summand = p.scale(Expression.ONE.divide(Integer.fromNumber(f)));
                        s = s.add(summand);
                        p = p.multiply(N);
                        k += 1;
                        f *= k;
                    }
                    return s;
                };
                if (Expression.callback != undefined) {
                    Expression.callback(new Expression.Event("exponential-using-Jordan-canonical-form", y));
                }
                //if (Expression.callback != undefined) {
                //  Expression.callback(new Expression.Event("Jordan-decomposition", y));
                //}
                return new Expression.Matrix(tmp.P.multiply(D.map(function(e, i, j) {
                    return i === j ? Expression.E.pow(e) : Expression.ZERO;
                }).multiply(exp(N))).multiply(tmp.P_INVERSED));
            }
        }

        //!2019-04-22
        if (x instanceof NthRoot && x.a instanceof Integer) {
            return x.a.pow(y.divide(Expression.Integer.fromNumber(x.n)));
        }

        if (enableEC) {
            if (x === Expression.E && isConstant(y) && !has(y, Expression.Complex) && !has(y, Expression.Logarithm)) {
                return new Expression.Exponentiation(x, y);
            }
            if ((x instanceof Expression.Symbol || Expression.has(x, Expression.Symbol)) && y instanceof Expression.Division && y.getDenominator() instanceof Integer) {
                return x.pow(y.getNumerator())._nthRoot(y.getDenominator().toNumber());
            }
            if (x instanceof Expression.Symbol && y instanceof Expression.Division && isIntegerOrN(y.getNumerator()) && isIntegerOrN(y.getDenominator())) {
                return new Expression.Exponentiation(x, y);
            }
            if (x === Expression.E && y instanceof Expression.Addition) {
                return x.pow(y.a).multiply(x.pow(y.b));
            }
            if (x instanceof Exponentiation && getBase(x) === Expression.E) { //?
                return getBase(x).pow(getExponent(x).multiply(y));
            }
            if (isGoodPolynomial(x) && y instanceof Expression.Division && isIntegerOrN(y.getNumerator()) && isIntegerOrN(y.getDenominator())) {
                return new Expression.Exponentiation(x, y);
            }
        }

        if (x instanceof Expression.Matrix && y instanceof Expression.Addition) {
            return x.pow(y.a).multiply(x.pow(y.b));
        }
        if (x instanceof Expression.Matrix && y instanceof Expression.Multiplication && y.a instanceof Expression.Integer) {
            return x.pow(y.a).pow(y.b);
        }
        if (x instanceof Expression.Matrix && y instanceof Expression.Division) {
            //?
            if (y.getNumerator().equals(Expression.ONE) && y.getDenominator() instanceof Expression.Symbol && (y.getDenominator().symbol === "n" || y.getDenominator().symbol === "k")) {
                return x._nthRoot(y.getDenominator()); //TODO: ?
            }
            if (isIntegerOrN(y.getNumerator()) && isIntegerOrN(y.getDenominator())) {
                return x.pow(y.getNumerator()).pow(Expression.ONE.divide(y.getDenominator()));
            }
        }

        //?
        if (y instanceof Expression.Symbol && (y.symbol === "n" || y.symbol === "k")) {
            var qi = QuadraticInteger.toQuadraticInteger(x); //?
            if (qi != null && /*qi.equals(qi.primeFactor()) &&*/ Number(qi.a.toString()) > 0 && qi.D > 0 && (qi.isValid() || true)) {
                if (Number(qi.b.toString()) > 0) {
                    return new Expression.ExponentiationOfQuadraticInteger(x, y);
                }
                if (Number(qi.b.toString()) < 0) {
                    var xc = qi.conjugate().toExpression();
                    return x.multiply(xc).pow(y).divide(xc.pow(y));
                }
            }
            if (qi != null && Number(qi.a.toString()) < 0) {
                return Expression.ONE.negate().pow(y).multiply(qi.toExpression().negate().pow(y));
            }
            /*
            if (qi != null) {
              if (x._nthRoot(2) instanceof Expression.Addition) {//TODO: remove
                var t = x._nthRoot(2).pow(y);
                return new Expression.ExponentiationOfQuadraticInteger(x._nthRoot(2), y.multiply(Expression.TWO));
              }
            }
            */
        }
        /*
        if (y instanceof Multiplication && y.a instanceof Integer && y.b instanceof Expression.Symbol) {
          return x.pow(y.a).pow(y.b);
        }
        */
        //?

        if (enableAN) {
            if (isIntegerOrN(y)) {
                if (y instanceof Addition) {
                    for (var iterators = y.summands()[globalThis.Symbol.iterator](), s = iterators.next().value; s != null; s = iterators.next().value) {
                        if (s.isNegative()) {
                            return x.pow(y.subtract(s)).divide(x.pow(s.negate()));
                        }
                    }
                }
                if (y.isNegative()) {
                    return Expression.ONE.divide(x.pow(y.negate()));
                }
                // (1+sqrt(2))**(2n) - ((1+sqrt(2))**2)**(n)
                if (Expression.isConstant(x) && !getConstant(y).equals(Expression.ONE)) { //?
                    return x.pow(getConstant(y)).pow(y.divide(getConstant(y)));
                }
                var goodX = x instanceof Expression.Symbol || x instanceof Expression.Addition && !(Expression.has(x, Expression.Sin) || Expression.has(x, Expression.Cos));
                if (goodX) {
                    return new Expression.Exponentiation(x, y);
                }
            }
            if (x instanceof Exponentiation && getBase(x) instanceof Integer && getBase(x).compareTo(Expression.ONE) > 0 && isIntegerOrN(getExponent(x).getNumerator()) && isIntegerOrN(getExponent(x).getDenominator())) { //TODO: FIX
                return getBase(x).pow(getExponent(x).multiply(y));
            }
            if (x instanceof Exponentiation && isGoodPolynomial(getBase(x)) &&
                isIntegerOrN(getExponent(x)) &&
                isIntegerOrN(y)) { //TODO: FIX
                return getBase(x).pow(getExponent(x).multiply(y));
            }
            if (x instanceof Exponentiation && isGoodPolynomial(getBase(x)) &&
                isIntegerOrN(getExponent(x).inverse()) &&
                isIntegerOrN(y.inverse())) { //TODO: FIX
                return getBase(x).pow(getExponent(x).multiply(y));
            }
        }

        if (Expression.has(x, Expression.Sin) || Expression.has(x, Expression.Cos)) {
            return Expression._replaceBySinCos(Expression._replaceSinCos(x).pow(y));
        }

        if (x === Expression.E && y instanceof Expression.Logarithm) {
            return y.a;
        }
        if (x === Expression.E && y instanceof Expression.Multiplication && y.a instanceof Integer && y.b instanceof Expression.Logarithm) {
            return x.pow(y.b).pow(y.a);
        }
        if (x === Expression.E && y instanceof Expression.Multiplication && y.a instanceof Expression.Symbol && y.b instanceof Expression.Logarithm) {
            return x.pow(y.b).pow(y.a);
        }
        if (x instanceof Expression.Integer && Expression.has(y, Expression.Logarithm)) { //?
            return Expression.E.pow(x.logarithm().multiply(y));
        }

        //!new 2020-12-11
        if (x instanceof Exponentiation && getBase(x) instanceof Integer && getBase(x).compareTo(Expression.TWO) >= 0 && isIntegerOrN(y)) { // (3^x)^k
            // https://en.wikipedia.org/wiki/Exponentiation#Identities_and_properties
            //TODO: positive real base check - ?
            return getBase(x).pow(getExponent(x).multiply(y));
        }
        //!

        //!new 2022-07-26
        //TODO: more cases
        if (x === Expression.E && y instanceof Expression.ComplexConjugate && y.a instanceof Expression.Symbol) {
            return new Expression.Exponentiation(x, y);
        }

        throw new RangeError("NotSupportedError");
    };

    // compare two expression, which are factors (multiplicaiton operands) of terms (addition operands)
    Expression.prototype.compare4Addition = function(y) {
        var x = this;
        if (x instanceof Integer && y instanceof Integer) {
            return x.compareTo(y);
        }
        if (x instanceof Expression.Symbol && y instanceof Integer) {
            return +1;
        }
        if (x instanceof Integer && y instanceof Expression.Symbol) {
            return -1;
        }
        if (x instanceof Expression.Symbol && y instanceof Expression.Symbol) {
            return x.symbol < y.symbol ? -1 : (y.symbol < x.symbol ? +1 : 0);
        }
        //!
        if (x instanceof Expression.Matrix && y instanceof MatrixSymbol) {
            return +1;
        }
        if (x instanceof MatrixSymbol && y instanceof Expression.Matrix) {
            return -1;
        }
        if (x instanceof Expression.Matrix && y instanceof Expression.Matrix) {
            /*
            if (x.matrix.rows() === y.matrix.rows() &&
                x.matrix.cols() === y.matrix.cols()) {
              var rows = x.matrix.rows();
              var cols = x.matrix.cols();
              for (var i = 0; i < rows; i += 1) {
                for (var j = 0; j < cols; j += 1) {
                  var c = x.matrix.e(i, j).compare4Addition(y.matrix.e(i, j));
                  if (c !== 0) {
                    return c;
                  }
                }
              }
            }
            */
            return 0;
        }

        //!new 2016-12-17
        //NOTE: the `x instanceof Addition || y instanceof Addition` should be used before `x instanceof Multiplication || y instanceof Multiplication`
        if (x instanceof Addition || y instanceof Addition) {
            return Addition.compare4Addition(x, y);
        }

        //!new 2016-10-09
        if (x instanceof Multiplication || y instanceof Multiplication) {
            return Multiplication.compare4Addition(x, y);
        }


        //!new 2018-10-11
        if (x instanceof Integer && y instanceof Expression.Function) {
            return -1;
        }

        //!new 2018-11-12
        if (x instanceof Division && y instanceof Division) {
            return x.a.compare4Addition(y.a) || x.b.compare4Addition(y.b); //?
        }
        if (x instanceof Expression && y instanceof Division) {
            return +1; //?
        }
        if (x instanceof Division && y instanceof Expression) {
            return -1; //?
        }

        if (x instanceof Expression.Matrix) {
            return -1;
        }
        if (y instanceof Expression.Matrix) {
            return +1;
        }

        //!2019-02-18
        if (x instanceof Integer && y instanceof Expression.Complex) {
            return -1; //?
        }
        if (x instanceof Expression.Complex && y instanceof Integer) {
            return +1; //?
        }
        //!

        if (x.equals(y)) {
            return 0; //!
        }

        if (x instanceof Expression.Exponentiation || y instanceof Expression.Exponentiation) {
            return getBase(x).compare4Addition(getBase(y)) || (0 - getExponent(x).compare4Addition(getExponent(y)));
        }

        //!new 2017-02-10
        if (y instanceof Expression.Symbol) {
            return -1;
        }

        //!
        throw new RangeError();
    };

    var compare = function(x, y) {
        return x.compare4Addition(y);
    };

    var compare4Multiplication = function(x, y) {
        //TODO: Exponentiation + Exponentiation, Exponentiation + Symbol, Symbol + Exponentiation
        return x.compare4Multiplication(y);
    };

    var getBase = function(x) {
        //TODO: ?
        //if (x instanceof NthRoot) {
        //  return x.a;
        //}
        return x instanceof Exponentiation ? x.a : x;
    };
    var getExponent = function(x) {
        //TODO: ?
        //if (x instanceof NthRoot) {
        //  return Expression.Integer.fromNumber(x.n);
        //}
        return x instanceof Exponentiation ? x.b : Expression.ONE;
    };

    // use getContent instead (?)
    var getConstant = function(e, allowExpressionPolynomialRoot) {
        allowExpressionPolynomialRoot = allowExpressionPolynomialRoot == undefined ? undefined : allowExpressionPolynomialRoot;

        if (e instanceof Integer) {
            return e;
        } else if (e instanceof Expression.Complex) {
            return e;
        } else if (e instanceof Expression.ExpressionPolynomialRoot) {
            if (allowExpressionPolynomialRoot) {
                return e;
            }
        } else if (e instanceof Multiplication) {
            var c = undefined;
            var x = e;
            for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
                var t = getConstant(y, allowExpressionPolynomialRoot);
                c = c == undefined ? t : t.multiply(c);
            }
            if (c != undefined) {
                return c;
            }
        } else if (e instanceof Addition) { // -5*x+15
            var c = undefined;
            for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
                var t = getConstant(x, allowExpressionPolynomialRoot);
                //c = c == undefined ? t : integerGCD(t, c);
                c = c == undefined ? t : complexGCD(t, c);
            }
            if (c != undefined) {
                return c;
            }
        }
        return Expression.ONE;
    };
    var getTerm = function(x, flag0) {
        // TODO: fix performance ?
        if (x instanceof Integer) {
            return undefined;
        } else if (x instanceof Expression.Complex) {
            return undefined;
        } else if (x instanceof Expression.ExpressionPolynomialRoot) {
            if (flag0) {
                return undefined;
            }
        } else if (x instanceof Multiplication) {
            var terms = [];
            for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
                var t = getTerm(y, flag0);
                if (t != undefined) {
                    terms.push(t);
                }
            }
            var result = undefined;
            for (var j = terms.length - 1; j >= 0; j -= 1) {
                result = result == undefined ? terms[j] : new Multiplication(result, terms[j]);
            }
            return result;
        } else if (x instanceof Addition) {
            return x.divide(getConstant(x));
        }
        return x;
    };

    Expression.getConstant = getConstant;

    var multiplyByInteger = function(x, y) {
        if (x.compareTo(Expression.ZERO) === 0) {
            return x;
        }
        if (x.compareTo(Expression.ONE) === 0) {
            return y;
        }
        return new Multiplication(x, y);
    };

    Expression.prototype.multiplyExpression = function(x) {
        var y = this;

        if (x instanceof Expression && y instanceof Multiplication) {
            return x.multiply(y.a).multiply(y.b);
        }
        if (x instanceof Multiplication && y instanceof Expression) {
            var c = compare4Multiplication2(x.b, y);
            if (c === 0) {
                return x.a.multiply(x.b.multiply(y));
            }
            return c > 0 ? x.a.multiply(y).multiply(x.b) : new Multiplication(x, y);
        }

        //!
        /*
        if (x instanceof IdentityMatrix && y instanceof MatrixSymbol) {
          return y;
        }
        if (y instanceof IdentityMatrix && x instanceof MatrixSymbol) {
          return x;
        }
        */
        //!
        // rest

        var c = 0;
        if (x instanceof Integer && y instanceof Expression.Symbol) {
            return multiplyByInteger(x, y);
        }
        if (x instanceof Expression.Symbol && y instanceof Integer) {
            return multiplyByInteger(y, x);
        }
        if (x instanceof Expression.Symbol && y instanceof Expression.Symbol) {
            c = compare4Multiplication(x, y);
            if (c === 0) {
                return x.pow(Expression.TWO);
            }
            return c > 0 ? new Multiplication(y, x) : new Multiplication(x, y);
        }
        if (x instanceof Integer && y instanceof Exponentiation) {
            return multiplyByInteger(x, y);
        }
        if (x instanceof Exponentiation && y instanceof Integer) {
            return multiplyByInteger(y, x);
        }
        //!new 2022-06-20
        //TODO: FIX
        if (getBase(x) instanceof Expression.MatrixSymbol || getBase(y) instanceof Expression.MatrixSymbol) {
            c = compare4Multiplication(getBase(x), getBase(y));
            if (c === 0) {
                if (getExponent(x).equals(new Expression.Symbol("T")) || getExponent(y).equals(new Expression.Symbol("T"))) {
                    return new Multiplication(x, y);
                }
            }
        }
        if (x instanceof Exponentiation && y instanceof Expression.Symbol) {
            c = compare4Multiplication(getBase(x), y);
            if (c === 0) {
                return y.pow(getExponent(x).add(Expression.ONE));
            }
            return c > 0 ? new Multiplication(y, x) : new Multiplication(x, y);
        }
        if (x instanceof Expression.Symbol && y instanceof Exponentiation) {
            c = compare4Multiplication(x, getBase(y));
            if (c === 0) {
                return x.pow(getExponent(y).add(Expression.ONE));
            }
            return c > 0 ? new Multiplication(y, x) : new Multiplication(x, y);
        }
        if (x instanceof Exponentiation && y instanceof Exponentiation) {
            c = compare4Multiplication(getBase(x), getBase(y));
            if (c === 0) {
                return getBase(x).pow(getExponent(x).add(getExponent(y)));
            }
            return c > 0 ? new Multiplication(y, x) : new Multiplication(x, y);
        }

        if (x instanceof SquareRoot && y instanceof SquareRoot) {
            if (x.a instanceof Integer && y.a instanceof Exponentiation) { //TODO: fix
                return new Multiplication(x, y);
            }
            // optimization:
            var g = x.a.gcd(y.a);
            return g.multiply(x.a.divide(g).multiply(y.a.divide(g)).squareRoot());
            //return x.a.multiply(y.a).squareRoot();
        }
        if (x instanceof NthRoot && x.n === 3 && y instanceof NthRoot && y.n === 3) {
            // optimization:
            //var g = x.a.gcd(y.a);
            //return g.pow(2/3).multiply(x.a.divide(g).multiply(y.a.divide(g))._nthRoot(3));
            return x.a.multiply(y.a)._nthRoot(3);
        }
        if (x instanceof NthRoot && y instanceof NthRoot) {
            //if (x.n === y.n) {
            //  return x.a.multiply(y.a)._nthRoot(x.n);
            //}
            //!2021-02-02 - hack
            if (x.a instanceof Integer && !(y.a instanceof Integer) && x.n < y.n && getVariable(y.a)._pow(2).gcd(x.a).equals(x.a)) {
                if (Expression.isConstant(x) && Expression.isConstant(y)) {
                    return y.multiply(x);
                }
            }
            //!
            var ng = Math.gcd(x.n, y.n);
            //TODO: remove check for integers (?)
            if (!(x.a instanceof Integer) && (!(y.a instanceof Integer) || !x.a._pow(2).gcd(y.a).equals(Expression.ONE) || getVariable(x.a)._pow(2).gcd(y.a).equals(getVariable(x.a)._pow(2))) || !x.a.gcd(y.a).equals(Expression.ONE)) {
                var v = Expression.pow(x.a, y.n / ng).multiply(Expression.pow(y.a, x.n / ng));
                var nn = x.n / ng * y.n;
                return v._nthRoot(nn);
            }
            if (!(x.a instanceof Integer) && x.n === 2 && y.a instanceof Integer && y.n === 4 && !(getConstant(x.a.getNumerator()).multiply(y.a)._nthRoot(y.n) instanceof NthRoot)) { //HACK
                return x.a.multiply(y.a._nthRoot(2))._nthRoot(2);
            }
            return x.n < y.n ? new Multiplication(x, y) : (x.n > y.n ? new Multiplication(y, x) : x.a.multiply(y.a)._nthRoot(x.n));
        }

        //!
        if (x instanceof MatrixSymbol && y instanceof Expression.Matrix) {
            return new Multiplication(x, y);
        }
        if (x instanceof Expression.Matrix && y instanceof MatrixSymbol) {
            return new Multiplication(x, y);
        }
        if (has(x, MatrixSymbol) && y instanceof Expression.Matrix) { // X^2*{{1,2},{3,4}}
            return new Multiplication(x, y);
        }
        if (x instanceof Expression.Matrix && has(y, MatrixSymbol)) { // {{1,2},{3,4}}*X^2
            return new Multiplication(x, y);
        }

        //!
        //throw new RangeError();
        if (x instanceof Integer && y instanceof Expression) {
            if (x.compareTo(Expression.ZERO) === 0) {
                return x;
            }
            if (x.compareTo(Expression.ONE) === 0) {
                return y;
            }
        }
        if (x instanceof Expression && y instanceof Integer) {
            if (y.compareTo(Expression.ZERO) === 0) {
                return y;
            }
            if (y.compareTo(Expression.ONE) === 0) {
                return x;
            }
        }

        /*
            // TODO: remove
            if (x instanceof Expression.Complex && y instanceof Expression.ExponentiationOfImaginaryUnit) {
              //!hack
              //TODO: remove
              if (x.real.equals(Expression.ZERO)) {
                if (!x.equals(Expression.I)) {
                //if (x.primeFactor().equals(y.a)) {//TODO: fix
                if (y.a.equals(Expression.I)) {//TODO: fix
                return x.imaginary.multiply(y.multiply(Expression.I));
                }
                //}
                }
              } else {
                if (getBase(y).equals(Expression.I)) {//TODO: remove
                  return x.imaginary.multiply(Expression.I).multiply(y).add(x.real.multiply(y));
                }
              }
            }
            if (x instanceof Expression.ExponentiationOfImaginaryUnit && y instanceof Expression.Complex) {
              //!hack
              //TODO: remove
              if (y.real.equals(Expression.ZERO)) {
                if (!y.equals(Expression.I)) {
                return y.imaginary.multiply(x.multiply(Expression.I));
                }
              } else {
                if (getBase(x).equals(Expression.I)) {//TODO: remove
                return y.imaginary.multiply(Expression.I).multiply(x).add(y.real.multiply(x));
                }
              }
            }
        */

        //var cmp = x instanceof Expression.Complex && y instanceof Expression.ExponentiationOfImaginaryUnit && !x.equals(getBase(y)) ? -1 : (x instanceof Expression.ExponentiationOfImaginaryUnit && y instanceof Expression.Complex && !y.equals(getBase(x)) ? +1 : compare4Multiplication(getBase(x), getBase(y)));
        var cmp = x instanceof Expression.Complex && y instanceof Expression.ExponentiationOfImaginaryUnit ? -1 : (x instanceof Expression.ExponentiationOfImaginaryUnit && y instanceof Expression.Complex ? +1 : compare4Multiplication(getBase(x), getBase(y)));
        if (cmp === 0) {
            return getBase(x).pow(getExponent(x).add(getExponent(y)));
        }
        if (cmp < 0) {
            return new Multiplication(x, y);
        }
        if (cmp > 0) {
            return new Multiplication(y, x);
        }

    };

    function Iterator() {}
    if ("\v" !== "v") {
        Object.defineProperty(Iterator.prototype, "done", {
            get: function() {
                return this.value == null;
            }
        });
    }
    Iterator.prototype[globalThis.Symbol.iterator] = function() {
        return this;
    };

    function TermFactorsIterator(e) {
        this.value = undefined;
        this.e = e;
    }
    TermFactorsIterator.prototype = Object.create(Iterator.prototype);
    TermFactorsIterator.prototype.next = function() {
        this.value = this.e instanceof Multiplication ? this.e.b : (this.e instanceof Integer || this.e instanceof Expression.Complex || this.e instanceof Expression.ExpressionPolynomialRoot ? null : this.e);
        this.e = this.e instanceof Multiplication ? this.e.a : undefined;
        return this;
    };

    function termFactors(e) {
        return new TermFactorsIterator(e);
    }

    var compare4Addition = function(x, y) {
        // undefined | Symbol | Exponentiation | Multiplication
        var i = termFactors(x);
        var j = termFactors(y);
        var a = i.next().value;
        var b = j.next().value;
        while (a != null && b != null) {

            //!
            // x^3*y^2, x^2*y^3
            var cmp = 0 - compare(getBase(a), getBase(b));
            if (cmp === 0) {
                cmp = compare(getExponent(a), getExponent(b));
            }
            if (cmp !== 0) {
                return cmp;
            }
            a = i.next().value;
            b = j.next().value;
        }
        //!new 2020-02-13
        if (a instanceof Expression.Matrix || b instanceof Expression.Matrix) {
            if (y instanceof Integer && x instanceof Multiplication) {
                return +1; //?
            }
            if (x instanceof Integer && y instanceof Multiplication) {
                return -1; //?
            }
            if (a != null && i.next().value != null) {
                return +1;
            }
            if (b != null && j.next().value != null) {
                return -1;
            }
            return 0;
        }
        //!
        return a != null ? +1 : (b != null ? -1 : 0);
    };

    var addSimilar = function(x, y) {
        if (x instanceof Expression.Matrix && y instanceof Expression.Matrix) {
            return x.add(y);
        }
        var c1 = getConstant(x); //TODO: remove (?)
        var c2 = getConstant(y);
        var i = termFactors(getTerm(x));
        var j = termFactors(getTerm(y));
        var a = i.next().value;
        var b = j.next().value;
        var result = Expression.ONE;
        var added = false;
        while (a != null || b != null) {
            var f = null;
            if (a instanceof Expression.Matrix &&
                a.matrix.isScalar() &&
                isScalar(a.matrix.e(0, 0)) && !a.matrix.e(0, 0).equals(Expression.ZERO) && //TODO: !?
                b instanceof Expression.Matrix &&
                b.matrix.isScalar() &&
                isScalar(b.matrix.e(0, 0)) && !b.matrix.e(0, 0).equals(Expression.ZERO) && //TODO: !?
                a.matrix.rows() === b.matrix.rows() && a.matrix.cols() === b.matrix.cols() &&
                !a.equals(b)) {
                var f = function(a, x) {
                    //return Expression._map(function (e) { return e.equals(a) ? a.matrix.divide(a.matrix.e(0, 0)) : e; }, a.matrix.e(0, 0).multiply(x));
                    return a.matrix.e(0, 0).multiply(x).multiply(a.inverse());
                };
                return addSimilar(f(a, x), f(b, y));
            } else if (!added && (a instanceof Expression.Matrix || b instanceof Expression.Matrix) && (a == null || b == null || !a.equals(b))) {
                added = true;
                f = (a == null ? c1 : a.multiply(c1)).add(b == null ? c2 : b.multiply(c2));
                c1 = Expression.ONE;
                c2 = Expression.ONE;
            } else {
                if (!a.equals(b)) {
                    //throw new TypeError();
                    return null;
                }
                f = a;
            }
            result = f.multiply(result); //!TODO: depends on the iteration order !!!
            a = i.next().value;
            b = j.next().value;
        }
        if (!added) {
            result = c1.add(c2).multiply(result);
        }
        return result;
    };

    Expression.getComplexNumberParts = function(e) {
        if (e instanceof Expression.Division) {
            var tmp = Expression.getComplexNumberParts(e.getNumerator());
            return {
                real: tmp.real.divide(e.getDenominator()),
                imaginary: tmp.imaginary.divide(e.getDenominator())
            };
        }
        if (!Expression.has(e, Expression.Complex)) {
            return {
                real: e,
                imaginary: Expression.ZERO
            };
        }
        var real = [];
        var imaginary = [];
        for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
            var c = undefined;
            for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
                if (c == undefined && y instanceof Expression.Complex) {
                    c = y;
                }
            }
            if (c == undefined) {
                real.push(x);
            } else if (c.real.equals(Expression.ZERO)) {
                imaginary.push(x.multiply(Expression.I.negate()));
            } else {
                var r = null;
                if (x !== c) {
                    for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
                        if (y !== c) {
                            r = r == null ? y : r.multiply(y);
                        }
                    }
                }
                if (r == null) {
                    //TODO: !?
                    real.push(c.real);
                    imaginary.push(c.imaginary);
                } else {
                    real.push(r.multiply(c.real));
                    imaginary.push(r.multiply(c.imaginary));
                }
            }
        }
        return {
            real: _sum(real),
            imaginary: _sum(imaginary)
        };
    };

    Expression.prototype.addExpression = function(x) {
        var y = this;
        if (x.equals(Expression.ZERO)) {
            return y;
        }
        if (y.equals(Expression.ZERO)) {
            return x;
        }

        //!2019-02-16
        if (x instanceof Multiplication && x.b instanceof IdentityMatrix) {
            var t = getIdentityMatrixCoefficient(y);
            if (t != null) {
                return x.a.add(t).multiply(x.b);
            }
        } else if (x instanceof IdentityMatrix) {
            var t = getIdentityMatrixCoefficient(y);
            if (t != null) {
                return Expression.ONE.add(t).multiply(x);
            }
        }
        if (y instanceof Multiplication && y.b instanceof IdentityMatrix) {
            var t = getIdentityMatrixCoefficient(x);
            if (t != null) {
                return t.add(y.a).multiply(y.b);
            }
        } else if (y instanceof IdentityMatrix) {
            var t = getIdentityMatrixCoefficient(x);
            if (t != null) {
                return t.add(Expression.ONE).multiply(y);
            }
        }
        //!2019-02-16

        //!new 2019-09-30
        /*
        if (x instanceof Expression.Addition && y instanceof Expression.Matrix) {//TODO:
          return x.a.add(x.b.add(y));
        }
        if (x instanceof Expression.Matrix && y instanceof Expression.Addition) {
          return x.add(y.a).add(y.b);
        }
        if (x instanceof Expression.Addition && y instanceof Expression.Addition) {
          if (x.b instanceof Expression.Matrix && y.b instanceof Expression.Matrix) {
            return x.a.add(x.b.add(y));
          }
        }
        */

        // rest

        //!new 2020-12-26
        if ( /*Expression.isConstant(x) && Expression.isConstant(y) && */
            (has2(x, Expression.Complex) || has2(y, Expression.Complex)) &&
            (has2(x, Expression.ExpressionPolynomialRoot) || has2(y, Expression.ExpressionPolynomialRoot))) {
            var tmp = Expression.getComplexNumberParts(x);
            var tmp1 = Expression.getComplexNumberParts(y);
            var re = tmp.real.add(tmp1.real);
            var im = tmp.imaginary.add(tmp1.imaginary);
            if (im.equals(Expression.ZERO)) {
                return re;
            }
            if (!(im instanceof Expression.Addition)) {
                if (re.equals(Expression.ZERO)) {
                    return im.multiply(Expression.I);
                }
                if (!has2(re, Expression.ExpressionPolynomialRoot) &&
                    !has2(im, Expression.ExpressionPolynomialRoot)) {
                    return re.add(im.multiply(Expression.I));
                }
                return new Expression.Addition(re, im.multiply(Expression.I));
            }
        }
        //!

        var i = x.summands();
        var j = y.summands();
        var a = i.next().value;
        var dontMove = 0;
        var b = j.next().value;
        var s = [];
        //a + b, compare4Addition("a", "b") > 0
        while (a != null && b != null) {
            var c = compare4Addition(a, b);
            if (c < 0) {
                s.push(a);
                a = i.next().value;
            } else if (c > 0) {
                s.push(b);
                b = j.next().value;
            } else {
                if (has2(a, Expression.Matrix) || has2(b, Expression.Matrix)) {
                    var last = addSimilar(a, b);
                    if (last != null) {
                        if (!last.equals(Expression.ZERO)) {
                            s.push(last);
                        }
                    } else {
                        //TODO: fix
                        s.push(a);
                        s.push(b);
                    }
                } else {
                    var constantA = getConstant(a, true);
                    var constantB = getConstant(b, true);
                    var termA = getTerm(a, true) || Expression.ONE;
                    var termB = getTerm(b, true) || Expression.ONE;
                    var constant = (termA.equals(termB) ? constantA : constantA.multiply(termA.divide(termB))).add(constantB);
                    var last = termB === Expression.ONE ? constant : (constant instanceof Expression.Addition ? new Expression.Multiplication(constant, termB) : constant.multiply(termB));
                    dontMove = 0;
                    if (!last.equals(Expression.ZERO)) {
                        if (Expression.has(last, Expression.ExpressionPolynomialRoot)) {
                            if (Expression.has(a, Expression.ExpressionPolynomialRoot)) {
                                a = last;
                                dontMove = 1;
                            } else {
                                b = last;
                                dontMove = 2;
                            }
                        } else {
                            s.push(last);
                        }
                    }
                }
                if (dontMove !== 1) {
                    a = i.next().value;
                }
                if (dontMove !== 2) {
                    b = j.next().value;
                }
            }
        }
        while (a != null) {
            s.push(a);
            a = i.next().value;
        }
        while (b != null) {
            s.push(b);
            b = j.next().value;
        }
        if (s.length === 0) {
            return Expression.ZERO;
        }
        var accumulator = s[s.length - 1];
        for (var k = s.length - 2; k >= 0; k -= 1) {
            var currentValue = s[k];
            accumulator = new Addition(accumulator, currentValue);
        }
        return accumulator;
    };

    var divideByInteger = function(e, f) {
        if (f.equals(Expression.ZERO)) {
            throw new TypeError("ArithmeticException");
        }
        var result = [];
        for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
            var rest = Expression.ONE;
            var t = undefined;
            // TODO: check, fix?
            for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
                var z = y;
                if (z instanceof Integer || z instanceof Expression.Complex || z instanceof Expression.ExpressionPolynomialRoot) {
                    if (t != undefined) {
                        console.warn("!");
                        t = t.multiply(z);
                    } else {
                        t = z;
                    }
                } else {
                    if (rest === Expression.ONE) {
                        rest = z;
                    } else {
                        rest = z.multiply(rest);
                    }
                }
            }
            if (!(t instanceof Expression.Complex)) {
                if (!(t instanceof Integer)) {
                    if (!(t instanceof Expression.ExpressionPolynomialRoot)) {
                        throw new RangeError();
                    }
                }
            }
            var summand = null;
            if (t instanceof Expression.ExpressionPolynomialRoot) { //TODO: 
                summand = t.divide(f).multiply(rest);
            } else {
                summand = t.truncatingDivide(f).multiply(rest);
            }
            result.push(summand);
        }
        return _sum(result);
    };

    Expression.getCoefficients = function(e, v) {
        if (e.equals(Expression.ZERO)) {
            return [];
        }
        var result = [];
        for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
            var d = Expression.ZERO;
            var c = Expression.ONE;
            for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
                var t = y;
                for (var iteratorve = getVariableInternal(t)[globalThis.Symbol.iterator](), ve = iteratorve.next().value; ve != null; ve = iteratorve.next().value) {
                    if (ve.v.equals(v)) {
                        d = d.add(ve.e);
                    } else {
                        c = c.multiply(ve.e === Expression.ONE ? ve.v : ve.v.pow(ve.e));
                    }
                }
            }
            var degree = d.toNumber();
            result.push({
                degree: degree,
                coefficient: c
            });
        }
        result.sort(function(a, b) {
            return b.degree - a.degree;
        });
        var k = -1;
        for (var i = 0; i < result.length; i += 1) {
            var x = result[i];
            if (k === -1 || x.degree !== result[k].degree) {
                k += 1;
                result[k] = {
                    degree: x.degree,
                    coefficient: []
                };
            }
            result[k].coefficient.push(x.coefficient);
        }
        result.length = k + 1;
        for (var i = 0; i < result.length; i += 1) {
            result[i] = {
                degree: result[i].degree,
                coefficient: _sum(result[i].coefficient)
            };
        }
        return result;
    };

    //TODO: remove
    var getFirstAdditionOperand = function(x) {
        var result = x;
        while (result instanceof Addition) {
            result = result.a;
        }
        return result;
    };
    //TODO: remove
    var getLastMultiplicationOperand = function(x) {
        var result = x;
        while (result instanceof Multiplication) {
            result = result.b;
        }
        return result;
    };

    function VIterator(v) {
        if (v == undefined) {
            throw new TypeError();
        }
        this.value = undefined;
        this.v = v;
    }
    VIterator.prototype = Object.create(Iterator.prototype);
    VIterator.prototype.next = function() {
        this.value = this.v;
        this.v = undefined;
        return this;
    };

    function VariablesIterator(v, additions) {
        if (additions == undefined) {
            throw new TypeError();
        }
        this.value = undefined;
        this.v = v;
        this.additions = additions;
    }
    VariablesIterator.prototype = Object.create(Iterator.prototype);
    VariablesIterator.prototype.next = function() {
        var x = this.additions.next().value;
        var value = null;
        if (x == null) {
            value = null;
        } else if (x instanceof Expression.Symbol) {
            value = {
                v: new Exponentiation(this.v, x),
                e: Expression.ONE
            };
        } else if (x instanceof Expression.NthRoot) { //!new 2019-11-30
            value = {
                v: new Exponentiation(this.v, x),
                e: Expression.ONE
            };
        } else if (x instanceof Expression.Exponentiation) { //!new 2019-12-01
            value = {
                v: new Exponentiation(this.v, x),
                e: Expression.ONE
            };
        } else if (x instanceof Multiplication && x.a instanceof Integer) {
            value = {
                v: new Exponentiation(this.v, x.b),
                e: x.a
            };
        } else if (x instanceof Multiplication) {
            value = {
                v: new Exponentiation(this.v, getTerm(x)),
                e: getConstant(x)
            };
        } else if (x instanceof Integer) {
            value = {
                v: this.v,
                e: x
            };
        } else if (x instanceof Expression.Division && x.a instanceof Integer && x.b instanceof Integer) { //!new 2019-06-16
            value = {
                v: this.v,
                e: x
            };
        } else if (x instanceof Expression.Division && x.a instanceof NthRoot && x.b instanceof Integer) { //!new 2019-12-01
            //value = {v: new Exponentiation(this.v, x.a), e: x.getDenominator()};
            value = {
                v: new Exponentiation(this.v, x.getNumerator()),
                e: Expression.ONE.divide(x.getDenominator())
            };
        } else if (x instanceof Expression.Division && x.a instanceof Multiplication && x.a.a instanceof Integer && x.b instanceof Integer) { //!new 2019-06-16
            if (this.v instanceof Integer) {
                value = {
                    v: new Exponentiation(this.v, x.a.b),
                    e: x.divide(x.a.b)
                };
            } else {
                value = {
                    v: this.v,
                    e: x
                }; //?
            }
        } else {
            // this.v instanceof Integer &&
            // && x.a instanceof Expression.Symbol
            if (x instanceof Division && x.b instanceof Integer) {
                var t = getTerm(x.a);
                value = {
                    v: new Exponentiation(this.v, t),
                    e: x.divide(t)
                };
            } else {
                if (x instanceof Division && x.a instanceof Integer && x.b instanceof Expression.Symbol && (this.v instanceof Integer || this.v instanceof Expression.Symbol || isGoodPolynomial(this.v))) { //TODO: fix ? 2**(1/n)
                    var t = Expression.ONE.divide(x.b);
                    value = {
                        v: new Exponentiation(this.v, t),
                        e: x.divide(t)
                    };
                } else {
                    throw new RangeError();
                }
            }
        }
        this.value = value;
        return this;
    };

    function NumeratorSummandsIterator(e) {
        this.value = undefined;
        this.internal = e.getNumerator().summands();
        this.denominator = e.getDenominator();
    }
    NumeratorSummandsIterator.prototype = Object.create(Iterator.prototype);
    NumeratorSummandsIterator.prototype.next = function() {
        var next = this.internal.next().value;
        this.value = next == null ? null : next.divide(this.denominator);
        return this;
    };

    var getVariableInternal = function(t) {
        if (t instanceof Expression.ExponentiationOfMinusOne) { //TODO: ?
            return new VIterator({
                v: t,
                e: Expression.ONE
            });
        }
        if (t instanceof Expression.ExponentiationOfImaginaryUnit) { //TODO: ?
            return new VIterator({
                v: t,
                e: Expression.ONE
            });
        }
        var v = getBase(t);
        var e = getExponent(t);

        //!new 2017-05-08
        if (enableEX) {
            if (!(e instanceof Integer)) {
                var additions = new NumeratorSummandsIterator(e);
                return new VariablesIterator(v, additions);
            }
        }
        //!
        return new VIterator({
            v: v,
            e: e
        });
    };

    var getVariable = function(e, options) {
        options = options == undefined ? null : options;

        if (options == null || !options.avoidNthRoots) {
            //? square roots at first
            for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
                for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
                    if (y instanceof NthRoot) {
                        //TODO: assert(y instanceof Integer)
                        return y;
                    }
                }
            }
            //?
        }

        var result = getVariableInternal(getLastMultiplicationOperand(getFirstAdditionOperand(e))).next().value.v;
        //!?
        //if (result instanceof NthRoot) {
        //  return undefined;
        //}
        //
        if (result instanceof Expression.Complex) {
            return undefined; //?
        }
        if (result instanceof Integer) {
            return undefined; //?
        }
        if (options != null && options.avoidNthRoots) {
            if (result instanceof NthRoot) {
                return undefined;
            }
        }
        return result;
    };

    Expression.getVariable = getVariable;

    var lastMaxSize = 1;
    var integerGCD = function(x, y) {
        if (x instanceof Expression.Complex && x.real.equals(Expression.ZERO)) {
            x = x.imaginary;
        }
        if (y instanceof Expression.Complex && y.real.equals(Expression.ZERO)) {
            y = y.imaginary;
        }
        if (x instanceof Expression.Integer && y instanceof Expression.Integer) {
            return Expression.Integer.fromBigInt(bigIntGCDWrapper(x.value, y.value));
        }
        var a = x;
        var b = y;
        while (!b.equals(Expression.ZERO)) {
            var r = a.remainder(b);
            a = b;
            b = r;
        }
        return a;
    };

    //var getIntegerContent = function (x) {
    //  return x instanceof Expression.Complex ? integerGCD(x.real, x.imaginary) : x;
    //};

    var complexGCD = function(a, b) { //?
        if (a instanceof Expression.ExpressionPolynomialRoot) {
            var x = a.root.getAlphaExpression();
            return complexGCD(Expression.getConstant(x.getNumerator()), b);
        }
        if (b instanceof Expression.ExpressionPolynomialRoot) {
            var x = b.root.getAlphaExpression();
            return complexGCD(a, Expression.getConstant(x.getNumerator()));
        }

        /*if ((a instanceof Expression.ExpressionPolynomialRoot) && b instanceof Integer) {
          return b;
        }
        if (a instanceof Integer && (b instanceof Expression.ExpressionPolynomialRoot)) {
          return a;
        }
        if (a instanceof Expression.ExpressionPolynomialRoot && b instanceof Expression.ExpressionPolynomialRoot) {
          //TODO: ???
          return Expression.ONE;
        }*/
        // return integerGCD(getIntegerContent(a), getIntegerContent(b));
        var x = integerGCD(a, b);
        if (x instanceof Expression.Complex) {
            //TODO: ?
            if (x.real.compareTo(Expression.ZERO) === 0) {
                return x.imaginary;
            }
        }
        if (x instanceof Expression.Integer) {
            if (x.compareTo(Expression.ZERO) < 0) {
                x = x.negate();
            }
        }
        return x;
    };

    var nthRootCommonFactor = function(a, b) {
        if (a instanceof Expression.NthRoot && b instanceof Expression.NthRoot) { //TODO: ?
            // gcd(a**(1/n), b**(1/k)) = gcd(a**(lcm(n,k)/n/lcm(n,k)), b**(lcm(n,k)/k/lcm(n,k))) = gcd(a**(lcm(n,k)/n), b**(lcm(n,k)/k))**(1/lcm(n,k))
            var lcm = a.n / Math.gcd(a.n, b.n) * b.n;
            // gcd(a**n, b**k) = gcd((gcd(a, b)*a/gcd(a, b))**n, (gcd(a, b)*b/gcd(a, b))**k) = gcd(a, b)**min(n, k)
            var radicandsGCD = a.radicand.gcd(b.radicand);
            var min = Math.min(lcm / a.n, lcm / b.n);
            var g = Math.gcd(lcm, min);
            return radicandsGCD._pow(min / g)._nthRoot(lcm / g);
        }
        return null;
    };

    // http://www-troja.fjfi.cvut.cz/~liska/ca/node33.html
    var gcd = function(a, b, v) {
        if (v == undefined) {
            //!TODO: (2020-06-13)
            if (getTerm(a) instanceof Expression.NthRoot && getTerm(b) instanceof Expression.NthRoot) { //TODO: remove (?)
                return gcd(getConstant(a), getConstant(b)).multiply(gcd(a.divide(getConstant(a)), b.divide(getConstant(b))));
            }
            //?
            return complexGCD(getConstant(a, true), getConstant(b, true));
        }

        var r = getReplacement(a, getReplacement(b, v));

        //!new 2023-03-11
        //TODO: !?
        var r = getReplacement(a, getReplacement(b, v, "any"), "any");
        if (r instanceof Replacement) {
            var a1 = r.apply(a);
            var b1 = r.apply(b);
            if (!a1.getDenominator().equals(Expression.ONE)) {
                console.assert(a1.getDenominator() instanceof Expression.Integer);
                a1 = a1.getNumerator();
            }
            if (!b1.getDenominator().equals(Expression.ONE)) {
                console.assert(b1.getDenominator() instanceof Expression.Integer);
                b1 = b1.getNumerator();
            }
            var c = Polynomial.polynomialGCD(Polynomial.toPolynomial(a1, v), Polynomial.toPolynomial(b1, v)).calcAt(v);
            var c1 = r.undo(c);
            if (getTerm(c1) == null) {
                return c1;
            }
            c1 = getTerm(c1);
            console.log('c1', c1.toString(), getTerm(c1));
            return c1;
        }
        if (!r.equals(v)) {
            return substitute(substitute(a, v, r, inverseReplacement(r, v)).gcd(substitute(b, v, r, inverseReplacement(r, v))), v, inverseReplacement(r, v), r);
        }

        return Polynomial.polynomialGCD(Polynomial.toPolynomial(a, v), Polynomial.toPolynomial(b, v)).calcAt(v);
    };

    // ! new 21.12.2013 (square roots)

    var getConjugateFactor = function(e) {
        var r = -1 / 0;
        for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
            for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
                if (y instanceof NthRoot) {
                    var degree = y.degree;
                    if (r < degree) {
                        r = degree;
                    }
                    if (!(y.a instanceof Integer)) {
                        r = 1 / 0;
                    }
                }
            }
        }
        var p = undefined;
        for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
            for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
                if (y instanceof NthRoot) {
                    var degree = y.degree;
                    var i = y.a instanceof Integer ? y.a : null;
                    if (i == null) {
                        i = QuadraticInteger.toQuadraticInteger(y.a);
                        if (i != null && p == undefined) {
                            var pf = i.primeFactor();
                            while (pf.toExpression() instanceof Expression.SquareRoot) {
                                i = i.truncatingDivide(pf);
                                pf = i.primeFactor();
                            }
                            i = pf;
                        }
                    }
                    if (i == null) {
                        throw new TypeError();
                    }
                    if (r === 1 / 0 && !(y.a instanceof Integer)) {
                        r = degree;
                    }
                    if (r % degree === 0) {
                        if (p == undefined) {
                            p = i;
                        }
                        //TODO: assert(y instanceof Integer)
                        if (i != null) {
                            var z = integerGCD(p, i);
                            if (!z.isUnit()) {
                                p = z; //!
                            }
                            if (z.isUnit() && !(z instanceof Integer) && (p.isUnit() || i.isUnit())) {
                                p = z; //?
                            }
                        } else {
                            throw new TypeError();
                        }
                    }
                }
            }
        }
        //!new 2020-12-16 - ExpressionParser.parse('1/(x+cbrt(18)+cbrt(12))')
        if (p != undefined) {
            if (p instanceof Integer) { //TODO: ?
                p = p.primeFactor();
            }
        }
        //!
        return {
            p: p,
            degree: r
        };
    };

    // TODO: test
    var getConjugate = function(a) {
        var e = undefined;
        e = Expression.getComplexNumberParts(a);
        if (e != undefined && !e.imaginary.equals(Expression.ZERO)) {
            return e.real.subtract(e.imaginary.multiply(Expression.I));
        }
        e = Expression.getNthRootConjugate(a);
        if (e != undefined) {
            if (e.equals(a) && a instanceof Addition) {
                throw new TypeError();
            }
            return e;
        }
        return undefined;
    };

    Expression.getConjugate = getConjugate;

    Expression.getConjugateExpression = function(e) { //?
        try {
            var c = Expression.getConjugate(e);
            if (c != null) {
                return Expression.getConjugateExpression(c.multiply(e));
            }
            return e;
        } catch (error) {
            //TODO: FIX!!!
            console.error(error);
        }
        return null;
    };

    var getPolynomialRelativeToNthRoot = function(e, p, r) {
        // Make a polynomial, with a variable = p**(1/r):
        var polynomial = Polynomial.of();
        for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
            var degree = 0;
            var coefficient = Expression.ONE;
            for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
                if (y instanceof NthRoot && (r === y.degree || r % y.degree === 0 && p instanceof Integer)) {
                    var i = y.a instanceof Integer ? y.a : null;
                    if (i == null) {
                        i = QuadraticInteger.toQuadraticInteger(y.a);
                    }
                    if (i != null) {
                        var j = 0;
                        var a = i;
                        if (p.isUnit()) {
                            if (a.isUnit()) {
                                j = 1;
                                a = a.truncatingDivide(p);
                                // a == 3+sqrt(2), p == 1+sqrt(2)
                                while (a.primeFactor().equals(p)) {
                                    j += 1;
                                    a = a.truncatingDivide(p);
                                }
                            } else {
                                if (!(a instanceof Integer)) {
                                    //TODO: ?
                                    //throw new TypeError();
                                    var tmp = a.truncatingDivide(p);
                                    if (!(tmp instanceof Expression.Integer)) {
                                        if (Number.isNaN(Number(tmp.a.toString()) * Number(tmp.b.toString()))) {
                                            throw new TypeError(); //TODO: FIX
                                        }
                                    }
                                    if (tmp instanceof Expression.Integer || Number(tmp.a.toString()) * Number(tmp.b.toString()) >= 0) {
                                        j = 1;
                                        a = tmp;
                                    }
                                }
                            }
                        } else {
                            //TODO: optimize using ctz
                            while (a.isDivisibleBy(p) && j < y.degree) { //?
                                a = a.truncatingDivide(p);
                                j += 1;
                            }
                        }
                        a = a.toExpression();
                        coefficient = coefficient.multiply(a._nthRoot(y.degree));
                        degree += j * (r / y.degree);
                    } else {
                        throw new TypeError();
                    }
                } else {
                    coefficient = coefficient.multiply(y);
                }
            }
            //TODO: efficiency ?
            polynomial = polynomial.add(Polynomial.of(coefficient).shift(degree));
        }
        return polynomial;
    };

    // https://en.wikipedia.org/wiki/Conjugate_(square_roots)
    Expression.getNthRootConjugate = function(e) {
        var expression = e;
        if (e instanceof Integer) {
            //optimize to not stop the debugger at common code
            return null;
        }
        if (e instanceof NthRoot) {
            //optimize to not stop the debugger at common code
            return e._pow(e.n - 1);
        }
        if (e instanceof Multiplication && e.a instanceof Integer) {
            //optimize to not stop the debugger at common code
            return Expression.getNthRootConjugate(e.b);
        }
        //!2019-10-20 a workaround
        if (e instanceof Addition &&
            e.a instanceof Multiplication && e.a.a instanceof Integer && e.a.b instanceof NthRoot && e.a.b.n === 3 &&
            e.b instanceof Multiplication && e.b.a instanceof Integer && e.b.b instanceof NthRoot && e.b.b.n === 3) {
            // (aa-ab+bb)
            return e.a._pow(2).subtract(e.a.multiply(e.b)).add(e.b._pow(2));
        }
        //!
        //?
        //if (e instanceof Expression.Exponentiation && getExponent(e).equals(Expression.ONE.divide(Expression.TWO))) {//TODO: FIX
        //return e;//?
        //}
        //?

        //TODO: fix
        var tmp = getConjugateFactor(e);
        var p = tmp.p;
        var r = tmp.degree;
        if (p == undefined) {
            return undefined;
        }
        var polynomial = getPolynomialRelativeToNthRoot(e, p, r);
        polynomial = polynomial.divideAndRemainder(Polynomial.of(polynomial.getContent()), "throw").quotient; //!new
        var x = p.toExpression();
        var mod = Polynomial.of(Expression.ONE).shift(r).subtract(Polynomial.of(x));
        var conjugate2 = polynomial.modularInverse(mod).primitivePart();
        return conjugate2.calcAt(x._nthRoot(r));
    };

    // without the checks
    Expression.collectLinearEquationVariables = function(e) {
        if (e instanceof Division) {
            throw new RangeError();
        }
        var list = [];
        for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
            var v = undefined;
            var c = Expression.ONE;
            var NO_VARIABLE = "";
            for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
                if (y instanceof Expression.Symbol && v == undefined) {
                    v = y;
                } else {
                    if (!(y instanceof Integer) && !(y instanceof NthRoot)) {
                        if (v == undefined) {
                            v = NO_VARIABLE;
                        }
                    }
                    c = c.multiply(y);
                }
            }
            if (v == undefined) {
                v = NO_VARIABLE;
            }
            var variable = v === NO_VARIABLE ? "" : v.toString();
            list.push({
                c: c,
                v: variable
            });
        }
        return list;
    };

    var has = function(e, Class) {
        if (e instanceof Class) {
            return true;
        }
        if (e instanceof BinaryOperation) {
            if (e instanceof Addition) {
                while (e instanceof Addition) {
                    if (has(e.b, Class)) {
                        return true;
                    }
                    e = e.a;
                }
                return has(e, Class);
            }
            if (has(e.b, Class)) {
                return true;
            }
            return has(e.a, Class);
        }
        if (e instanceof Negation) {
            return has(e.b, Class);
        }

        if (e instanceof Expression.Function) {
            return has(e.a, Class);
        }
        return false; //?
    };
    Expression.has = has;

    var has2 = function(e, Class) {
        do {
            var e1 = null;
            if (e instanceof Addition) {
                e1 = e.b;
                e = e.a;
            } else {
                e1 = e;
                e = null;
            }
            do {
                var e2 = null;
                if (e1 instanceof Multiplication) {
                    e2 = e1.b;
                    e1 = e1.a;
                } else {
                    e2 = e1;
                    e1 = null;
                }
                if (e2 instanceof Class) {
                    return true;
                }
            } while (e1 != null);
        } while (e != null);
        return false;
    };

    var inverseReplacement = function(e, v) {
        var t = v;
        while (!e.equals(v)) {
            if (e instanceof Expression.Exponentiation && e.b instanceof Multiplication && v instanceof Exponentiation) {
                t = t.pow(e.b.a.inverse());
                e = e.pow(e.b.a.inverse());
            } else if (e instanceof Expression.Exponentiation) {
                t = t.pow(getExponent(e).inverse());
                e = getBase(e);
            } else if (e instanceof Addition) {
                if (!(e.b instanceof Integer)) {
                    throw new RangeError();
                }
                t = t.subtract(e.b);
                e = e.a;
            } else if (e instanceof Multiplication) {
                if (!(e.a instanceof Integer)) {
                    throw new RangeError();
                }
                t = t.divide(e.a);
                e = e.b;
            } else if (e instanceof Division) {
                if (!(e.b instanceof Integer)) {
                    throw new RangeError();
                }
                t = t.multiply(e.b);
                e = e.a;
            } else {
                if ((Expression.E === e) || (e instanceof Integer && e.compareTo(Expression.ONE) > 0) && getBase(v).equals(e)) { //!new 2019-09-23
                    t = t.pow(getExponent(v));
                    e = v;
                } else {
                    throw new TypeError();
                }
            }
        }
        return t;
    };

    var h = function(e, n, q) {
        for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
            for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
                if (getBase(q).equals(getBase(y))) {
                    n = n.lcm(getExponent(y).getDenominator());
                }
            }
        }
        return n;
    };

    // t=sqrt(x**2+1)
    Replacement._counter = 0;

    function Replacement(from) {
        this.from = getBase(from);
        this.to = new Expression.Symbol("$t" + (++Replacement._counter)).pow(getExponent(from).getDenominator());
    }
    Replacement.prototype.apply = function(e) {
        var from = this.from;
        var to = this.to;
        var variable = getVariable(from);
        var p1 = Polynomial.toPolynomial(from.subtract(to), variable);

        return Expression._map(function(x) {
            if (!Expression.has(x, Expression.Division)) {
                var p2 = Polynomial.toPolynomial(x, variable);
                return p2.divideAndRemainder(p1).remainder.calcAt(variable);
            }
            return x;
        }, e);
    };
    Replacement.prototype.undo1 = function(e) {
        var from = this.from;
        var to = this.to;
        var variable = getBase(this.to);
        var p1 = Polynomial.toPolynomial(from.subtract(to), variable);
        return Polynomial.toPolynomial(e, variable).divideAndRemainder(p1).remainder.calcAt(variable);
    };
    Replacement.prototype.undo = function(e) {
        var variable = getBase(this.to);
        var r = this.from.pow(getExponent(this.to).inverse());
        return Expression._map(function(x) {
            if (x.equals(variable)) {
                return r;
            }
            return x;
        }, e);
    };
    Replacement.prototype.equals = function() {
        return true; //TODO: ?
    };

    // a^(2/3)+a^(1/3), a->a**3
    // -2*(-1)^n*3^(n/2)+2*3^(n/2), 3^n -> 3^(2*n)
    // (4*k+1)^(1/2)-1, k->(k^2-1)/4
    var getReplacement = function(e, v, originalVariable) {
        if (v instanceof Replacement) {
            return v;
        }
        for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
            for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
                if (y instanceof Expression.Exponentiation && (Expression.has(y.a, Expression.Symbol) || y.a instanceof Integer && y.a.compareTo(Expression.ONE) > 0) && y.b instanceof Expression.Division) {
                    if (getBase(v).equals(y.a)) {
                        //v = new Expression.Exponentiation(y.a, y.b.b.lcm(getExponent(v).getNumerator()));
                        v = new Expression.Exponentiation(y.a, getConstant(y.b.b).lcm(getExponent(v).getNumerator()).divide(getExponent(v).getDenominator()));
                    } else if (getBase(v) instanceof Expression.Symbol) {
                        if ((y.a instanceof Expression.Addition && y.a.a.divide(getBase(v)) instanceof Integer && y.a.b instanceof Integer) && (y.b instanceof Division && y.b.a instanceof Integer && y.b.b instanceof Integer)) {
                            var n = y.b.getDenominator();
                            n = h(e, n, y); //!
                            //TODO: ?
                            //debugger;
                            // sqrt(y.a.a + y.a.b) = t
                            // k * v = y.a.a = t**2 - y.a.b
                            // v = (t**2 - y.a.b) / (y.a.a / v)
                            var t = getBase(v).pow(n).subtract(y.a.b).divide(y.a.a.divide(getBase(v)));
                            return t;
                        } else {
                            //TODO: test
                            //throw new TypeError();
                            if (originalVariable === "any" || originalVariable != null && originalVariable.equals(y.a)) {
                                return new Replacement(y);
                            }
                        }
                    }
                }
            }
        }
        return v;
    };

    Expression._getReplacement = getReplacement;

    var substitute = function(e, a, b, inv) {
        if (e.equals(a)) {
            return b;
        }
        if (e instanceof Expression.Exponentiation) {
            if (e.equals(inv)) {
                return a;
            }
            if (getBase(e).equals(getBase(inv))) { //!new 2019-09-23
                return a.pow(getExponent(e).divide(getExponent(inv)));
                //TODO: add an assertion below
            }
        }

        if (e instanceof Expression.Addition) {
            return substitute(e.a, a, b, inv).add(substitute(e.b, a, b, inv));
        }
        if (e instanceof Expression.Multiplication) {
            return substitute(e.a, a, b, inv).multiply(substitute(e.b, a, b, inv));
        }
        if (e instanceof Expression.Exponentiation) {
            var x = substitute(e.a, a, b, inv);
            var y = substitute(e.b, a, b, inv);
            //console.log(x + ' ' + y + ' ' + a + ' ' + b + ' ' + inv);
            if (x instanceof Expression.Exponentiation &&
                getBase(x).equals(getBase(inv)) &&
                getExponent(inv).getDenominator().remainder(Expression.TWO).equals(Expression.ZERO)) {
                //TODO: FIX
                return getBase(x).pow(getExponent(x).multiply(y));
            }
            return x.pow(y);
        }
        //return e;

        //! for sin.js:
        if (e instanceof Division) {
            return substitute(e.a, a, b, inv).divide(substitute(e.b, a, b, inv));
        }
        if (e instanceof Expression.Sin) {
            return substitute(e.a, a, b, inv).sin();
        }
        if (e instanceof Expression.Cos) {
            return substitute(e.a, a, b, inv).cos();
        }
        return e;
    };

    Expression._substitute = substitute;

    Expression.prototype.divideExpression = function(x) {
        var y = this;

        //if (Expression.getIdentityMatrixCoefficient(x) != undefined) {
        //  if (y instanceof Expression.Matrix) {
        //    return Expression.getIdentityMatrixCoefficient(x).divide(y);
        //  }
        //  return Expression.makeIdentityMatrixWithCoefficient(Expression.getIdentityMatrixCoefficient(x).divide(y));
        //}
        //if (Expression.getIdentityMatrixCoefficient(y) != undefined) {
        //  if (x instanceof Expression.Matrix) {
        //    return x.divide(Expression.getIdentityMatrixCoefficient(y));
        //  }
        //  return Expression.makeIdentityMatrixWithCoefficient(x.divide(Expression.getIdentityMatrixCoefficient(y)));
        //}

        //if (has(x, IdentityMatrix)) {//?
        //  throw new RangeError("NotSupportedError");
        //}
        //if (has(x, MatrixSymbol)) {
        //  throw new RangeError("NotSupportedError");
        //}

        if (simplifyIdentityMatrixPower) {
            if (x instanceof Multiplication && x.b instanceof IdentityMatrix) {
                return x.b.equals(y) ? x.a : x.a.divide(y).multiply(x.b);
            } else if (x instanceof IdentityMatrix) {
                return Expression.ONE.divide(y).multiply(x);
            }
            if (y instanceof Multiplication && y.b instanceof IdentityMatrix) {
                return x.divide(y.a).multiply(y.b);
            } else if (y instanceof IdentityMatrix) {
                return x.multiply(y);
            }
        }

        if (has(y, MatrixSymbol)) {
            //!?
            var tmp = getBase(y) instanceof MatrixSymbol ? y.pow(Expression.ONE.negate()) : new Expression.Exponentiation(y, Expression.ONE.negate());
            if (x.equals(Expression.ONE)) {
                if (y instanceof Multiplication) {
                    //!?
                    //TODO: info about properties of the Matrix Inversion
                    if (Expression.callback != undefined) {
                        Expression.callback(new Expression.Event("property-inverse-of-multiplication", {
                            matrix: "{{0}}"
                        }));
                    }
                    return x.multiply(Expression.ONE.divide(y.b).multiply(Expression.ONE.divide(y.a)));
                }
                if (y instanceof Addition && !has(y, Expression.Matrix)) {
                    var f = Expression.simpleDivisor(y);
                    if (f != null && !f.equals(Expression.ONE) && isScalar(f) && !gcd(f, y).equals(Expression.ONE)) {
                        return x.multiply(Expression.ONE.divide(f).multiply(Expression.ONE.divide(y.divide(f))));
                    }
                }
                return tmp;
            }
            //return x.multiply(tmp);
            //return new Expression.Multiplication(x, tmp);
            //throw new RangeError("NotSupportedError");
        }

        if (x instanceof Expression.Matrix && y instanceof Expression.Matrix) {
            // TODO: callback ???
            return new Expression.Matrix(x.matrix.multiply(y.matrix.inverse()));
        }
        if (x instanceof Expression.Matrix && y instanceof Expression) {
            //return new Expression.Matrix(x.matrix.scale(y.inverse()));
            return x.multiply(y.inverse());
        }
        if (x instanceof Expression && y instanceof Expression.Matrix) {
            if (Expression.callback != undefined) {
                Expression.callback(new Expression.Event(y.matrix.getDeterminantEventType("inverse").type, y));
            }
            //return new Expression.Matrix(y.matrix.inverse().scale(x));
            return new Expression.Matrix(y.matrix.inverse()).multiply(x);
        }

        if (y.equals(Expression.ZERO)) {
            //TODO: fix?
            throw new TypeError("ArithmeticException");
        }
        if (x.equals(Expression.ZERO)) {
            return Expression.ZERO;
        }
        if (y.equals(Expression.ONE)) {
            return x;
        }

        //!!! new (2021-04-05)
        // hack!
        //TODO: remove - ?
        var term = getTerm(y);
        if (term instanceof Expression.Exponentiation && getBase(term) === Expression.E && (getExponent(term) instanceof Expression.ExpressionPolynomialRoot)) {
            //if (Expression.isConstant(term.b.e)) {
            if (getTerm(x) instanceof Expression.Exponentiation && getExponent(getTerm(x)) instanceof Expression.ExpressionPolynomialRoot) {
                if ((x instanceof Expression.Exponentiation || x instanceof Expression.Multiplication) && (y instanceof Expression.Exponentiation || y instanceof Expression.Multiplication)) {
                    return getExponent(getTerm(x)).subtract(getExponent(getTerm(y))).exp().multiply(getConstant(x).divide(getConstant(y)));
                }
            }
            if (getExponent(getTerm(y)).isNegative()) {
                return x.multiply(term.inverse()).divide(y.divide(term));
            }
            //}
        }
        //!!!

        //!!! new (21.12.2013)
        if (true) { //TODO: remove hack!
            var e = getConjugate(y);
            if (e != undefined) {
                if (e.equals(Expression.ONE)) {
                    //!
                    if (Expression.isConstant(y)) {
                        return x.multiply(Expression._map(function(x) {
                            return x instanceof NthRoot ? Expression.toPolynomialRoot(x) : x;
                        }, y).inverse());
                    }
                    //!
                    throw new TypeError(); // "assertion"
                }
                //TODO: fix for g+i*g
                if (e instanceof Expression.Multiplication && e.a instanceof Expression.Complex) {
                    e = e.a;
                }
                return x.multiply(e).divide(y.multiply(e));
            }
        }

        if (Expression.has(x, Expression.Complex)) { //!new 2017-11-25
            var tmp = Expression.getComplexNumberParts(x);
            if (tmp != undefined && !tmp.imaginary.equals(Expression.ZERO)) {
                var a = tmp.real;
                var b = tmp.imaginary;
                var g = (a.equals(Expression.ZERO) ? y : a.gcd(y)).gcd(b)._abs();
                if (!g.equals(Expression.ONE)) {
                    x = a.divide(g).add(b.divide(g).multiply(Expression.I));
                    y = y.divide(g);
                }
                if (y.isNegative()) {
                    x = x.negate();
                    y = y.negate();
                }
                return y.equals(Expression.ONE) ? x : new Division(x, y);
            }
        } //!

        //!2020-06-07
        if (!getConstant(y).equals(y) && x.divide(getConstant(x)).equals(y.divide(getConstant(y)))) {
            return getConstant(x).divide(getConstant(y));
        }

        // check if y is instance of Integer to avoid issues with nth-roots (?) - see a test
        //TODO: investigate
        var v = y instanceof Integer ? undefined : getVariable(x); //???
        //var v = getVariable(x);//???
        //TODO: move?

        if (has(v, MatrixSymbol) && isScalar(y)) { //TODO: fix ?
            v = getVariable(y);
        }

        //!2019-06-16
        if (v != null) { // e**(1/2)
            var originalVariable = v;
            v = getVariable(v);
            var r = getReplacement(y, getReplacement(x, v, originalVariable), "any");
            if (r instanceof Replacement) {
                //debugger;
                var a = r.apply(x);
                var b = r.apply(y);
                var c = a.divide(b);
                var n = r.undo1(c.getNumerator());
                var d = r.undo1(c.getDenominator());
                //debugger;
                //!new 2023-03-11:
                //TODO: instead do gcd modulo t^n - <from>  - ?
                var g = n.gcd(d); //TODO:
                if (!g.equals(Expression.ONE)) {
                    n = n.divide(g);
                    d = d.divide(g);
                }
                n = r.undo(n);
                d = r.undo(d);
                return d.equals(Expression.ONE) ? n : new Expression.Division(n, d);
            }
            if (!r.equals(v)) {
                var ir = inverseReplacement(r, v);
                var a = substitute(x, v, r, ir);
                var b = substitute(y, v, r, ir);
                //console.log(a + ' ' + b);
                var t = a.divide(b);
                a = substitute(t.getNumerator(), v, ir, r);
                b = substitute(t.getDenominator(), v, ir, r);
                return b.equals(Expression.ONE) ? a : new Expression.Division(a, b);
            }
        }


        // gcd
        var px = undefined;
        var py = undefined;
        if (v != undefined) {
            px = Polynomial.toPolynomial(x, v);
            py = Polynomial.toPolynomial(y, v);
            if (px.getDegree() === 0 && py.getDegree() === 0) {
                v = undefined;
            }
        }
        if (v == undefined) {
            var g = complexGCD(getConstant(x, true), getConstant(y, true));
            if (!g.equals(Expression.ONE)) {
                x = divideByInteger(x, g);
                y = divideByInteger(y, g);
                return x.divide(y);
            }
        } else {
            //!TODO: remove - performance optimization
            var t = px.divideAndRemainder(py, "undefined");
            if (t != undefined && t.remainder.equals(Polynomial.ZERO)) {
                return t.quotient.calcAt(v);
            }
            //!
            var g = Polynomial.polynomialGCD(px, py);
            if (g.getDegree() !== 0 || !g.getLeadingCoefficient().equals(Expression.ONE)) { // g !== 1
                var x2 = px.divideAndRemainder(g, "throw").quotient;
                var y2 = py.divideAndRemainder(g, "throw").quotient;
                return x2.calcAt(v).divide(y2.calcAt(v));
            }
        }

        //var lc = getConstant(getLeadingCoefficient(y, v));
        //var lc = getConstant(getLeadingCoefficient(y, getVariable(y)));
        var lc = getConstant(getFirstAdditionOperand(y));
        if (lc.compareTo(Expression.ZERO) < 0) {
            return x.negate().divide(y.negate());
        }
        if (has(y, MatrixSymbol)) { //?
            return new Expression.Multiplication(x, new Expression.Exponentiation(y, Expression.ONE.negate())); //?
        } //?
        return new Division(x, y);
    };

    function Expression() {
        throw new TypeError("Do not call for better performance");
    }

    Expression.callback = undefined;
    Expression.Event = function(type, data, second) {
        second = second == undefined ? undefined : second;
        this.type = type;
        this.data = data;
        this.second = second;
    };

    Expression.prototype.compare4Multiplication = function(y) {
        throw new TypeError(this.toString());
    };
    Expression.prototype.compare4MultiplicationInteger = function(x) {
        throw new TypeError();
    };
    Expression.prototype.compare4MultiplicationSymbol = function(x) {
        throw new TypeError();
    };
    Expression.prototype.compare4MultiplicationNthRoot = function(x) {
        throw new TypeError();
    };

    Expression.prototype.negate = function() {
        return Expression.ONE.negate().multiply(this);
    };
    Expression.prototype.add = function(y) {
        return y.addExpression(this);
    };
    Expression.prototype.subtract = function(y) {
        return this.add(y.negate());
    };
    Expression.prototype.divide = function(y) {
        //!2019-04-22
        if (!(y instanceof Expression.Matrix)) {
            if (this.equals(y)) { //!TODO: remove - a hack to avoid some exceptions
                //if (this instanceof IdentityMatrix) {
                //  return this;
                //}
                return Expression.ONE;
            }
            if (this.equals(y.negate())) {
                return Expression.ONE.negate();
            }
        }
        return y.divideExpression(this);
    };
    Expression.prototype.multiply = function(y) {
        return y.multiplyExpression(this);
    };
    Expression.prototype.pow = function(y) {
        return y.powExpression(this);
    };
    Expression.prototype.getDenominator = function() {
        //TODO: FIX!!!!
        return this instanceof Division ? this.b : Expression.ONE;
    };
    Expression.prototype.getNumerator = function() {
        //TODO: FIX!!!!
        return this instanceof Division ? this.a : this;
    };
    Expression.prototype.inverse = function() {
        return Expression.ONE.divide(this);
    };
    Expression.prototype.exp = function() {
        return Expression.E.pow(this);
    };


    //TODO: use in Expression#getCoefficients -?
    var variables = function(e) {
        var result = [];
        for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
            for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
                for (var iteratorve = getVariableInternal(y)[globalThis.Symbol.iterator](), ve = iteratorve.next().value; ve != null; ve = iteratorve.next().value) {
                    if (!(ve.v instanceof Integer)) {
                        result.push(ve.v);
                    }
                }
            }
        }
        return result;
    };

    //TODO: remove - performance optimization
    var getCommonVariable = function(x, y) {
        var a = variables(x);
        var b = variables(y);
        for (var i = 0; i < a.length; i += 1) {
            if (a[i] instanceof NthRoot) {
                return a[i];
            }
        }
        for (var i = 0; i < b.length; i += 1) {
            if (b[i] instanceof NthRoot) {
                return b[i];
            }
        }
        for (var i = 0; i < a.length; i += 1) {
            if (a[i] instanceof Addition) {
                //return variables(a[i])[0];//TODO: fix
                a = a.concat(variables(a[i]));
                a[i] = null;
            }
        }
        for (var i = 0; i < b.length; i += 1) {
            if (b[i] instanceof Addition) {
                //return variables(b[i])[0];//TODO: fix
                b = b.concat(variables(b[i]));
                b[i] = null;
            }
        }
        for (var i = 0; i < a.length; i += 1) {
            for (var j = 0; j < b.length; j += 1) {
                if (a[i] != null && b[j] != null) {
                    if (a[i].equals(b[j])) {
                        return a[i];
                    }
                }
            }
        }
        return null;
    };

    // TODO: fix or remove ?
    Expression.prototype.gcd = function(x) {
        if (this.equals(Expression.ONE)) {
            return this;
        }
        //if (this.equals(x)) {
        //return this;//?
        //}
        if (this instanceof Integer && x instanceof Integer) {
            return integerGCD(this, x); //performance
        }
        if (!(this instanceof Integer) && !(x instanceof Integer)) {
            //TODO: fix
            //return gcd(this, x, getVariable(this) || getVariable(x));
            //TODO: remove this block (a workaround for buggy gcd)
            var t1 = getTerm(this);
            var t2 = getTerm(x);
            if (t1 != null && t2 != null && t1.equals(t2)) {
                return getConstant(this).gcd(getConstant(x)).multiply(t2);
            }
            //!2020-11-05 more workarounds:
            t1 = getTerm(getFirstAdditionOperand(this));
            t2 = getTerm(getFirstAdditionOperand(x));
            if (t1 != null && t2 != null && t1.equals(t2)) {
                var c1 = getConstant(getFirstAdditionOperand(this));
                var c2 = getConstant(getFirstAdditionOperand(x));
                if (c1 instanceof Integer && c2 instanceof Integer) {
                    var alpha = c1.truncatingDivide(c2);
                    if (alpha instanceof Expression.Integer && alpha.multiply(c2).equals(c1)) {
                        return this.subtract(x.multiply(alpha)).gcd(x);
                    }
                    var alpha = c2.truncatingDivide(c1);
                    if (alpha instanceof Expression.Integer && alpha.multiply(c1).equals(c2)) {
                        return this.gcd(x.subtract(this.multiply(alpha)));
                    }
                }
            }
        }
        if (this.equals(Expression.ZERO) || x.equals(Expression.ZERO)) {
            return this.add(x);
        }
        //!
        var result = gcd(this, x, getCommonVariable(this, x));
        return result;
    };
    // Least common multiple
    Expression.prototype.lcm = function(x) {
        if (x.equals(Expression.ONE)) {
            return this; //performance
        }
        return this.divide(this.gcd(x)).multiply(x);
    };

    //!new 2020-07-21
    Expression.prototype.polynomialGCD = function(b) {
        var a = this;

        var v = getVariableInternal(getLastMultiplicationOperand(getFirstAdditionOperand(a))).next().value.v; // avoid square roots
        if (v instanceof Expression.Symbol) {
            var r = getReplacement(a, getReplacement(b, v));
            if (!r.equals(v)) {
                return substitute(substitute(a, v, r, inverseReplacement(r, v)).polynomialGCD(substitute(b, v, r, inverseReplacement(r, v))), v, inverseReplacement(r, v), r);
            }

            return Polynomial.polynomialGCD(Polynomial.toPolynomial(a, v), Polynomial.toPolynomial(b, v)).calcAt(v);
        }
        return a.gcd(b); //?
    };

    //TODO: merge with ExpressionParser.js ?!?
    var precedence = {
        binary: {
            ".^": 5,
            "^": 5,
            "*": 3,
            "/": 3,
            "+": 2,
            "-": 2
        },
        unary: {
            "-": 5 //HACK
        }
    };

    var Symbol = null;

    Expression.Symbol = function(symbol) {
        //Expression.call(this);
        this.symbol = symbol;
    };

    Expression.Symbol.prototype = Object.create(Expression.prototype);

    Expression.Symbol.prototype.compare4Multiplication = function(y) {
        return y.compare4MultiplicationSymbol(this);
    };
    Expression.Symbol.prototype.compare4MultiplicationInteger = function(x) {
        return -1;
    };
    Expression.Symbol.prototype.compare4MultiplicationSymbol = function(x) {
        return x.symbol < this.symbol ? -1 : (this.symbol < x.symbol ? +1 : 0);
    };
    Expression.Symbol.prototype.compare4MultiplicationNthRoot = function(x) {
        return -1;
    };

    Expression.Symbol.prototype.toString = function(options) {
        if (this.symbol === '\u2147') {
            return 'e'; //!
        }
        return this.symbol;
    };

    Expression.Symbol.prototype._pow = function(count) {
        if (count > 1) {
            return new Expression.Exponentiation(this, Expression.Integer.fromNumber(count));
        }
        return Expression.prototype._pow.call(this, count);
    };

    Expression.prototype.addInteger = function(x) {
        return this.addExpression(x);
    };
    Expression.prototype.multiplyInteger = function(x) {
        if (x === Expression.ONE) {
            return this;
        }
        return this.multiplyExpression(x);
    };
    Expression.prototype.divideInteger = function(x) {
        return this.divideExpression(x);
    };

    var simplifyIdentityMatrixPower = true; //! TODO:

    function Integer(value) {
        //Expression.call(this);
        this.value = value;
    }

    Integer.prototype = Object.create(Expression.prototype);

    Integer.prototype.powExpression = function(x) {
        var y = this;
        if (x instanceof IdentityMatrix) {
            if (simplifyIdentityMatrixPower) {
                return new IdentityMatrix(x.symbol);
            }
        }
        if (x instanceof MatrixSymbol) {
            if (y.equals(Expression.ZERO)) {
                return Expression.ONE;
            }
            if (y.equals(Expression.ONE)) {
                return x;
            }
            return new Exponentiation(x, y); //?
        }
        //!new 2019-12-16
        if (x instanceof Exponentiation && getExponent(x) instanceof Integer && y instanceof Integer) { //? (X**2)**(-1)
            return getBase(x).pow(getExponent(x).multiply(y));
        }
        //!
        //!new 2020-03-02
        if (x instanceof Exponentiation && getTerm(getExponent(x)) instanceof Expression.Symbol) { //? (X**2)**(-1)
            return getBase(x).pow(getExponent(x).multiply(y));
        }
        //!

        if (y.compareTo(Expression.ZERO) < 0) {
            return Expression.ONE.divide(x.pow(y.negate()));
        }
        if (x instanceof Expression.Matrix) {
            if (y.compareTo(Expression.ONE) > 0) {
                if (!x.matrix.isDiagonal()) {
                    if (Expression.callback != undefined) {
                        Expression.callback(new Expression.Event("pow", x, new Expression.Matrix(Matrix.I(1).map(function() {
                            return y;
                        }))));
                    }
                }
            }
            var powMatrix = function(matrix, n) {
                if (n.toNumber() > Number.MAX_SAFE_INTEGER) {
                    return powMatrix(matrix, n.truncatingDivide(Expression.TWO)).pow(2).multiply(matrix.pow(n.remainder(Expression.TWO).toNumber()));
                }
                return matrix.pow(n.toNumber());
            };
            return new Expression.Matrix(powMatrix(x.matrix, y));
        }
        if (y.equals(Expression.ZERO)) {
            return Expression.ONE;
        }
        if (y.equals(Expression.ONE)) {
            return x;
        }

        if (x instanceof Expression.Symbol) {
            return new Exponentiation(x, y);
        }
        if (x instanceof Exponentiation) {
            var t = x.b.multiply(y);
            if (t.getNumerator() instanceof Integer && t.getDenominator() instanceof Integer) { //TODO: ?
                var i = t.getNumerator().truncatingDivide(t.getDenominator());
                if (i.compareTo(Expression.ZERO) > 0) {
                    return x.a.pow(i).multiply(x.a.pow(t.subtract(i)));
                }
            }
            return x.a.pow(x.b.multiply(y));
        }
        if (x instanceof Integer && (x.compareTo(Expression.ZERO) === 0 || x.compareTo(Expression.ONE) === 0 || x.compareTo(Expression.ONE.negate()) === 0)) {
            return y.remainder(Expression.TWO).compareTo(Expression.ZERO) === 0 ? x.multiply(x) : x;
        }
        if (x.equals(Expression.I)) {
            y = y.remainder(Expression.TWO.add(Expression.TWO));
            return Expression.pow(x, y.toNumber());
        }
        // assert(x instanceof Operation || x instanceof Integer);
        return Expression.pow(x, y.toNumber());
    };

    Integer.prototype.compare4Multiplication = function(y) {
        return y.compare4MultiplicationInteger(this);
    };
    Integer.prototype.compare4MultiplicationInteger = function(x) {
        return x.compareTo(this);
        //return 0;
    };
    Integer.prototype.compare4MultiplicationSymbol = function(x) {
        return +1;
    };
    Integer.prototype.compare4MultiplicationNthRoot = function(x) {
        return +1;
    };

    Integer.prototype.negate = function() {
        return new Integer(SmallBigInt.unaryMinus(this.value));
    };
    Integer.prototype.isUnit = function() {
        return this.equals(Expression.ONE) || this.equals(Expression.ONE.negate());
    };
    Expression.prototype.toExpression = function() {
        return this;
    };
    Integer.prototype.compareTo = function(y) {
        if (y instanceof Expression.Integer) {
            var b = y.value;
            var a = this.value;
            return SmallBigInt.lessThan(a, b) ? -1 : (SmallBigInt.lessThan(b, a) ? +1 : 0);
        }
        return Expression.prototype.compareTo.call(this, y);
    };
    Integer.prototype.abs = function() {
        return SmallBigInt.toNumber(this.value) < 0 ? this.negate() : this;
    };
    Integer.prototype.sign = function() {
        return Math.sign(SmallBigInt.toNumber(this.value));
    };
    Integer.prototype.add = function(y) {
        if (this === Expression.ZERO) {
            return y;
        }
        return y.addInteger(this);
    };
    Integer.prototype.addInteger = function(x) {
        return new Integer(SmallBigInt.add(x.value, this.value));
    };
    Integer.prototype.multiply = function(y) {
        return y.multiplyInteger(this);
    };
    Integer.prototype.multiplyInteger = function(x) {
        if (x === Expression.ONE) {
            return this;
        }
        return new Integer(SmallBigInt.multiply(x.value, this.value));
    };
    Integer.prototype.divide = function(y) {
        return y.divideInteger(this);
    };
    //! for performance only
    Integer.prototype.divideInteger = function(x) {
        var y = this;
        var a = x.value;
        var b = y.value;
        //if (a == b) { // for performance
        //  return Expression.ONE;
        //}
        if (SmallBigInt.toNumber(b) === 0) {
            //TODO: fix?
            throw new TypeError("ArithmeticException");
        }
        if (typeof b === "number" && b === 1) {
            return x; //!!!
        }
        var q = SmallBigInt.divide(a, b);
        var r = SmallBigInt.subtract(a, SmallBigInt.multiply(q, b));
        if (SmallBigInt.toNumber(r) === 0) {
            return new Integer(q);
        }
        var g = SmallBigInt.BigInt(bigIntGCDWrapper(r, b));
        //if (BigInteger.notEqual(g, Expression.ONE.value)) {
        a = SmallBigInt.divide(a, g);
        b = SmallBigInt.divide(b, g);
        //}
        if (SmallBigInt.toNumber(b) < 0) {
            a = SmallBigInt.unaryMinus(a);
            b = SmallBigInt.unaryMinus(b);
        }
        return /*BigInteger.equal(b, Expression.ONE.value) ? new Integer(a) : */ new Division(new Integer(a), new Integer(b));
    };
    Integer.prototype.truncatingDivide = function(y) {
        if (y.equals(Expression.ONE)) {
            return this;
        }
        return y.truncatingDivideInteger(this);
    };
    Integer.prototype.truncatingDivideInteger = function(x) {
        var y = this;
        return new Integer(SmallBigInt.divide(x.value, y.value));
    };
    Integer.prototype.isDivisibleBy = function(y) {
        return y.isDivisibleByInteger(this);
    };
    Integer.prototype.isDivisibleByInteger = function(x) {
        return x.remainder(this).equals(Expression.ZERO);
    };
    Integer.prototype.remainder = function(y) {
        return y.remainderInteger(this);
    };
    Integer.prototype.remainderInteger = function(x) {
        var y = this;
        var r = SmallBigInt.remainder(x.value, y.value);
        return r === 1 ? Expression.ONE : new Integer(r);
    };
    Integer.prototype.primeFactor = function() {
        return integerPrimeFactor(this);
    };
    Integer.prototype.toNumber = function() {
        return SmallBigInt.toNumber(this.value);
    };
    Integer.prototype.toBigInt = function() {
        return this.value;
    };
    Integer.prototype.toString = function(options) {
        return this.value.toString();
    };
    Integer.prototype.valueOf = function() {
        console.error("!");
        //throw new TypeError("");
        return this;
    };
    Integer.prototype.leftShift = function(n) {
        return new Integer(SmallBigInt.leftShift(this.value, n));
    };

    Integer.fromNumber = function(n) {
        return new Integer(SmallBigInt.BigInt(n));
    };
    Integer.fromString = function(s) {
        return new Integer(SmallBigInt.BigInt(s));
    };
    Integer.fromBigInt = function(i) {
        return new Integer(SmallBigInt.BigInt(i));
    };

    Expression.ZERO = Integer.fromNumber(0);
    Expression.ONE = Integer.fromNumber(1);
    Expression.TWO = Integer.fromNumber(2);
    Expression.TEN = Integer.fromNumber(10);

    Expression.Matrix = function(matrix) {
        //Expression.call(this);
        this.matrix = matrix;
    };

    Expression.Matrix.fromArray = function(rows) {
        return new Expression.Matrix(Matrix.padRows(rows, null));
    };

    Expression.Matrix.prototype = Object.create(Expression.prototype);

    Expression.Matrix.prototype.augment = function(other) {
        if (other instanceof Expression.IdentityMatrix) {
            return new Expression.Matrix(this.matrix.augment(Matrix.I(this.matrix.cols())));
        }
        return new Expression.Matrix(this.matrix.augment(other.matrix));
    };

    Expression.Matrix.prototype.equals = function(x) {
        //!new 2019-12-03
        if (x === Expression.ZERO) {
            return this.matrix.isSquare() && this.matrix.eql(this.matrix.map(function(e, i, j) {
                return Expression.ZERO;
            }));
        }
        //!
        if (!(x instanceof Expression.Matrix)) {
            return false;
        }
        return this.matrix.eql(x.matrix);
    };

    Expression.Matrix.prototype.compare4Multiplication = function(y) {
        if (y instanceof Expression.Matrix) {
            return 0;
        }
        if (y instanceof MatrixSymbol) {
            // https://math.stackexchange.com/a/1698005/116680
            if (this.matrix.isSquare() && this.matrix.isDiagonal()) { //?
                var element = this.matrix.e(0, 0);
                if (this.matrix.eql(Matrix.Zero(this.matrix.rows(), this.matrix.cols()).map(function(e, i, j) {
                        return i === j ? element : Expression.ZERO;
                    }))) {
                    return +1;
                }
            }
            return -1;
        }
        return +1;
    };
    Expression.Matrix.prototype.compare4MultiplicationNthRoot = function(x) {
        return +1;
    };

    Expression.Matrix.prototype.multiply = function(y) {
        return y.multiplyMatrix(this);
    };
    Expression.prototype.multiplyMatrix = function(x) {
        var t = getIdentityMatrixCoefficient(this);
        if (t != undefined) {
            return new Expression.Matrix(x.matrix.scale(t));
        }
        if (x.equals(Expression.ZERO)) { //!TODO: TEST, TODO: sizes are lost
            return x;
        }
        return this.multiplyExpression(x);
    };
    Expression.Matrix.prototype.multiplyExpression = function(x) {
        var t = getIdentityMatrixCoefficient(x);
        if (t != undefined) {
            return new Expression.Matrix(this.matrix.scale(t));
        }
        return Expression.prototype.multiplyExpression.call(this, x);
    };
    Expression.Matrix.prototype.multiplyMatrix = function(x) {
        if (Expression.callback != undefined) {
            Expression.callback(new Expression.Event("multiply", x, this));
        }
        return new Expression.Matrix(x.matrix.multiply(this.matrix));
    };
    Expression.Matrix.prototype.compare4MultiplicationSymbol = function(x) {
        return +1;
    };
    Expression.Matrix.prototype.multiplyDivision = Expression.Matrix.prototype.multiplyExpression;
    Expression.Matrix.prototype.add = function(y) {
        return y.addMatrix(this);
    };
    Expression.Matrix.prototype.addMatrix = function(x) {
        if (Expression.callback != undefined) {
            Expression.callback(new Expression.Event("add", x, this));
        }
        return new Expression.Matrix(x.matrix.add(this.matrix));
    };

    var isScalar = function(x) {
        if (x instanceof Integer) {
            return true;
        }
        if (x instanceof Expression.Complex) {
            return true;
        }
        if (x instanceof MatrixSymbol) {
            return false;
        }
        if (x instanceof Expression.ExpressionWithPolynomialRoot) {
            return isScalar(x.e);
        }
        if (x instanceof Expression.Symbol) {
            return true;
        }
        if (x instanceof BinaryOperation) {
            return isScalar(x.a) && isScalar(x.b);
        }
        if (x instanceof Negation) {
            return isScalar(x.b);
        }
        if (x instanceof Expression.Function) {
            return isScalar(x.a);
        }
        if (x instanceof Expression.NonSimplifiedExpression) { //TODO: ?
            return isScalar(x.unwrap());
        }
        return false; //?
    };

    Expression.isScalar = isScalar;

    var getIdentityMatrixCoefficient = function(x) {
        var t = undefined;
        if (x instanceof Multiplication && x.b instanceof IdentityMatrix) {
            t = x.a;
        } else if (x instanceof IdentityMatrix) {
            t = Expression.ONE;
        } else if (isScalar(x)) {
            t = x;
        } else if (x instanceof Addition) {
            if (Expression.has(x, IdentityMatrix)) { //TODO: fix
                var ca = getIdentityMatrixCoefficient(x.a);
                var cb = getIdentityMatrixCoefficient(x.b);
                if (ca != undefined && cb != undefined) {
                    t = ca.add(cb);
                }
            }
        }
        return t;
    };

    Expression.prototype.addMatrix = function(x) {
        var t = getIdentityMatrixCoefficient(this);
        if (t != undefined) {
            //?
            if (x.matrix.isSquare()) {
                return new Expression.Matrix(Matrix.I(x.matrix.rows()).scale(t)).add(x);
            } else {
                throw new RangeError("NonSquareMatrixException");
            }
        }
        return this.addExpression(x);
    };
    Expression.Matrix.prototype.addExpression = function(x) {
        var t = getIdentityMatrixCoefficient(x);
        if (t != undefined) {
            //?
            if (this.matrix.isSquare()) {
                return this.add(new Expression.Matrix(Matrix.I(this.matrix.rows()).scale(t)));
            } else {
                throw new RangeError("NonSquareMatrixException");
            }
        }
        return Expression.prototype.addExpression.call(this, x);
    };

    Expression.Matrix.prototype.toString = function(options) {
        return this.matrix.toString(setTopLevel(true, options));
    };

    Expression.Matrix.prototype.isExact = function() {
        return this.matrix.isExact();
    };

    function BinaryOperation(a, b) {
        //Expression.call(this);
        this.a = a;
        this.b = b;
    }

    BinaryOperation.prototype = Object.create(Expression.prototype);

    BinaryOperation.prototype.isNegation = function() {
        // TODO: What about NonSimplifiedExpression(s) ?
        //if (this instanceof Multiplication && this.a instanceof NonSimplifiedExpression && this.a.e instanceof Integer && this.a.e.equals(Expression.ONE.negate())) {
        //  return true;
        //}
        return (this instanceof Multiplication && this.a instanceof Integer && this.a.equals(Expression.ONE.negate()));
    };

    var setTopLevel = function(isTopLevel, options) {
        return options == undefined ? {
            isTopLevel: isTopLevel
        } : Object.assign({}, options, {
            isTopLevel: isTopLevel
        });
    };

    Expression.setTopLevel = setTopLevel;

    BinaryOperation.prototype.toString = function(options) {
        //if (this instanceof Division && this.isNegative()) {
        //  return '-' + this.negateCarefully().toString(options);
        //}
        var a = this.a;
        var b = this.b;
        var isSubtraction = false;
        // TODO: check
        /*
        if (Expression.simplification && this instanceof Addition && a.isNegative()) {
          var tmp = b;
          b = a;
          a = tmp;
        }*/

        if (this instanceof Addition && b.isNegative()) {
            isSubtraction = true;
            b = b.negateCarefully(); //?
        }
        var fa = a.getPrecedence() + (a.isRightToLeftAssociative() ? -1 : 0) < this.getPrecedence();
        var fb = this.getPrecedence() + (this.isRightToLeftAssociative() ? -1 : 0) >= b.getPrecedence();
        if (options != undefined && options.isTopLevel != undefined && options.isTopLevel === false) {
            fa = fa || a.isUnaryPlusMinus();
        }
        fb = fb || b.isUnaryPlusMinus(); // 1*-3 -> 1*(-3)
        fb = fb || (this.unwrap() instanceof Exponentiation && b.unwrap() instanceof Exponentiation); // 2^3^4
        fa = fa || (this.unwrap() instanceof Exponentiation && a.unwrap() instanceof Expression.Function); // cos(x)^(2+3)
        var s = isSubtraction ? "-" : this.getS();
        //TODO: fix spaces (matrix parsing)
        if (this.isNegation()) {
            // assert(fa === false);
            return "-" + (fb ? "(" : "") + b.toString(setTopLevel(fb, options)) + (fb ? ")" : "");
        }
        return (fa ? "(" : "") + a.toString(setTopLevel(fa || options == undefined || options.isTopLevel, options)) + (fa ? ")" : "") +
            s +
            (fb ? "(" : "") + b.toString(setTopLevel(fb, options)) + (fb ? ")" : "");
    };

    //?
    Expression.prototype.unwrap = function() {
        return this;
    };

    function Exponentiation(a, b) {
        BinaryOperation.call(this, a, b);
    }

    Exponentiation.prototype = Object.create(BinaryOperation.prototype);

    //TODO: remove - ?
    Exponentiation.prototype.compare4Multiplication = function(y) {
        return y.compare4MultiplicationExponentiation(this);
    };
    Exponentiation.prototype.compare4MultiplicationInteger = function(x) {
        return -1;
    };

    Exponentiation.prototype.compare4MultiplicationExponentiation = function(x) {
        var y = this;
        return getBase(x).compare4Multiplication(getBase(y)) || getExponent(x).compare4Multiplication(getExponent(y));
    };
    BinaryOperation.prototype.compare4MultiplicationExponentiation = function() {
        return -1; //TODO: !?
    };


    function Multiplication(a, b) {
        BinaryOperation.call(this, a, b);
    }

    Multiplication.prototype = Object.create(BinaryOperation.prototype);

    Multiplication.prototype.multiply = function(y) {
        return y.multiplyExpression(this);
    };
    //TODO:
    var compare4Multiplication2 = function(x, y) { //TODO: fix

        //  && x.n !== y.n
        if (x instanceof NthRoot && y instanceof NthRoot) { //TODO: fix
            var test = x.multiply(y);
            // instanceof is needeed to avoid ExpressionWithPolynomialRoot#equals, which cause an infinite loop
            if (test instanceof Expression.Multiplication) {
                if (test.equals(new Expression.Multiplication(x, y))) {
                    return -1;
                }
                if (test.equals(new Expression.Multiplication(y, x))) {
                    return +1;
                }
            }
            return 0;
        }
        /*
            //!2019-04-22
            if (x instanceof NthRoot && y instanceof NthRoot && x.n === y.n) {//TODO: fix
              if (x.a instanceof Integer && y.a instanceof Integer) {
                return 0;
              }
              if (x.a instanceof Addition && y.a instanceof Integer) {
                return 0;//TODO: fix
              }
              if (x.a instanceof Integer && y.a instanceof Addition) {
                return 0;//TODO: fix
              }
              // -(2^0.5+1)^0.5*(2*2^0.5+2)^0.5
              if (x.a instanceof Addition && y.a instanceof Addition) {
                return 0;//TODO: fix
              }
              // 3 and 3^n
              return compare4Multiplication(x.a, y.a);
            }
          */
        if (x instanceof Integer && y instanceof Exponentiation) {
            return -1; //?
        }
        if (x instanceof Exponentiation && y instanceof Integer) {
            return +1; //?
        }
        if (x instanceof Expression.Complex && y instanceof Exponentiation) {
            return -1; //?
        }
        if (x instanceof Exponentiation && y instanceof Expression.Complex) {
            return +1; //?
        }

        return compare4Multiplication(getBase(x), getBase(y));
    };

    function Negation(b) {
        //Expression.call(this);
        this.b = b;
    }

    Negation.prototype = Object.create(Expression.prototype);

    Expression.prototype.equalsNegation = function(x) {
        return false;
    };
    Negation.prototype.equalsNegation = function(b) {
        return this.b.equals(b.b);
    };
    Negation.prototype.equals = function(b) {
        return b.equalsNegation();
    };
    Negation.prototype.toString = function(options) {
        var b = this.b;
        var fb = this.getPrecedence() + (this.isRightToLeftAssociative() ? -1 : 0) >= b.getPrecedence();
        fb = fb || b.isUnaryPlusMinus();
        // assert(fa === false);
        return "-" + (fb ? "(" : "") + b.toString(setTopLevel(fb, options)) + (fb ? ")" : "");
    };

    function Subtraction(a, b) {
        BinaryOperation.call(this, a, b);
    }

    Subtraction.prototype = Object.create(BinaryOperation.prototype);

    Subtraction.prototype.getS = function() {
        return "-";
    };

    //

    function Addition(a, b) {
        BinaryOperation.call(this, a, b);
    }

    Addition.prototype = Object.create(BinaryOperation.prototype);
    Addition.prototype.multiply = function(y) {
        return y.multiplyAddition(this);
    };
    var _multiplyAddition = function(value, addition, fromLeft) {
        // optimization (to avoid stack overflow when addition has a lot of summands (?))
        var result = [];
        for (var iterators = addition.summands()[globalThis.Symbol.iterator](), s = iterators.next().value; s != null; s = iterators.next().value) {
            var v = fromLeft ? value.multiply(s) : s.multiply(value);
            result.push(v);
        }
        return _sum(result);
    };
    var _sum = function(summands) {
        var k = summands.length;
        if (k === 0) {
            return Expression.ZERO;
        }
        while (k > 1) {
            for (var i = 0; 2 * i < k; i += 1) {
                summands[i] = 2 * i + 1 < k ? summands[2 * i + 1].add(summands[2 * i]) : summands[2 * i];
            }
            k = Math.ceil(k / 2);
        }
        return summands[0];
    };
    Expression.prototype.multiplyAddition = function(x) {
        return _multiplyAddition(this, x, false);
        //return x.a.multiply(this).add(x.b.multiply(this));
    };
    Addition.prototype.multiplyExpression = function(x) {
        return _multiplyAddition(x, this, true);
        //return x.multiply(this.a).add(x.multiply(this.b));
    };

    function Division(a, b) {
        BinaryOperation.call(this, a, b);
    }

    Division.prototype = Object.create(BinaryOperation.prototype);
    Division.prototype.multiply = function(y) {
        return y.multiplyDivision(this);
    };
    Expression.prototype.multiplyDivision = function(x) {
        return x.a.multiply(this).divide(x.b);
    };
    Division.prototype.multiplyDivision = function(x) { // for performance
        return x.a.multiply(this.a).divide(x.b.multiply(this.b));
    };
    Division.prototype.multiplyExpression = function(x) {
        return x.multiply(this.a).divide(this.b);
    };
    Division.prototype.add = function(y) {
        return y.addDivision(this);
    };
    Expression.prototype.addDivision = function(x) {
        return x.a.add(this.multiply(x.b)).divide(x.b);
    };
    Division.prototype.addDivision = function(x) {
        if (x.b.equals(this.b)) {
            return x.a.add(this.a).divide(this.b);
        }
        //return BinaryOperation.prototype.addDivision.call(this, x);
        return x.a.multiply(this.b).add(x.b.multiply(this.a)).divide(x.b.multiply(this.b));
    };
    Division.prototype.addExpression = function(x) {
        return x.multiply(this.b).add(this.a).divide(this.b);
    };
    Division.prototype.divide = function(y) {
        return this.a.divide(this.b.multiply(y));
    };
    Division.prototype.divideExpression = function(x) {
        return x.multiply(this.b).divide(this.a);
    };
    //? not needed, but looks appropriate
    Division.prototype.multiplyAddition = function(x) {
        return x.multiply(this.a).divide(this.b);
    };

    // TODO: move
    Expression.prototype.equals = function(b) {
        throw new RangeError(); //?
    };
    Expression.prototype.equalsInteger = function(x) {
        if (this instanceof Expression.ExpressionWithPolynomialRoot || this instanceof Expression.ExpressionPolynomialRoot) {
            return this.equals(x);
        }
        return false;
    };
    var _isNumberTypeUsedForSmall = SmallBigInt.BigInt(0) === 0;
    Integer.prototype.equals = function(y) {
        // TODO: fix
        //if (y == undefined) {
        //  return false;
        //}
        if (y === Expression.ZERO) {
            if (_isNumberTypeUsedForSmall) {
                return typeof this.value === "number" && this.value === 0;
            }
        }
        if (y === Expression.ONE) {
            if (_isNumberTypeUsedForSmall) {
                return typeof this.value === "number" && this.value === 1;
            }
        }
        return y.equalsInteger(this);
    };
    Integer.prototype.equalsInteger = function(x) {
        return x.compareTo(this) === 0;
        // performance:
        //return x.value == this.value;
    };
    Expression.Symbol.prototype.equals = function(b) {
        return b instanceof Expression.Symbol && this.symbol === b.symbol;
    };
    BinaryOperation.prototype.equals = function(b) {
        if (b instanceof Addition && Expression.has(b, Expression.ExpressionPolynomialRoot)) { // not e^(alpha) or -1 * e^(alpha)
            //console.assert(false, '!!!');
            return this.subtract(b).equals(Expression.ZERO);
        }
        if (b instanceof Addition && this instanceof Multiplication && Expression.has(this, Expression.ExpressionPolynomialRoot) ||
            this instanceof Addition && b instanceof Multiplication && Expression.has(b, Expression.ExpressionPolynomialRoot)) { // alpha * x and sqrt(2) * x + sqrt(3) * x
            //console.assert(false, '!!!');
            return this.subtract(b).equals(Expression.ZERO);
        }
        if (this instanceof Addition && b instanceof Addition) {
            //HACK TO not call Expression.has each time!!! (three lines before)
            var x = this;
            var y = b;
            var i = x.summands();
            var j = y.summands();
            var a = i.next().value;
            var b = j.next().value;
            while (a != null && b != null) {
                if (!a.equals(b)) {
                    return false;
                }
                a = i.next().value;
                b = j.next().value;
            }
            return a != null ? false : (b != null ? false : true);
        }
        if (b instanceof Expression.ExpressionWithPolynomialRoot || b instanceof Expression.ExpressionPolynomialRoot) {
            //console.assert(false, '!!!');
            return b.equals(this);
        }
        return b instanceof BinaryOperation && this.getS() === b.getS() && this.a.equals(b.a) && this.b.equals(b.b);
    };

    function MatrixSymbol(symbol) { //TODO: only for square matrix !!!
        Expression.Symbol.call(this, symbol);
    }
    MatrixSymbol.prototype = Object.create(Expression.Symbol.prototype);

    Exponentiation.prototype.inverse = function() {
        return this.pow(Expression.ONE.negate());
    };
    MatrixSymbol.prototype.inverse = function() { //TODO: only for square matrix !!!
        return this.pow(Expression.ONE.negate());
    };
    MatrixSymbol.prototype.compare4Multiplication = function(y) {
        return y.compare4MultiplicationMatrixSymbol(this);
    };
    Expression.prototype.compare4MultiplicationMatrixSymbol = function(x) {
        return +1;
    };
    Addition.prototype.compare4MultiplicationMatrixSymbol = function(x) { // (X+{{1}})*X
        return -1;
    };
    Expression.Matrix.prototype.compare4MultiplicationMatrixSymbol = function(x) {
        return x instanceof IdentityMatrix ? +1 : -1; //?
    };
    MatrixSymbol.prototype.compare4MultiplicationMatrixSymbol = function(x) {
        var c = Expression.Symbol.prototype.compare4MultiplicationSymbol.call(this, x);
        return c === +1 ? -1 : c;
    };
    MatrixSymbol.prototype.compare4MultiplicationSymbol = function(x) {
        return -1;
    };
    MatrixSymbol.prototype.equals = function(b) {
        return b instanceof MatrixSymbol && Expression.Symbol.prototype.equals.call(this, b);
    };
    MatrixSymbol.prototype.transpose = function() {
        // quick solution:
        return new Expression.Exponentiation(this, new Expression.Symbol("T")); // TODO: fix
    };
    //...

    Expression.MatrixSymbol = MatrixSymbol;

    function IdentityMatrix(symbol) {
        MatrixSymbol.call(this, symbol);
    }
    IdentityMatrix.prototype = Object.create(MatrixSymbol.prototype);
    //IdentityMatrix.prototype.multiply = function (y) {
    //  return y.multiplyIdentityMatrix(this);
    //};

    //TODO: move to MatrixSymbol - ?
    IdentityMatrix.prototype.multiplyAddition = function(x) {
        if (isScalar(x)) {
            return new Multiplication(x, this);
        }
        return Expression.prototype.multiplyAddition.call(this, x);
    };

    //Expression.prototype.multiplyIdentityMatrix = function (x) {
    //  return this.multiplyExpression(x);
    //};
    //IdentityMatrix.prototype.multiplyIdentityMatrix = function (x) {
    //  return new IdentityMatrix(this.symbol);
    //};
    IdentityMatrix.prototype.addMatrix = function(x) {
        return x.add(new Expression.Matrix(Matrix.I(x.matrix.rows())));
    };
    IdentityMatrix.prototype.add = function(y) {
        return y.addIdentityMatrix(this);
    };
    Expression.prototype.addIdentityMatrix = function(x) {
        return this.addExpression(x); //?
    };
    Expression.Matrix.prototype.addIdentityMatrix = function(x) {
        return new Expression.Matrix(Matrix.I(this.matrix.rows())).add(this);
    };

    IdentityMatrix.prototype.multiplyDivision = function(x) {
        if (isScalar(x)) {
            return new Multiplication(x, this);
        }
        return Expression.prototype.multiplyExpression.call(this, x);
    };

    IdentityMatrix.prototype.compare4MultiplicationMatrixSymbol = function(x) {
        var y = this;
        return x instanceof IdentityMatrix ? (x.symbol < y.symbol ? -1 : (y.symbol < x.symbol ? +1 : 0)) : +1;
    };

    Expression.IdentityMatrix = IdentityMatrix;

    BinaryOperation.prototype.getS = function() {
        throw new TypeError("abstract");
    };
    Exponentiation.prototype.getS = function() {
        return "^";
    };
    Multiplication.prototype.getS = function() {
        return "*";
    };
    Negation.prototype.getS = function() {
        return "-";
    };
    Addition.prototype.getS = function() {
        return "+";
    };
    Division.prototype.getS = function() {
        return "/";
    };

    // unary argument function, fix Expression.Function#compare4Addition for multiple argument functions (!)
    Expression.Function = function(name, a) {
        //Expression.call(this);
        this.name = name;
        this.a = a;
    };
    Expression.Function.prototype = Object.create(Expression.prototype);
    Expression.Function.prototype.toString = function(options) {
        //?
        return this.name + "(" + this.a.toString(setTopLevel(true, options)) + ")";
    };
    Expression.Function.prototype.equals = function(b) {
        return b instanceof Expression.Function && this.name === b.name && this.a.equals(b.a);
    };

    Negation.prototype.isUnaryPlusMinus = function() {
        return true;
    };
    BinaryOperation.prototype.isUnaryPlusMinus = function() {
        return this.isNegation();
    };
    Expression.Function.prototype.isUnaryPlusMinus = function() {
        return false; //!
    };
    Expression.prototype.isUnaryPlusMinus = function() {
        return false;
    };
    Integer.prototype.isUnaryPlusMinus = function() { //?
        return this.compareTo(Expression.ZERO) < 0;
    };

    Negation.prototype.getPrecedence = function() {
        return precedence.unary["-"];
    };
    BinaryOperation.prototype.getPrecedence = function() {
        return this.isNegation() ? precedence.unary["-"] : precedence.binary[this.getS()];
    };
    Expression.Function.prototype.getPrecedence = function() {
        return precedence.unary["-"];
    };
    Expression.prototype.getPrecedence = function() {
        return 1000;
    };
    Integer.prototype.getPrecedence = function() { //?
        return this.compareTo(Expression.ZERO) < 0 ? precedence.unary["-"] : 1000;
    };

    //! Note: this function is more for canonical order(?) or output(?), to check if a numeric expression is negative you should use Expression#sign()
    Expression.prototype.isNegative = function() {
        var x = this;
        if (x instanceof Integer) {
            return x.compareTo(Expression.ZERO) < 0;
        }
        if (x instanceof Expression.Complex) {
            return x.real.compareTo(Expression.ZERO) < 0 || (x.real.compareTo(Expression.ZERO) === 0 && x.imaginary.compareTo(Expression.ZERO) < 0);
        }
        if (x instanceof Addition) {
            var e = x;
            do {
                e = e.a;
            } while (e instanceof Addition);
            return e.isNegative();
            //return x.a.isNegative();
            //return x.a.isNegative() && x.b.isNegative();
        }
        if (x instanceof Multiplication) {
            return x.a.isNegative() !== x.b.isNegative();
        }
        if (x instanceof Division) {
            return x.a.isNegative() !== x.b.isNegative();
        }
        if (x instanceof Negation) {
            //return !x.b.isNegative();
            return true;
        }
        if (x instanceof Expression.Radians) {
            return x.value.isNegative();
        }
        return false;
    };

    //TODO: remove
    Expression.prototype.negateCarefully = function() {
        if (this instanceof Integer) {
            return this.negate();
        }
        if (this instanceof Addition) {
            return new Addition(this.a.negateCarefully(), this.b.negateCarefully());
        }
        if (this instanceof Multiplication) {
            return this.b.isNegative() ? new Multiplication(this.a, this.b.negateCarefully()) : (this.a.negateCarefully().equals(Expression.ONE) ? this.b : new Multiplication(this.a.negateCarefully(), this.b));
        }
        if (this instanceof Division) {
            return this.b.isNegative() ? new Division(this.a, this.b.negateCarefully()) : new Division(this.a.negateCarefully(), this.b);
        }
        if (this instanceof Negation) {
            return this.b; //!
        }
        return this.negate();
    };

    // https://en.wikipedia.org/wiki/Nth_root#Simplified_form_of_a_radical_expression
    // https://en.wikipedia.org/wiki/Factorization#Sum.2Fdifference_of_two_cubes

    function NthRoot(name, a, n) {
        Expression.Function.call(this, name, a);
        this.n = n; //TODO: remove
        this.degree = n;
        this.radicand = a;
        //this.index = n;
        console.assert(name === (n === 2 ? "sqrt" : n + "-root")); // otherwise it is not unary argument function (!)
    }

    NthRoot.prototype = Object.create(Expression.Function.prototype);

    NthRoot.prototype.compare4Multiplication = function(y) {
        return y.compare4MultiplicationNthRoot(this);
    };
    NthRoot.prototype.compare4MultiplicationInteger = function(x) {
        return -1;
    };
    NthRoot.prototype.compare4MultiplicationSymbol = function(x) {
        return +1;
    };
    NthRoot.prototype.compare4MultiplicationNthRoot = function(x) {
        return x.n < this.n ? -1 : (x.n > this.n ? +1 : 0);
    };

    NthRoot.prototype.toString = function(options) {
        var fa = this.a.getPrecedence() <= this.getPrecedence();
        return (fa ? "(" : "") + this.a.toString(setTopLevel(fa || options == undefined || options.isTopLevel, options)) + (fa ? ")" : "") + "^" + (this.n === 2 ? "0.5" : "(1/" + this.n + ")");
    };

    var isCommutative = function(e) {
        return !Expression.has(e, Expression.Matrix) && !Expression.has(e, Expression.MatrixSymbol);
    };

    NthRoot.prototype.getDegree = function() {
        console.error('deprecated');
        return this.n;
    };
    NthRoot.prototype.multiplyExpression = function(x) {
        if (x instanceof Multiplication && isCommutative(this) && this.a instanceof Expression.Integer) { //TODO: fix
            for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
                if (y instanceof NthRoot && y.a instanceof Expression.Integer && compare4Multiplication2(y, this) === 0) {
                    var multiplied = false;
                    var result = Expression.ONE;
                    for (var iteratory1 = x.factors()[globalThis.Symbol.iterator](), y1 = iteratory1.next().value; y1 != null; y1 = iteratory1.next().value) {
                        var y2 = y1;
                        if (!multiplied && y === y1) {
                            y2 = y.multiply(this);
                            multiplied = true;
                        }
                        result = result.multiply(y2);
                    }
                    return result;
                }
            }
        }
        return Expression.prototype.multiplyExpression.call(this, x);
    };

    NthRoot.prototype.equals = function(b) {
        if (b instanceof Expression.ExpressionWithPolynomialRoot || b instanceof Expression.ExpressionPolynomialRoot) {
            return b.equals(this);
        }
        return Expression.Function.prototype.equals.call(this, b);
    };

    //function isPrime(n) {
    //if (typeof n === "bigint") {//TODO: ?
    //  return n === BigInt(primeFactor(BigInt(n.toString())).toString());
    //}
    //return n == primeFactor(n);
    //}

    function isPerfectCube(n) {
        return SmallBigInt.toNumber(SmallBigInt.subtract(SmallBigInt.exponentiate(n._integerNthRoot(3).toBigInt(), SmallBigInt.BigInt(3)), n.toBigInt())) === 0;
    }

    function isPerfectSquare(n) {
        return SmallBigInt.toNumber(SmallBigInt.subtract(SmallBigInt.exponentiate(n._integerNthRoot(2).toBigInt(), SmallBigInt.BigInt(2)), n.toBigInt())) === 0;
    }
    var makeRoot = function(i, n) {
        return n === 1 ? i : (n === 2 ? new SquareRoot(i) : new NthRoot(n + "-root", i, n));
    };
    NthRoot.makeRoot = makeRoot;

    Expression.prototype._nthRoot = function(n) {
        if (typeof n === "number") {
            if (n < 1 || n > Number.MAX_SAFE_INTEGER || Math.floor(n) !== n) {
                throw new RangeError("NotSupportedError");
            }
        } else {
            if (!(this instanceof Expression.Matrix)) {
                throw new RangeError("NotSupportedError");
            }
        }
        var x = this;

        if (n === 2) {
            if (x instanceof Addition) {
                if ((x.a instanceof SquareRoot || x.a instanceof Multiplication && x.a.a instanceof Integer && x.a.b instanceof SquareRoot) && x.b instanceof Integer) {
                    // (5^0.5+3)/2 or (-5^0.5+3)/2
                    var u = x.a;
                    var v = x.b;
                    // (a+b)^2 = aa+2ab+bb = u+v
                    // 2ab = u, b = u/(2a)
                    // aa+bb = v, 4aaaa - 4vaa + uu = 0
                    // t = sqrt(v*v-u*u);
                    // a = sqrt(v+t)/sqrt(2)
                    // b = sqrt(v-t)/sqrt(2)
                    var tt = v.multiply(v).subtract(u.multiply(u));
                    if (tt instanceof Integer && !isPerfectSquare(tt.abs())) {
                        tt = null;
                    }
                    var t = tt instanceof Integer && tt.compareTo(Expression.ZERO) >= 0 ? tt.squareRoot() : undefined;
                    if (t != undefined && (t instanceof Integer)) { //?
                        var aa = v.add(t);
                        var a = aa.compareTo(Expression.ZERO) >= 0 ? aa.squareRoot().divide(Expression.TWO.squareRoot()) : undefined;
                        if (a != undefined) {
                            var b = u.divide(Expression.TWO.multiply(a));
                            return a.add(b);
                        }
                    }
                }
                //TODO: https://brownmath.com/alge/nestrad.htm  - √(√392 + √360)
                if ((x.a instanceof SquareRoot || x.a instanceof Multiplication && x.a.a instanceof Integer && x.a.b instanceof SquareRoot) &&
                    (x.b instanceof SquareRoot || x.b instanceof Multiplication && x.b.a instanceof Integer && x.b.b instanceof SquareRoot)) {
                    var a = x.a;
                    var b = x.b;
                    var aa = a.multiply(a);
                    var bb = b.multiply(b);
                    var g = aa.gcd(bb).squareRoot();
                    if (!g.equals(Expression.ONE)) {
                        var v = a.divide(g).add(b.divide(g)).squareRoot().multiply(g.squareRoot());
                        if (typeof hit === "function") {
                            hit({
                                rootFromAddition: x.toString()
                            });
                        }
                        return v;
                    }
                }
                if (Expression._isPositive(x)) { //?
                    var tmp = getConjugateFactor(x);
                    if (tmp.p != null) {
                        var t = tmp.p.toExpression()._nthRoot(tmp.degree);
                        var polynomial = getPolynomialRelativeToNthRoot(x, tmp.p, tmp.degree);
                        var u = polynomial.getCoefficient(1).multiply(t.toExpression());
                        var v = polynomial.getCoefficient(0);
                        var D = v.multiply(v).subtract(u.multiply(u));
                        var f1 = function(aa) {
                            var tmp = aa.divide(getConstant(aa));
                            var c = Expression.getConjugate(tmp);
                            return c != null && c.multiply(tmp) instanceof Integer && isPerfectSquare(c.multiply(tmp).abs());
                        };
                        if (D instanceof Integer || f1(D)) { //TODO: FIX
                            var sD = D.squareRoot();
                            var aa = v.add(sD);
                            if (aa instanceof Integer || f1(aa)) {
                                //console.log('aa', aa + '');
                                var a = aa.squareRoot().divide(Expression.TWO.squareRoot());
                                var b = u.divide(Expression.TWO.multiply(a));
                                return a.add(b);
                            }
                        }
                    }
                } else if (Expression._isPositive(x.negate()) && n === 2) {
                    return Expression.I.multiply(x.negate()._nthRoot(2));
                }
            }
        }
        if (n === 3) { //? new: 2019-08-18
            if (x instanceof Addition) {
                if ((x.a instanceof SquareRoot && x.a.a instanceof Integer || x.a instanceof Multiplication && x.a.a instanceof Integer && x.a.b instanceof SquareRoot) && x.b instanceof Integer) {
                    // (5^0.5+3)/2 or (-5^0.5+3)/2
                    var u = x.a;
                    var v = x.b;
                    var d = u.multiply(u).subtract(v.multiply(v));
                    if (isPerfectCube(d)) { //?
                        // (a+b)^3 = aaa+3aab+3bba+bbb = u+v
                        // aaa+3bba = v, bb=(v-aaa)/(3a)
                        // 3aab+bbb = u, b(3aa+bb)=u, b=u/(3aa+bb), bb=u**2/(3aa+bb)**2
                        // (9aaa+(v-aaa))**2*(v-aaa) = 27*aaa*u**2

                        // t = aaa
                        // (9t+(v-t))**2*(v-t) = 27*t*u**2

                        var t = new Expression.Symbol('t');
                        //var eq = ExpressionParser.parse('(9t+(v-t))**2*(v-t) - 27*t*u**2', new ExpressionParser.Context(function (id) {
                        //  return id === 'v' ? v : (id === 'u' ? u : (id === 't' ? t : undefined));
                        //})).simplify();
                        var NINE = Expression.Integer.fromNumber(9);
                        var TWENTY_SEVEN = Expression.Integer.fromNumber(27);
                        var eq = Expression.pow(NINE.multiply(t).add(v.subtract(t)), 2).multiply(v.subtract(t)).subtract(TWENTY_SEVEN.multiply(t).multiply(Expression.pow(u, 2)));
                        var p = Polynomial.toPolynomial(eq, t);
                        p = p.scale(p.getContent().inverse());
                        var t = p.doRationalRootTest();
                        if (t != null) {
                            var a = t._nthRoot(3);
                            var b = u.divide(u.abs()).multiply(v.subtract(t).divide(Expression.Integer.fromNumber(3).multiply(a))._nthRoot(2));
                            return a.add(b);
                        }
                    }
                }
            }
        }

        //?
        if (x instanceof NthRoot) {
            if (typeof hit === "function") {
                hit({
                    rootFromRoot: ""
                });
            }
            return x.a._nthRoot(x.n * n);
        }
        if (x instanceof Division || x instanceof Multiplication) {
            if (n % 2 !== 0 || x.a instanceof Integer && x.a.compareTo(Expression.ZERO) > 0 || // sqrt(-x) = sqrt(-1 * -1) = i * i = -1
                x.b instanceof Integer && x.b.compareTo(Expression.ZERO) > 0 || //TODO: fix
                x.a instanceof Integer && isConstant(x.b) ||
                isConstant(x) ||
                isPositive(x.a) ||
                isPositive(x.b) || // -sqrt(7)
                //isPositive(x.a.negate()) ||
                isPositive(x.b.negate())) {
                if (x instanceof Division) {
                    return x.a._nthRoot(n).divide(x.b._nthRoot(n));
                }
                if (x instanceof Multiplication) {
                    return x.a._nthRoot(n).multiply(x.b._nthRoot(n));
                }
            }
        }
        var qi = x instanceof Integer ? x : null;
        var qq = QuadraticInteger.toQuadraticInteger(x);
        // sqrt(2sqrt(2)+2) "(2*2^0.5+2)^0.5"
        // sqrt(sqrt(2)+2) "(2^0.5+1)^0.5*2^(1/4)"
        // sqrt(4sqrt(2)+4) 2*(2^0.5+1)^0.5
        // sqrt(2sqrt(2)+4) (2*2^0.5+2)^0.5*2^(1/4)

        //TODO: fix for !isPrime(qq.D)
        //if (qq != null && (isPrime(qq.D) && (qq.a / Math.gcd(qq.a, qq.b)) % qq.D == 0 || !isPrime(qq.D) && qq.a % qq.D == 0 && Math.gcd(qq.a, qq.b) % qq.D != 0)) {
        //var D = Expression.Integer.fromNumber(qq.D)._nthRoot(2);
        //return D._nthRoot(n).multiply(x.divide(D)._nthRoot(n));
        //}

        //!
        if (qq == null && x instanceof Expression.Addition) {
            if (x.a instanceof Multiplication && x.b instanceof Multiplication) {
                var g = x.a.pow(Expression.TWO).gcd(x.b.pow(Expression.TWO)).squareRoot();
                if (!g.equals(Expression.ONE)) {
                    return g._nthRoot(n).multiply(x.divide(g)._nthRoot(n));
                }
            }
        }
        //!

        if (qq != null) {
            if (n !== 2 && n % 2 === 0) {
                //TODO: check
                var tmp = x.squareRoot();
                if (!(tmp instanceof Expression.SquareRoot)) {
                    return tmp._nthRoot(n / 2);
                }
            }
            if ((n === 2 || n === 3) && qq.isValid()) { //Note: isValid should be checked here
                //if (qq.norm() === -1 * Math.pow(Math.gcd(qq.a, qq.b), 2)) {
                if (qq.isPositive()) {
                    qi = qq;
                    //!new 2020-12-31
                    if (qq.norm != null && Math.abs(Number(qq.norm().toString())) > Number.MAX_SAFE_INTEGER) {
                        qi = null; //!
                    }
                    //!
                } else {
                    return Expression.ONE.negate()._nthRoot(n).multiply(this.negate()._nthRoot(n));
                }
                //}
            }
        }
        if (qi != null) {
            x = qi; //TODO:
            if (x instanceof Integer && x.compareTo(Expression.ZERO) < 0) {
                if (n % 2 === 0) {
                    if (n === 2) { //TODO: ?
                        return Expression.I.multiply(this.negate()._nthRoot(n));
                    }
                    throw new RangeError("NotSupportedError");
                }
                return this.negate()._nthRoot(n).negate();
            }
            if (x.equals(Expression.ZERO)) {
                return this;
            }
            var roots = [];
            var i = x;
            while (!i.equals(Expression.ONE)) {
                var d = i.primeFactor();
                if (d instanceof QuadraticInteger) {
                    if (n !== 2 && n !== 3) {
                        throw new TypeError(); // "assertion"
                    }
                    //if (Math.abs(Number(d.norm().toString())) === 1) {//!new
                    //TODO: why is it here?
                    // sqrt(sqrt(2)-1) = (sqrt(2)-1)*sqrt(sqrt(2)+1)
                    if (Number(d.a.toString()) < 0 && Number(d.b.toString()) > 0 || Number(d.a.toString()) > 0 && Number(d.b.toString()) < 0) {
                        var a = (n % 2 === 0 ? d.abs() : d);
                        return x.toExpression().divide(a.toExpression()._pow(n))._nthRoot(n).multiply(a.toExpression());
                    }
                    //}
                    var s = d.norm();
                    // https://brownmath.com/alge/nestrad.htm#SurveyDoable
                    //TODO: s >= 0 - ?
                    if (Number(d.b.toString()) !== 0 && Number(d.a.toString()) !== 0 && Number(s.toString()) >= 0 && isPerfectSquare(Integer.fromBigInt(s))) {
                        if (n === 2) {
                            return x.toExpression().divide(d.toExpression())._nthRoot(2).multiply(d.toExpression()._nthRoot(2));
                        }
                    }
                }
                var ctz = i instanceof Expression.Integer && d instanceof Expression.Integer ? primeFactor._countTrailingZeros(i.value, d.value) : -1;
                var e = 0;
                if (ctz !== -1) {
                    e = ctz;
                    i = i.truncatingDivide(d._pow(ctz));
                } else {
                    if (i.isUnit()) {
                        //TODO:
                        // d should be a https://en.wikipedia.org/wiki/Fundamental_unit_(number_theory)
                        while (!i.equals(Expression.ONE)) {
                            i = i.truncatingDivide(d);
                            e += 1;
                        }
                    } else {
                        while (i.isDivisibleBy(d)) {
                            i = i.truncatingDivide(d);
                            e += 1;
                        }
                    }
                }
                //if (ctz !== -1) {
                //  console.assert(ctz === e);
                //}
                d = d.toExpression();
                var nn = n;
                if (d instanceof NthRoot) {
                    nn *= d.n;
                    d = d.a;
                }
                var t = Math.gcd(nn, e);
                nn /= t; //?
                e /= t; //?

                while (e !== 0) {
                    //var g = e;
                    //while (nn % g !== 0) {
                    //  g -= 1;
                    //}
                    var g = e >= nn ? nn : 1;

                    var e1 = Math.floor(e / g);
                    var k = Math.floor(nn / g);
                    roots.push(Object.freeze({
                        degree: k,
                        radicand: Expression.pow(d, e1)
                    }));

                    e = e - g * e1; // e = e % g;
                }
            }
            var y = Expression.ONE;
            roots.sort(function(a, b) {
                return a.degree - b.degree;
            });
            var k = -1;
            for (var i = 0; i < roots.length; i += 1) {
                if (k === -1 || roots[i].degree !== roots[k].degree) {
                    k += 1;
                    roots[k] = roots[i];
                } else {
                    roots[k] = Object.freeze({
                        degree: roots[i].degree,
                        radicand: roots[k].radicand.multiply(roots[i].radicand)
                    });
                }
            }
            roots.length = k + 1;
            //for (var j = 1; j <= n; j += 1) {
            //}
            // `for-in` loop is used to have better performance for "a sparse array"
            var f = null;
            for (var jj = 0; jj < roots.length; jj += 1) { //TODO: fix the iteration order
                var degree = roots[jj].degree;
                if (degree !== 1) {
                    var radicand = roots[jj].radicand;
                    //y = y.multiply(makeRoot(radicand, j));
                    var x = makeRoot(radicand, degree);
                    if (y !== Expression.ONE) {
                        y = new Expression.Multiplication(y, x);
                    } else {
                        y = x;
                    }
                } else {
                    f = roots[jj].radicand;
                }
            }
            if (f != null) {
                y = f.multiply(y);
            }
            return y;
        }
        if (x instanceof Expression.Matrix) {
            if (typeof hit === "function") {
                hit(n === 2 ? {
                    squareRoot: "matrix"
                } : {
                    nthRoot: "Matrix^(1/" + n + ")"
                });
            }
            var eigenvalues = Expression.getEigenvalues(x.matrix);
            var N = typeof n === "number" ? Expression.Integer.fromNumber(n) : n;
            if (eigenvalues.length === x.matrix.cols()) {
                var eigenvectors = Expression.getEigenvectors(x.matrix, eigenvalues);
                if (eigenvectors.filter(function(v) {
                        return v != null;
                    }).length === x.matrix.cols()) {
                    if (!x.matrix.isDiagonal()) {
                        if (Expression.callback != undefined) {
                            Expression.callback(new Expression.Event("nth-root-using-diagonalization", x));
                        }
                        if (Expression.callback != undefined) { //TODO: remove - ?
                            Expression.callback(new Expression.Event("diagonalize", x));
                        }
                    }
                    var tmp = Expression.diagonalize(x.matrix, eigenvalues, eigenvectors);
                    var L = tmp.L;
                    var SL = L.map(function(e, i, j) {
                        return i === j ? e.pow(Expression.ONE.divide(N)) : e;
                    });
                    return new Expression.Matrix(tmp.T.multiply(SL).multiply(tmp.T_INVERSED));
                } else {
                    if (!x.matrix.isJordanMatrix()) {
                        if (Expression.callback != undefined) {
                            Expression.callback(new Expression.Event("nth-root-using-Jordan-normal-form", x));
                        }
                        if (Expression.callback != undefined) { //TODO: remove - ?
                            Expression.callback(new Expression.Event("Jordan-decomposition", x));
                        }
                    } else {
                        if (Expression.callback != undefined) {
                            Expression.callback(new Expression.Event("Jordan-matrix-nth-root", x));
                        }
                    }
                    var rootOfJordanForm = function(J, N) {
                        var tmp = J.map(function(e, i, j) {
                            if (i > j) {
                                return Expression.ZERO;
                            }
                            if (i === j) {
                                return J.e(i, j).pow(Expression.ONE.divide(N));
                            }
                            if (J.e(i, i + 1).equals(Expression.ZERO)) {
                                return Expression.ZERO;
                            }
                            if (!J.e(i, i + 1).equals(Expression.ONE)) {
                                throw new TypeError("assertion");
                            }
                            //if (i + 1 === j) {
                            //return J.e(i, i).pow(Expression.ONE.divide(N)).divide(N.multiply(J.e(i, i)));
                            //return J.e(i, i + 1).divide(N.multiply(J.e(i, i).pow(Expression.ONE.divide(N)).pow(N.subtract(Expression.ONE))));
                            //}
                            //return new Expression.Symbol('aa_(' + (j - i) + ',' + j + ')');
                            var m = j - i;
                            for (var k = 0; k < m; k += 1) {
                                if (!J.e(j - 1 - k, j - k).equals(Expression.ONE)) { // outside of a block
                                    return Expression.ZERO;
                                }
                            }
                            // 1/n(1/n-1)(1/n-2)(1/n-3)/(4!*λ**4) * λ**(1/n)
                            var f = Expression.ONE;
                            for (var k = 0; k < m; k += 1) {
                                f = f.multiply(Expression.ONE.divide(N).subtract(Expression.Integer.fromNumber(k))).divide(Expression.Integer.fromNumber(k + 1));
                            }
                            return f.divide(J.e(i, i)._pow(m)).multiply(J.e(i, i).pow(Expression.ONE.divide(N)));
                        });

                        /*
                        for (var k = 2; k < J.cols(); k += 1) {
                          //var x = tmp.pow(N);
                          var x = new Expression.Matrix(tmp).pow(N).matrix;//!?
                          tmp = tmp.map(function (e, i, j) {
                            if (i + k === j) {
                              if (x.e(i, j).equals(Expression.ZERO)) {
                                return Expression.ZERO;
                              }
                              var s = new Expression.Symbol('aa_(' + (j - i) + ',' + j + ')');
                              var p = Polynomial.toPolynomial(x.e(i, j).getNumerator(), s);
                              if (p.getDegree() === 0) {
                                return x.e(i, j);
                              }
                              if (p.getDegree() !== 1) {
                                throw new TypeError("!");
                              }
                              var y = p.getCoefficient(0).negate().divide(p.getCoefficient(1));
                              return y;
                            }
                            return e;
                          });
                        }
                        */
                        return tmp;
                    };
                    var tmp = Expression.getFormaDeJordan(x.matrix, eigenvalues);
                    var JN = rootOfJordanForm(tmp.J, N);
                    //TODO: details - ?
                    return new Expression.Matrix(tmp.P.multiply(JN).multiply(tmp.P_INVERSED));
                }
            }
            //TODO: using Jordan normal form -?
        }
        //!2019-04-22
        if (x instanceof Exponentiation && x.a instanceof Integer && x.a.compareTo(Expression.ZERO) > 0) {
            //if (n === 2) {//TODO:
            if (x.b instanceof Expression.Symbol) {
                if (x.a instanceof Expression.Integer && integerPrimeFactor(x.a).equals(x.a)) {
                    //return new SquareRoot(x);
                    return new Expression.Exponentiation(x.a, x.b.divide(Expression.Integer.fromNumber(n)));
                }
            } else {
                return x.a.pow(x.b.divide(Expression.Integer.fromNumber(n)));
            }
            //}
        }

        //!2019-16-06
        if (x instanceof Exponentiation && x.a === Expression.E) {
            return x.a.pow(x.b.divide(Expression.Integer.fromNumber(n)));
        }
        if (x instanceof Exponentiation && getBase(x) instanceof Expression.Logarithm && getBase(x).a instanceof Expression.Integer) { //TODO: ?
            return x.a.pow(x.b.divide(Expression.Integer.fromNumber(n)));
        }
        if (x instanceof IdentityMatrix) {
            if (simplifyIdentityMatrixPower) {
                return x;
            }
        }
        //!2019-17-06
        if (x instanceof Expression.Symbol) {
            return new Expression.Exponentiation(x, Expression.ONE.divide(Expression.Integer.fromNumber(n)));
        }
        if (x instanceof Exponentiation &&
            (x.a instanceof Expression.Symbol || isGoodPolynomial(x.a)) &&
            (n % 2 === 1 || (x.b.getNumerator() instanceof Integer && x.b.getNumerator().remainder(Expression.TWO).equals(Expression.ONE)))) {
            //TODO: fix condition for n % 2 === 0
            var b = x.b.divide(Expression.Integer.fromNumber(n));
            return b.equals(Expression.ONE) ? x.a : new Expression.Exponentiation(x.a, b);
        }

        //!2019-06-20
        //var v = getVariable(x);
        var v = getVariableInternal(getLastMultiplicationOperand(getFirstAdditionOperand(x))).next().value.v; // avoid square roots
        if (v instanceof Expression.Symbol || (v instanceof Expression.Logarithm && v.a instanceof Expression.Integer) && (n === 2 || n === 3 || true)) { //TODO: other n's
            var p = Polynomial.toPolynomial(x, v);
            var c = p.getContent();
            if (c.isNegative()) {
                c = c.negate();
            }
            if (isPositive(c) && !c.equals(Expression.ONE)) {
                return x.divide(c)._nthRoot(n).multiply(c._nthRoot(n));
            }
            if (p.getDegree() === 1 && p.getCoefficient(0) instanceof Integer && !p.getCoefficient(0).equals(Expression.ZERO) && p.getCoefficient(1) instanceof Integer) {
                //TODO:
                if (p.getCoefficient(1).compareTo(Expression.ZERO) > 0) {
                    var N = n instanceof Expression.Symbol ? n : Expression.Integer.fromNumber(n); //TODO: ?
                    return new Expression.Exponentiation(x, Expression.ONE.divide(N));
                } else {
                    //!TODO: fix
                    if (n % 2 !== 0) {
                        return Expression.ONE.negate()._nthRoot(n).multiply(new Expression.Exponentiation(x.negate(), Expression.ONE.divide(Expression.Integer.fromNumber(n))));
                    }
                }
            }
            if (p.getDegree() > 1 && !p.getCoefficient(0).equals(Expression.ZERO)) {
                //TODO: check
                var N = p.getDegree();
                var t = v.multiply(p.getCoefficient(N)._nthRoot(N)).add(p.getCoefficient(0)._nthRoot(N));
                if (x.equals(t._pow(N))) {
                    //!TODO: remove
                    if (N >= n && (n % 2 !== 0 || Expression._isPositive(v))) {
                        return t.pow(Expression.ONE).multiply(t._pow(N - n)._nthRoot(n));
                    }
                    //!
                    if (n % 2 !== 0 || Expression._isPositive(v)) {
                        return new Expression.Exponentiation(t, Expression.Integer.fromNumber(N).divide(Expression.Integer.fromNumber(n)));
                    }
                }
                //TODO: (ax+b)**(n+1)
                if (p.getDegree() > 1 && p.getSquareFreePolynomial().equals(p) && n === 2) { //TODO: fix ?
                    return new Expression.Exponentiation(x, Expression.ONE.divide(Expression.Integer.fromNumber(n)));
                }
                if (p.getDegree() > 1 && n === 3) {
                    var d = simpleDivisor(x);
                    return x.divide(d)._nthRoot(n).multiply(d._nthRoot(n));
                }
            }
        }

        if (n % 2 !== 0 && x instanceof Expression.ExponentiationOfMinusOne) { //?
            return getBase(x).pow(getExponent(x).divide(Expression.Integer.fromNumber(n)));
        }

        if (x instanceof Addition && x.b instanceof NthRoot && x.a instanceof NthRoot) { //TODO: ? multiple operands - ?
            var g = nthRootCommonFactor(x.a, x.b);
            if (!g.equals(Expression.ONE)) {
                return g._nthRoot(n).multiply(x.divide(g)._nthRoot(n));
            }
        }

        if (x instanceof Exponentiation && n === 3 && getExponent(x).equals(Integer.fromNumber(3))) { //TODO: other degrees (?)
            return getBase(x);
        }
        if (x instanceof Exponentiation && n === 2 && getExponent(x).equals(Integer.fromNumber(2))) { //TODO: other degrees (?)
            if (isPositive(getBase(x))) {
                return getBase(x);
            }
            if (isPositive(getBase(x).negate())) {
                return getBase(x).negate();
            }
        }

        if (n === 2 && !(x.getDenominator() instanceof Expression.Integer)) { //TODO: other even n (?)
            var sd = simpleDivisor(x.getDenominator());
            if (sd.complexConjugate().multiply(sd).equals(x.getDenominator())) { //TODO: any factor
                return x.getNumerator()._nthRoot(n).divide(sd.abs());
            }
        }

        var sd = simpleDivisor(x);
        if (!sd.equals(x)) { //TODO: FIX
            //debugger;
            //console.log(sd + '');
            //console.log(isPositive(sd));
            console.log(sd.toString());
            if (isPositive(sd) && (!(sd instanceof Addition) || !(x.divide(sd) instanceof Addition))) {
                if (!(sd._nthRoot(n) instanceof NthRoot)) { //TODO: !?
                    return sd._nthRoot(n).multiply(x.divide(sd)._nthRoot(n));
                }
            }
        }

        var allowComplexSqrt = true;
        var isComplexNumber = function(x) {
            return Expression.isConstant(x) && !Expression.has(x, Expression.Sin) && !Expression.has(x, Expression.Cos);
        };
        if (typeof n === "number" && !isPositive(x) && allowComplexSqrt && isComplexNumber(x) && n === 2) {
            // https://en.wikipedia.org/wiki/Complex_number#Square_root
            var tmp = Expression.getComplexNumberParts(x);
            var a = tmp.real;
            var b = tmp.imaginary;
            //debugger;
            var tmp2 = a._pow(2).add(b._pow(2)).squareRoot();
            var gamma = a.add(tmp2).divide(Expression.TWO).squareRoot();
            var delta = Expression.Integer.fromNumber(b.sign()).multiply(a.negate().add(tmp2).divide(Expression.TWO).squareRoot());
            var result = gamma.add(delta.multiply(Expression.I));
            return result;
        }
        if (typeof n === "number" && (isPositive(x) || allowComplexSqrt && isComplexNumber(x) && n === 2)) { //?TODO: FIX
            var tmp = Expression.toPolynomialRoot(makeRoot(x, n));
            if (tmp != undefined) {
                return tmp;
            }
        }
        if (typeof n === "number" && isPositive(x.negate())) {
            var tmp = Expression.toPolynomialRoot(makeRoot(x.negate(), n));
            if (tmp != undefined) {
                return tmp.negate();
            }
        }

        if (getBase(x) instanceof Expression.Symbol && getBase(x).symbol.startsWith('$t') && typeof n === "number") {
            return getBase(x).pow(getExponent(x).divide(Expression.Integer.fromNumber(n)));
        }

        //!new
        //TODO: remove (move)
        if (Expression.isReal(x) && typeof n === "number") {
            if (isPositive(x)) {
                return new Expression.Exponentiation(x, Expression.Integer.fromNumber(n).inverse()); //?
            } else {
                debugger;
            }
        }
        //!

        if (n === 2 && !(this instanceof Expression.Exponentiation)) { //TODO: other even n (?)
            var d = simpleDivisor(this);
            if (d.complexConjugate().multiply(d).equals(this)) { //TODO: any factor
                return d.abs();
            }
        }

        //TODO: !?
        if (n === 2 && !(this instanceof Expression.Exponentiation)) {
            console.log(this.toString());
            //debugger;
            if (Expression.has(this, Expression.Symbol)) {
                return new Expression.Exponentiation(x, Expression.Integer.fromNumber(n).inverse());
            }
            return NthRoot.makeRoot(this, n);
        }

        throw new RangeError("NotSupportedError");
    };

    function SquareRoot(a) {
        NthRoot.call(this, "sqrt", a, 2);
    }

    SquareRoot.prototype = Object.create(NthRoot.prototype);
    //!
    SquareRoot.prototype.divideInteger = function(x) {
        //TODO: check
        return x.multiply(this).divide(this.a);
    };

    Expression.prototype.squareRoot = function() {
        return this._nthRoot(2);
    };

    Expression.Rank = function(matrix) {
        Expression.Function.call(this, "rank", matrix);
    };
    Expression.Rank.prototype = Object.create(Expression.Function.prototype);

    Expression.prototype.rank = function() {
        var x = this;
        if (!(x instanceof Expression.Matrix)) {
            throw new RangeError("NotSupportedError:matrixArgExpected"); //?
        }
        //!
        if (Expression.callback != undefined) {
            Expression.callback(new Expression.Event("rank", x));
        }
        //TODO: fix
        var cases = [];
        var rank = undefined;
        Matrix.toRowEchelonWithCallback(x.matrix, Matrix.GaussMontante, "", undefined, function(result) {
            var condition = result.condition;
            if (!condition.isTrue()) {
                var resultMatrix = result.matrix;
                cases.push(new ExpressionWithCondition(Integer.fromNumber(resultMatrix.rank()), condition));
            } else {
                rank = result.matrix.rank();
            }
        });
        if (cases.length !== 0) {
            return new Expression.Cases(cases);
        }
        //!
        return Integer.fromNumber(rank);
    };
    Expression.Determinant = function(matrix) {
        Expression.Function.call(this, "determinant", matrix);
    };
    Expression.Determinant.prototype = Object.create(Expression.Function.prototype);

    function isSquareMatrix(x) {
        if (x instanceof Expression.Matrix && x.matrix.isSquare()) {
            return true;
        }
        if (x instanceof Expression.Exponentiation && x.a instanceof Expression.MatrixSymbol && isIntegerOrN(x.b)) {
            return true;
        }
        return false;
    }
    Expression.prototype.determinant = function() {
        var x = this;
        if (x instanceof Expression.Multiplication && (isSquareMatrix(x.a) || isSquareMatrix(x.b))) {
            //TODO: ?
            if (Expression.callback != undefined) {
                Expression.callback(new Expression.Event("property-determinant-of-multiplication", {
                    matrix: "{{0}}"
                }));
            }
            return x.a.determinant().multiply(x.b.determinant());
        }
        if (x instanceof Expression.Exponentiation && x.a instanceof Expression.MatrixSymbol && isIntegerOrN(x.b)) {
            //TODO: ?
            if (Expression.callback != undefined) {
                Expression.callback(new Expression.Event("property-determinant-of-multiplication", {
                    matrix: "{{0}}"
                }));
            }
            return x.a.determinant().pow(x.b);
        }
        if (x instanceof Expression.MatrixSymbol) {
            return new Expression.Determinant(x); //?
        }
        if (isMatrixSymbolTranspose(x)) { //TODO: other cases
            return x.transpose().determinant();
        }
        if (!(x instanceof Expression.Matrix)) {
            throw new RangeError("NotSupportedError:matrixArgExpected"); //?
        }
        //!
        if (Expression.callback != undefined) {
            Expression.callback(new Expression.Event(x.matrix.getDeterminantEventType("determinant").type, x));
        }
        return x.matrix.determinant();
    };
    Expression.RowReduce = function(matrix) {
        Expression.Function.call(this, "row-reduce", matrix);
    };
    Expression.RowReduce.prototype = Object.create(Expression.Function.prototype);
    Expression.prototype.rowReduce = function() {
        var x = this;
        if (!(x instanceof Expression.Matrix)) {
            throw new RangeError("NotSupportedError:matrixArgExpected"); //?
        }
        //!
        if (Expression.callback != undefined) {
            Expression.callback(new Expression.Event("row-reduce".type, x));
        }
        //TODO: Matrix.GaussMontante
        return new Expression.Matrix(x.matrix.toRowEchelon(Matrix.GaussJordan, "", null).matrix);
    };
    Expression.Transpose = function(matrix) {
        Expression.Function.call(this, "transpose", matrix);
    };
    Expression.Transpose.prototype = Object.create(Expression.Function.prototype);
    Expression.prototype.transpose = function() {
        var x = this;
        if (x instanceof Expression.Multiplication) {
            //TODO: info about properties of the Matrix Transpose
            if (Expression.callback != undefined) {
                Expression.callback(new Expression.Event("property-transpose-of-multiplication", {
                    matrix: "{{0}}"
                }));
            }
            return x.b.transpose().multiply(x.a.transpose()); //TODO: ?
        }
        if (x instanceof Expression.Addition) {
            return x.a.transpose().add(x.b.transpose());
        }
        if (isScalar(x)) {
            return x;
        }
        if (!(getBase(x) instanceof MatrixSymbol) && x instanceof Expression.Exponentiation && x.b.equals(Expression.ONE.negate())) {
            //TODO: (X^-2)^T
            return x.a.transpose().pow(x.b);
        }
        if (x instanceof Expression.Exponentiation && x.b.equals(new Expression.Symbol("T"))) {
            //TODO: (X**2)^T
            return x.a;
        }
        if (getBase(x) instanceof MatrixSymbol) {
            var e = getExponent(x).multiply(new Expression.Symbol("T"));
            //TODO: ?
            var p = Polynomial.toPolynomial(e, new Expression.Symbol("T"));
            if (p.getDegree() >= 2) {
                e = e.subtract(p.getCoefficient(2).multiply(new Expression.Symbol("T")._pow(2))).add(p.getCoefficient(2));
            }
            return new Expression.Exponentiation(getBase(x), e);
        }
        if (!(x instanceof Expression.Matrix)) {
            throw new RangeError("NotSupportedError"); //?
        }
        return new Expression.Matrix(x.matrix.transpose());
    };
    Expression.Adjugate = function(matrix) {
        Expression.Function.call(this, "adjugate", matrix);
    };
    Expression.Adjugate.prototype = Object.create(Expression.Function.prototype);
    Expression.prototype.adjugate = function() {
        var x = this;
        var property = function() {
            //TODO: ?
            if (Expression.callback != undefined) {
                Expression.callback(new Expression.Event("property-adjugate-of-multiplication", {
                    matrix: "{{0}}"
                }));
            }
        };
        if (x instanceof Expression.Multiplication && (isSquareMatrix(x.a) || isSquareMatrix(x.b))) {
            property();
            return x.b.adjugate().multiply(x.a.adjugate());
        }
        if (x instanceof Expression.Exponentiation && x.a instanceof Expression.MatrixSymbol && isIntegerOrN(x.b)) {
            property();
            return x.a.adjugate().pow(x.b);
        }
        if (isMatrixSymbolTranspose(x)) {
            property();
            return x.transpose().adjugate().transpose();
        }
        if (x instanceof Expression.MatrixSymbol) {
            //TODO: ?
            //assuming x is an invertible square matrix
            return x.determinant().multiply(x.inverse());
            //TODO: ?
            //return new Expression.Cases([
            //  new ExpressionWithCondition(new Expression.Adjugate(x), Condition.TRUE.andZero(new Expression.Determinant(x))),
            //  new ExpressionWithCondition(x.determinant().multiply(x.inverse()), Condition.TRUE.andNotZero(new Expression.Determinant(x)))
            //]);
        }
        if (!(x instanceof Expression.Matrix)) {
            throw new RangeError("NotSupportedError:matrixArgExpected"); //?
        }
        if (Expression.callback != undefined) {
            Expression.callback(new Expression.Event("adjugate", x));
        }
        if (x.matrix.rows() === 1 && x.matrix.cols() === 1) {
            return new Expression.Matrix(Matrix.I(1));
        }
        var det = x.matrix.determinant();
        if (Expression.isScalar(det) && !det.equals(Expression.ZERO)) { //TODO: other cases
            return new Expression.Matrix(x.matrix.inverse().scale(det));
        }
        //TODO: optimize
        var C = x.matrix.map(function(element, i, j, matrix) {
            return ((i + j) - 2 * Math.floor((i + j) / 2) === 1 ? Expression.ONE.negate() : Expression.ONE).multiply(matrix.minorMatrix(i, j).determinant());
        });
        var CT = new Expression.Matrix(C.transpose());
        return CT;
    };

    Expression.NoAnswerExpression = function(matrix, name, second) {
        Expression.Function.call(this, name, matrix);
        this.second = second;
    };
    Expression.NoAnswerExpression.prototype = Object.create(Expression.Function.prototype);
    //TODO: remove secondArgument (?)
    Expression.prototype.transformNoAnswerExpression = function(name, second) {
        second = second == undefined ? undefined : second;
        if (!(this instanceof Expression.Matrix)) {
            throw new RangeError("NotSupportedError"); //?
        }
        if (name === "solve") {
            if (Expression.callback != undefined) {
                Expression.callback(new Expression.Event("solve", this));
            }
        }
        return new Expression.NoAnswerExpression(this, name, second);
    };

    //Expression.NoAnswerExpression.prototype.multiplyExpression =
    //Expression.NoAnswerExpression.prototype.multiplyMatrix =
    //Expression.NoAnswerExpression.prototype.multiplySymbol =
    //Expression.NoAnswerExpression.prototype.multiplyInteger =
    Expression.NoAnswerExpression.prototype.multiply = function() {
        throw new RangeError("NotSupportedError");
    };
    Expression.NoAnswerExpression.prototype.add = function() {
        throw new RangeError("NotSupportedError");
    };

    //TODO: remove (only for second)
    Expression.NoAnswerExpression.prototype.toString = function(options) {
        if (this.second == undefined) {
            return Expression.Function.prototype.toString.call(this, options);
        }
        return this.a.toString(setTopLevel(true, options)) + " " + this.name + " " + this.second.toString(setTopLevel(true, options));
    };


    Expression.ElementWisePower = function(a, b) {
        BinaryOperation.call(this, a, b);
    };
    Expression.ElementWisePower.prototype = Object.create(BinaryOperation.prototype);
    Expression.ElementWisePower.prototype.getS = function() {
        return ".^";
    };
    Expression.prototype.elementWisePower = function(e) {
        if (!(this instanceof Expression.Matrix)) {
            throw new RangeError("NotSupportedError"); //?
        }
        return new Expression.Matrix(this.matrix.map(function(element, i, j) {
            return element.pow(e);
        }));
    };

    Expression.prototype.isRightToLeftAssociative = function() {
        var x = this;
        if (x instanceof Integer) {
            return x.compareTo(Expression.ZERO) < 0;
        }
        if (x instanceof Negation) {
            return true;
        }
        if (x instanceof BinaryOperation) {
            if (x.isNegation()) {
                return true;
            }
            return x instanceof Exponentiation;
        }
        return false;
    };

    var integerPrimeFactor = function(n) {
        return Integer.fromBigInt(primeFactor(n.value));
    };

    //?
    var simpleDivisor = function(e) {
        if (e instanceof Division) {
            throw new RangeError();
        }
        if (e instanceof Expression.Matrix) {
            throw new RangeError();
        }
        if (e instanceof Expression.Symbol) {
            return e;
        }
        if (e instanceof Integer) {
            var x = e;
            var i = x.compareTo(Expression.ZERO) < 0 ? x.negate() : x;
            if (i.compareTo(Expression.ONE) > 0) {
                return integerPrimeFactor(i);
            }
            return null;
        }
        if (e instanceof Expression.Complex) {
            //TODO: (!)
            var f = e.primeFactor();
            if (!f.equals(e) && e.divide(f) instanceof Expression.Integer) {
                f = f.multiply(Expression.I);
            }
            return f;
            /*
            var g = integerGCD(e.real, e.imaginary);
            var t = simpleDivisor(g);
            if (t != null) {
              return t;
            }
            if (typeof hit === "function") {
              hit({everySimpleDivisor: e.toString()});
            }
            return e;
            */
        }
        //var v = getVariable(e);
        // To avoid square roots / nth roots:
        var v = getVariableInternal(getLastMultiplicationOperand(getFirstAdditionOperand(e))).next().value.v;
        //if (v instanceof NthRoot || v instanceof Integer || v instanceof Expression.Complex) {
        //  v = undefined;
        //}
        if (v instanceof NthRoot && v.a instanceof Integer && v.n === 2) { //TODO: ???
            var p = getPolynomialRelativeToNthRoot(e, v.a, v.n);
            var f = p.getContent();
            if (!f.equals(Expression.ONE) && !f.equals(Expression.ONE.negate())) {
                return simpleDivisor(f);
            }
        }
        if (v != undefined) {
            v = getVariable(v); //!?TODO: FIX
            var r = getReplacement(e, v);
            if (!r.equals(v)) {
                return substitute(simpleDivisor(substitute(e, v, r, inverseReplacement(r, v))), v, inverseReplacement(r, v), r);
            }

            var np = Polynomial.toPolynomial(e, v);

            var content = np.getContent();
            var t = simpleDivisor(content);
            if (t != null) {
                return t;
            }
            var c = getConstant(np.getLeadingCoefficient());
            if (c instanceof Expression.Complex && c.real.equals(Expression.ZERO)) {
                return Expression.I; //!?
            }

            //?
            if (np.getCoefficient(0).equals(Expression.ZERO)) {
                return v;
            }

            if (np.getDegree() >= 2) {
                //TODO: square free polynomial - ?
                var root = np.doRationalRootTest();
                if (root != null) {
                    var t = v.multiply(root.getDenominator()).subtract(root.getNumerator());
                    return t;
                }
            }

            if (np.getDegree() >= 2 && np._hasIntegerLikeCoefficients()) {
                //TODO: TEST COVERAGE (!)
                var t = np.factorize();
                if (t != null) {
                    //TODO: write a test case
                    return simpleDivisor(t.calcAt(v));
                }
            }

            if (np.getDegree() >= 2 && !np._hasIntegerLikeCoefficients()) {
                //TODO: TEST COVERAGE (!)
                var t = np.squareFreeFactors();
                if (t.a0.getDegree() !== 0) {
                    //TODO: write a test case
                    return t.a0.scale(t.a0.getLeadingCoefficient().inverse()).calcAt(v);
                }
            }
            /*
            if (np.getDegree() >= 2) {
              var roots = np.getroots();
              if (roots.length > 0) {
                var root = roots[0];
                return v.subtract(root);
              }
            }
            */

            e = np.calcAt(v);
            if (e.isNegative()) { //TODO: remove - ?
                e = e.negate(); //!?
            }
            return e;
        }
        throw new RangeError(); //?
    };
    Expression.simpleDivisor = simpleDivisor;

    Expression.everyDivisor = function(e, callback) {
        if (e.equals(Expression.ZERO)) {
            return true;
        }
        if (!callback(Expression.ONE)) {
            return false;
        }
        var divisors = [];
        var rec = function(start, n, s) {
            if (n >= 0) {
                var x = divisors[n];
                for (var i = start; i <= x.e; i += 1) {
                    if (!rec(0, n - 1, s.multiply(Expression.pow(x.d, i)))) {
                        return false;
                    }
                }
            } else {
                if (!callback(s)) {
                    return false;
                }
            }
            return true;
        };
        while (!e.equals(Expression.ONE) && !e.equals(Expression.ONE.negate())) {
            var d = simpleDivisor(e);
            if (divisors.length === 0 || !divisors[divisors.length - 1].d.equals(d)) {
                divisors.push({
                    d: d,
                    e: 0
                });
            }
            divisors[divisors.length - 1].e += 1;
            if (!rec(divisors[divisors.length - 1].e, divisors.length - 1, Expression.ONE)) {
                return false;
            }
            e = e.divide(d);
        }
        return true;
    };

    Expression.Integer = Integer;
    Expression.NthRoot = NthRoot;
    Expression.SquareRoot = SquareRoot;
    Expression.Negation = Negation;
    Expression.Subtraction = Subtraction;
    Expression.BinaryOperation = BinaryOperation;
    Expression.Exponentiation = Exponentiation;
    Expression.Multiplication = Multiplication;
    Expression.Addition = Addition;
    Expression.Division = Division;
    //TODO: remove
    Expression.pow = function(x, count) {
        return x._pow(count);
    };
    Expression.prototype._pow = function(count) {
        return pow(this, count, Expression.ONE);
    };
    Expression.Integer.prototype._pow = function(count) {
        // for performance (?)
        if (typeof count === "number" && Math.floor(count) === count && count >= 0 && count <= Number.MAX_SAFE_INTEGER) {
            return new Integer(SmallBigInt.exponentiate(this.value, SmallBigInt.BigInt(count)));
        }
        return Expression.prototype._pow.call(this, count);
    };
    Expression.Integer.prototype._nthRoot = function(n) {
        // for performance (?)
        //TODO: fix (more cases)
        if (typeof n === "number" && n === 2 && this.equals(this.abs()) && isPerfectSquare(this)) {
            return this._integerNthRoot(2);
        }
        if (typeof n === "number" && n === 3 && isPerfectCube(this)) {
            return this._integerNthRoot(3);
        }
        //TODO: move !!!
        if (typeof n === "number" && n === 2 && this.equals(this.abs())) {
            var x = this;
            var a = Expression.ONE;
            var s = Expression.ONE;
            while (!isPerfectSquare(x)) {
                var f = Integer.fromBigInt(primeFactor(x.toBigInt()));
                var multiplicity = primeFactor._countTrailingZeros(x.toBigInt(), f.toBigInt());
                x = x.divide(f._pow(multiplicity));
                if (multiplicity % 2 === 1) {
                    //var g = a.gcd(f);
                    //if (!g.equals(Expression.ONE)) {
                    //  f = f.divide(g);
                    //  a = a.divide(g);
                    //  a = a.multiply(g);
                    //}
                    //s.push(f);
                    s = s.multiply(f);
                    multiplicity -= 1;
                }
                a = a.multiply(f._pow(multiplicity / 2));
            }
            return x.squareRoot().multiply(a).multiply(new SquareRoot(s));
        }
        return Expression.prototype._nthRoot.call(this, n);
    };
    Expression.Integer.prototype._isPerfectSquare = function() {
        if (this.sign() < 0) {
            return false;
        }
        return isPerfectSquare(this);
    };
    Integer.prototype._integerNthRoot = function(n) {
        return new Integer(SmallBigInt.BigInt(primeFactor._integerNthRoot(this.toBigInt(), n)));
    };
    Integer.prototype.bitLength = function() {
        return primeFactor._bitLength(this.toBigInt());
    };
    Integer.prototype.modInverse = function(p) {
        return Expression.Integer.fromBigInt(primeFactor._modInverse(this.toBigInt(), p.toBigInt()));
    };
    Integer.prototype.modulo = function modulo(p) {
        var r = this.remainder(p);
        return r.compareTo(Expression.ZERO) < 0 ? r.add(p) : r;
    };
    // ---





    Expression.Equality = function(a, b) {
        BinaryOperation.call(this, a, b);
    };

    Expression.Equality.prototype = Object.create(BinaryOperation.prototype);
    Expression.Equality.prototype.getS = function() {
        return "=";
    };

    Expression.Inequality = function(a, b, sign) {
        BinaryOperation.call(this, a, b);
        this.sign = sign;
    };

    Expression.Inequality.prototype = Object.create(BinaryOperation.prototype);
    Expression.Inequality.prototype.getS = function() {
        return this.sign;
    };

    function AdditionIterator(e) {
        if (e == undefined) {
            throw new TypeError();
        }
        this.value = undefined;
        this.e = e;
    }
    AdditionIterator.prototype = Object.create(Iterator.prototype);
    AdditionIterator.prototype.next = function() {
        this.value = this.e instanceof Addition ? this.e.b : this.e;
        this.e = this.e instanceof Addition ? this.e.a : undefined;
        return this;
    };

    function MultiplicationIterator(e) {
        if (e == undefined) {
            throw new TypeError();
        }
        this.value = undefined;
        this.e = e;
    }
    MultiplicationIterator.prototype = Object.create(Iterator.prototype);
    MultiplicationIterator.prototype.next = function() {
        this.value = this.e instanceof Multiplication ? this.e.b : this.e;
        this.e = this.e instanceof Multiplication ? this.e.a : null;
        return this;
    };

    Expression.prototype.summands = function() {
        return new AdditionIterator(this);
    };

    Expression.prototype.factors = function() {
        return new MultiplicationIterator(this);
    };

    var splitX = function(e) {
        var scalar = undefined;
        var l = undefined;
        var r = undefined;
        var xx = undefined;
        for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
            //TODO: why iteration by additions - (?)
            var state = 0;
            for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
                var factor = y;
                var factorBase = getBase(y);
                var factorExponent = getExponent(y);
                /*if ((!(factorBase instanceof Integer) && !(factorBase instanceof Expression.Symbol) && !(factorBase instanceof Expression.Matrix)) ||
                    !(factorExponent instanceof Integer) && !(factorExponent instanceof Expression.Symbol && factorExponent.toString() === "T")) {//TODO: fix
                  throw new RangeError("NotSupportedError");
                }*/
                var s = factorBase instanceof Expression.Symbol ? factorBase.toString() : "";
                if (s === "X" && state === 0) {
                    state = 1;
                    xx = factor;
                } else {
                    if (isScalar(factor)) {
                        scalar = scalar == undefined ? factor : factor.multiply(scalar);
                    } else {
                        if (state === 0) {
                            r = r == undefined ? factor : factor.multiply(r);
                        }
                        if (state === 1) {
                            l = l == undefined ? factor : factor.multiply(l);
                        }
                    }
                }
            }
        }
        scalar = scalar == undefined ? Expression.ONE : scalar;
        return {
            s: scalar,
            l: l,
            r: r,
            x: xx
        };
    };
    Expression.splitX = splitX;
    var groupX = function(a, b) {
        var tmp1 = splitX(a);
        var tmp2 = splitX(b);
        var s1 = tmp1.s;
        var l1 = tmp1.l;
        var r1 = tmp1.r;
        var s2 = tmp2.s;
        var l2 = tmp2.l;
        var r2 = tmp2.r;
        if (r1 == undefined && r2 == undefined && tmp1.x.equals(tmp2.x)) {
            l1 = l1 == undefined ? new IdentityMatrix("I") : l1;
            l2 = l2 == undefined ? new IdentityMatrix("I") : l2;
            return new Multiplication(s1.multiply(l1).add(s2.multiply(l2)), tmp1.x);
        }
        if (l1 == undefined && l2 == undefined && tmp1.x.equals(tmp2.x)) {
            r1 = r1 == undefined ? new IdentityMatrix("I") : r1;
            r2 = r2 == undefined ? new IdentityMatrix("I") : r2;
            return new Multiplication(tmp1.x, s1.multiply(r1).add(s2.multiply(r2)));
        }
        return undefined;
    };

    //TODO: remove (replace with a Condition) - ?
    //?
    var getExpressionWithX = function(e) {
        if (e instanceof Division) {
            if (e.getDenominator() instanceof Expression.Integer) {
                e = e.getNumerator(); //!
            } else {
                return {
                    withX: undefined,
                    withoutX: undefined
                };
            }
        }

        var withX = undefined;
        var withoutX = undefined;
        for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
            var summand = x;
            var hasX = false;
            for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
                var factor = y;
                var factorBase = getBase(factor);
                //!new2019-12-03
                if (factorBase instanceof Addition && getExponent(factor).isNegative()) { // (<matrix addition>)**-1 (?)
                    //TODO: fix
                    var q = null; // e.subtract(x)
                    for (var iteratorx1 = e.summands()[globalThis.Symbol.iterator](), x1 = iteratorx1.next().value; x1 != null; x1 = iteratorx1.next().value) {
                        if (x1 !== x) {
                            q = q == null ? x1 : q.add(x1);
                        }
                    }
                    var exponent = getExponent(factor).negate();
                    var e1 = q.multiply(factorBase.pow(exponent)).add(x.multiply(new Expression.Exponentiation(factorBase, exponent)));
                    var z2 = e1.transformEquality(Expression.ZERO);
                    //TODO:
                    //var tmp = Polynomial.toPolynomial(factorBase, z2.a).calcAt(z2.b);
                    var variable = getExponent(z2.a) instanceof Expression.Symbol ? z2.a : getBase(z2.a);
                    var tmp = Polynomial.toPolynomial(factorBase, variable).divideAndRemainder(Polynomial.toPolynomial(z2.a.subtract(z2.b), variable)).remainder.calcAt(variable);
                    var d = tmp instanceof Expression.Matrix ? tmp.determinant() : null;
                    if (!Expression.isConstant(d)) { //TODO: ?
                        return {
                            withX: undefined,
                            withoutX: undefined
                        };
                    }
                    if (d.equals(Expression.ZERO)) {
                        return {
                            withX: Expression.ZERO,
                            withoutX: Expression.ONE
                        }; //TODO: no solutions
                    }
                    return getExpressionWithX(e1); //!hack
                }
                //!
                //!2020-06-14
                if (factorBase instanceof MatrixSymbol && getExponent(factor).isNegative()) { // (<matrix addition>)**-1 (?)
                    var exponent = getExponent(factor).negate();
                    // if the multiplication will "remove" the factor
                    var e1 = x.b.equals(factor) ? e.multiply(factorBase.pow(exponent)) : (Array.from(factorBase.pow(exponent).multiply(x).factors()).length < Array.from(x.factors()).length ? factorBase.pow(exponent).multiply(e) : null);
                    //TODO: determinant(X) != 0
                    //?
                    /*
                    var g = null;
                    for (var iteratorx = e1.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
                      var y = x.factors().next().value;
                      if (getBase(y) instanceof Expression.MatrixSymbol) {//TODO: FIX
                        g = g == null ? y : y.gcd(g);
                      } else {
                        g = Expression.ONE;
                      }
                    }
                    if (g != null && !g.equals(Expression.ONE)) {
                      e1 = e1.multiply(g.inverse());//!?
                    }
                    */
                    //?
                    if (e1 != null) {
                        return getExpressionWithX(e1);
                    }
                }
                if (factorBase instanceof Expression.Division) { //! 2023-02-12  (X/9) TODO: ???
                    if (factorBase.getDenominator() instanceof Expression.Integer) {
                        return getExpressionWithX(factorBase.getDenominator().multiply(e));
                    }
                }
                //!
                if (!(factorBase instanceof Integer) && !(factorBase instanceof Expression.Symbol)) {
                    if (!(factorBase instanceof Expression.Matrix)) { //?
                        if (!(factorBase instanceof NthRoot)) { //?TODO: remove - ?
                            if (factorBase instanceof Expression.Determinant && factorBase.a.toString() === "X") { //TODO: wrong
                                return {
                                    withX: null,
                                    withoutX: null
                                };
                            }
                            if (Expression.has(factorBase, Expression.MatrixSymbol)) { //?
                                throw new RangeError("NotSupportedError");
                            }
                        }
                    }
                }
                if (factorBase instanceof Expression.Symbol) {
                    var s = factorBase.toString();
                    if (s === "X") {
                        if (hasX) {
                            //throw new RangeError("NotSupportedError");
                            return {
                                withX: null,
                                withoutX: null
                            };
                        }
                        hasX = true;
                    }
                }
            }
            if (hasX) {
                if (withX != undefined) {
                    withX = groupX(withX, summand);
                    if (withX == null) {
                        //throw new RangeError("NotSupportedError");
                        return {
                            withX: null,
                            withoutX: null
                        };
                    }
                    //throw new RangeError("NotSupportedError");
                } else {
                    withX = summand;
                }
            }
            if (!hasX) {
                withoutX = withoutX == undefined ? summand.negate() : withoutX.subtract(summand);
            }
        }
        return {
            withX: withX,
            withoutX: withoutX
        };
    };

    // Some number, including e and pi
    var isConstant = function(e) {
        if (e instanceof Expression.BinaryOperation) {
            return isConstant(e.b) && isConstant(e.a);
        } else if (e instanceof Expression.Integer) {
            return true;
        } else if (e instanceof Expression.PolynomialRootSymbol) { // note: e instanceof Expression.Symbol for now (!) so this check should go first
            return true;
        } else if (e instanceof Expression.ExpressionWithPolynomialRoot) {
            return isConstant(e.e);
        } else if (e instanceof Expression.ExpressionPolynomialRoot) { // note: e instanceof Expression.Symbol for now (!) so this check should go first
            return true;
        } else if (e instanceof Expression.Symbol) {
            return e === Expression.E || e === Expression.PI;
        } else if (e instanceof Expression.Complex) {
            return true;
        } else if (e instanceof Expression.NthRoot) {
            return isConstant(e.a);
        } else if (e instanceof Expression.Sin || e instanceof Expression.Cos || e instanceof Expression.Arctan) {
            return isConstant(e.a);
        } else if (e instanceof Expression.Radians) {
            return isConstant(e.value);
            //TODO:
        } else if (e instanceof Expression.Logarithm) {
            return isConstant(e.a); //TODO: test
        } else if (e === Expression.E || e === Expression.PI) {
            return true;
        }
        return false;
    };

    Expression.isConstant = isConstant;

    Expression.getMultivariatePolynomial = function(e) {
        if (e instanceof Expression.Division) {
            return undefined;
        }
        //var v = Expression.getVariable(e);
        // To avoid square roots / nth roots:
        var v = getVariableInternal(getLastMultiplicationOperand(getFirstAdditionOperand(e))).next().value.v;
        if (v instanceof NthRoot || v instanceof Integer || v instanceof Expression.Complex) {
            v = undefined;
        }
        if (v == undefined) {
            //throw new TypeError("undefined");
            return undefined;
        }
        //?
        if (v instanceof Expression.Addition) {
            v = getVariableInternal(getLastMultiplicationOperand(getFirstAdditionOperand(v))).next().value.v;
        }
        //?

        //TODO:
        var r = getReplacement(e, v);
        if (!r.equals(v)) {
            e = substitute(e, v, r, inverseReplacement(r, v));
            if (e instanceof Expression.Division && e.b instanceof Expression.Integer) {
                e = e.a; //!
            }
        }

        var p = Polynomial.toPolynomial(e, v);
        if (p.getDegree() === 0) {
            console.warn('Expression.getMultivariatePolynomial');
            return undefined;
        }
        //TODO: iteration by sparse coefficients
        for (var i = 0; i <= p.getDegree(); i += 1) {
            var c = p.getCoefficient(i);
            if (!isConstant(c)) {
                var pc = Expression.getMultivariatePolynomial(c);
                if (pc == undefined) {
                    return undefined;
                }
            }
        }
        return {
            p: p.map(function(c) {
                return substitute(c, v, inverseReplacement(r, v), r);
            }),
            v: inverseReplacement(r, v)
        };
    };
    Expression.isSingleVariablePolynomial = function(e) {
        var tmp = Expression.getMultivariatePolynomial(e);
        if (tmp == null) {
            return false;
        }
        var p = tmp.p;
        //TODO: iteration by sparse coefficients
        for (var i = 0; i <= p.getDegree(); i += 1) {
            var c = p.getCoefficient(i);
            if (!isConstant(c)) {
                return false;
            }
        }
        return true;
    };

    // TODO: NotSupportedError
    Expression.prototype.transformEquality = function(b) {
        var e = this.subtract(b);
        var tmp = getExpressionWithX(e);
        var withX = tmp.withX;
        var withoutX = tmp.withoutX;
        if (withX == undefined) {
            if (e.getDenominator() instanceof Integer &&
                !(e.getNumerator() instanceof Expression.Matrix) &&
                !Expression.has(e, Expression.MatrixSymbol) &&
                !e.equals(Expression.ZERO)) {
                if (typeof e.upgrade === "function") { //TODO:
                    e = e.upgrade();
                }
                //TODO: tests
                //TODO: fix, TODO: for 'y'
                var tmpv = new Expression.Symbol('x');
                var tmp = {
                    p: Polynomial.toPolynomial(e.getNumerator(), tmpv),
                    v: tmpv
                };
                if (tmp.p.getDegree() === 0 || Expression.has(e, Expression.Function)) { //TODO: FIX!!!
                    tmp = Expression.getMultivariatePolynomial(e.getNumerator());
                }
                if (tmp != undefined && tmp.v instanceof Expression.Symbol) {
                    var p = tmp.p;
                    var v = tmp.v;
                    var m = Matrix.Zero(1, p.getDegree() + 1).map(function(e, i, j) {
                        return p.getCoefficient(p.getDegree() - j);
                    });
                    return new Expression.NoAnswerExpression(new Expression.Matrix(m), "polynomial-roots", {
                        polynomial: p,
                        variable: v
                    });
                }
            }
            if (e instanceof Expression.Matrix) {
                if (this instanceof Expression.Matrix && (b instanceof Expression.Matrix || b instanceof Expression.IdentityMatrix)) {
                    return Expression.SystemOfEquations.from([{
                        left: this,
                        right: b
                    }]);
                }
                //TODO: other things - ?
            }
            if (true) { //!new 2019-11-27
                //TODO: fix
                return Expression.SystemOfEquations.from([{
                    left: this,
                    right: b
                }]);
            }
            throw new RangeError("NotSupportedError");
        }

        if (withoutX == undefined) {
            withoutX = Expression.ZERO; //?
        }
        //console.log(withX.toString() + "=" + withoutX.toString());

        var left = withX;
        var right = withoutX;

        var isToTheLeft = false;
        var x = withX;
        for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
            var factor = y;
            var factorBase = getBase(factor);
            //if (!(factorBase instanceof Integer) && !(factorBase instanceof Expression.Symbol)) {
            //  if (!(factorBase instanceof Expression.Matrix)) {//?
            //    throw new RangeError("NotSupportedError");
            //  }
            //}
            var isX = false;
            if (factorBase instanceof Expression.Symbol) {
                var s = factorBase.toString();
                if (s === "X") {
                    isX = true;
                    isToTheLeft = true;
                }
            }
            if (!isX) {
                if (factor instanceof Expression.Matrix && (!(factor.matrix.cols() === factor.matrix.rows()) || factor.determinant().equals(Expression.ZERO))) {
                    //TODO: when determinant is not constant - ?
                    return Expression.SystemOfEquations.from([{
                        left: withX,
                        right: withoutX
                    }]);
                }
                var f = factor.inverse();
                //  console.log(isToTheLeft, f.toString());
                if (isToTheLeft) {
                    right = f.multiply(right);
                    //left = f.multiply(left);
                } else {
                    right = right.multiply(f);
                    //left = left.multiply(f);
                }
            } else {
                left = factor;
            }
        }

        //console.log(left.toString() + "=" + right.toString());
        if (left instanceof Expression.Exponentiation && getExponent(left).equals(Expression.ONE.negate())) { //TODO: FIX!!!
            if (right instanceof Expression.Matrix && !right.determinant().equals(Expression.ZERO)) { //TODO: condition - ?
                left = left.inverse();
                right = right.inverse();
                //TODO: add a step (?)
                //console.log(left.toString() + "=" + right.toString());
            }
        }
        return new Expression.Equality(left, right);
    };

    Expression.prototype.transformInequality = function(b, sign) { //TODO: ?
        var a = this;
        /*var c = Condition.TRUE;
        if (sign === '>') {
          c = c.andGreaterZero(a.subtract(b));
        } else if (sign === '<') {
          c = c.andGreaterZero(a.subtract(b).negate());
        //} else if (sign === '>=') {
        //  c = c.andGreaterZero(a.subtract(b).negate());
        //} else if (sign === '<=') {
        //  c = c.andGreaterZero(a.subtract(b));
        } else if (sign === '!=') {
          c = c.andNotZero(a.subtract(b));
        } else {
          throw new TypeError();
        }
        */
        //return new ExpressionWithCondition(Expression.ZERO, c);//TODO: ?
        return new Expression.Inequality(a, b, sign);
    };

    Expression.simplifications = [];
    Expression.prototype.simplifyExpression = function() {
        var e = this;
        for (var i = 0; i < Expression.simplifications.length; i += 1) {
            e = Expression.simplifications[i](e);
        }
        return e;
    };

    Expression.prototype.isExact = function() {
        //TODO: it is used in diagonalization (!!!), which is not good for performance (?)
        return !Expression.has(this, Expression.PolynomialRootSymbol) && !Expression.has(this, Expression.ExpressionPolynomialRoot);
    };

    //Expression.Complex = function () {
    //};

    Expression.PI = new Expression.Symbol("\u03C0"); // PI
    Expression.E = new Expression.Symbol("\u2147"); // EulerNumber
    Expression.I = new Expression.Symbol("\u2148"); // ImaginaryUnit

    Expression.CIRCLE = new Expression.Symbol("○");
    Expression.INFINITY = new Expression.Symbol("∞");

    Expression.prototype.addPosition = function() {
        return this;
    };

    //! 2018-09-30
    Expression.SystemOfEquations = function(equations) {
        throw new TypeError();
        this.equations = equations;
    };
    Expression.SystemOfEquations.from = function(equations) {
        return new Expression.NoAnswerExpression({
            matrix: null
        }, "system-of-equations", {
            equations: equations
        });
    };

    Expression.ExponentiationOfMinusOne = function(x, y) {
        Expression.Exponentiation.call(this, x, y);
    };
    Expression.ExponentiationOfMinusOne.prototype = Object.create(Expression.Exponentiation.prototype);
    Expression.ExponentiationOfMinusOne.prototype.divideExpression = function(x) {
        return x.multiply(this);
    };

    Expression.ExponentiationOfImaginaryUnit = function(x, y) {
        Expression.Exponentiation.call(this, x, y);
    };
    Expression.ExponentiationOfImaginaryUnit.prototype = Object.create(Expression.Exponentiation.prototype);
    Expression.ExponentiationOfImaginaryUnit.prototype.divideExpression = function(x) {
        var c = getConjugate(getBase(this)).pow(getExponent(this));
        return x.multiply(c).divide(this.multiply(c));
    };

    Expression.ExponentiationOfQuadraticInteger = function(x, y) {
        Expression.Exponentiation.call(this, x, y);
    };
    Expression.ExponentiationOfQuadraticInteger.prototype = Object.create(Expression.ExponentiationOfImaginaryUnit.prototype);
    Expression.ExponentiationOfQuadraticInteger.prototype.divideExpression = function(x) {
        return Expression.Exponentiation.prototype.divideExpression.call(this, x);
    };

    //!
    Expression.Division.prototype.negate = function() {
        return new Expression.Division(this.a.negate(), this.b);
    };

    Expression.Polynomial = function(polynomial) {
        this.polynomial = polynomial;
    };
    Expression.Polynomial.prototype = Object.create(Expression.prototype);
    Expression.Polynomial.prototype.gcd = function(other) {
        if (other instanceof Expression.Polynomial) {
            return new Expression.Polynomial(Polynomial.polynomialGCD(this.polynomial, other.polynomial));
        }
        if (other.equals(Expression.ZERO)) {
            return this;
        }
        throw new TypeError();
    };
    Expression.Polynomial.prototype.equals = function(y) {
        return y.equalsPolynomial(this);
    };
    Expression.Polynomial.prototype.equalsPolynomial = function(x) {
        //TODO: test case
        return x.polynomial.equals(this.polynomial);
    };
    Expression.prototype.equalsPolynomial = function(x) {
        return (x.polynomial.equals(Polynomial.ZERO) && this.equals(Expression.ZERO)) || (x.polynomial.getDegree() === 0 && this.equals(x.polynomial.getCoefficient(0)));
    };
    Expression.Polynomial.prototype.multiply = function(p) {
        if (p === Expression.ONE) {
            return this;
        }
        return p.multiplyPolynomial(this);
    };
    Expression.Polynomial.prototype.multiplyPolynomial = function(x) {
        return new Expression.Polynomial(x.polynomial.multiply(this.polynomial));
    };
    Expression.Division.prototype.multiplyPolynomial = function(p) {
        return this.multiplyExpression(p);
    };
    Expression.Integer.prototype.multiplyPolynomial = function(p) {
        return new Expression.Polynomial(p.polynomial.scale(this));
    };
    Expression.Polynomial.prototype.multiplyInteger = function(x) {
        return new Expression.Polynomial(this.polynomial.scale(x));
    };
    Expression.Polynomial.prototype.divide = function(l) {
        if (l.equals(Expression.ONE)) {
            return this;
        }
        if (l.equals(Expression.ONE.negate())) {
            return this.negate();
        }
        if (l instanceof Expression.Integer) { //TODO: ?
            return new Expression.Polynomial(this.polynomial.scale(l.inverse()));
        }
        return l.dividePolynomial(this);
    };
    Expression.Division.prototype.dividePolynomial = function(p) {
        return this.divideExpression(p);
    };
    Expression.Polynomial.prototype.dividePolynomial = function(x) {
        var y = this;
        var a = x.polynomial;
        var b = y.polynomial;
        if (a.getDegree() < 0 && b.getDegree() >= 0) {
            return new Expression.Polynomial(a);
        }
        //TODO: ?
        var tmp = a.divideAndRemainder(b);
        if (tmp.remainder.equals(Polynomial.ZERO)) {
            return new Expression.Polynomial(tmp.quotient);
        }
        var ca = a.getContent();
        if (!ca.getDenominator().equals(Expression.ONE)) {
            return y.multiply(ca.getDenominator()).dividePolynomial(x.multiply(ca.getDenominator()));
        }
        var cb = b.getContent();
        if (!cb.getDenominator().equals(Expression.ONE)) {
            return y.multiply(cb.getDenominator()).dividePolynomial(x.multiply(cb.getDenominator()));
        }
        var gcd = Polynomial.polynomialGCD(a, b);
        //TODO:
        if (y.polynomial.equals(gcd)) {
            return new Expression.Polynomial(x.polynomial.divideAndRemainder(gcd).quotient);
        }
        return new Expression.Division(new Expression.Polynomial(x.polynomial.divideAndRemainder(gcd).quotient), new Expression.Polynomial(y.polynomial.divideAndRemainder(gcd).quotient));
    };
    Expression.Polynomial.prototype.negate = function() {
        return new Expression.Polynomial(this.polynomial.negate());
    };
    Expression.Polynomial.prototype.add = function(y) {
        return y.addPolynomial(this);
    };
    Expression.Polynomial.prototype.addPolynomial = function(x) {
        return new Expression.Polynomial(x.polynomial.add(this.polynomial));
    };
    Expression.prototype.addPolynomial = function(x) {
        if (this.equals(Expression.ZERO)) {
            return x;
        }
        throw new RangeError();
    };
    Expression.Polynomial.prototype.getPrecedence = function() {
        var d = this.polynomial.getDegree();
        var count = 0;
        for (var i = 0; i <= d; i += 1) {
            if (!this.polynomial.getCoefficient(i).equals(Expression.ZERO)) {
                count += 1;
            }
        }
        return (count < 2 ? (this.polynomial.getLeadingCoefficient().equals(Expression.ONE) ? new Expression.Symbol("x") : new Expression.Multiplication(Expression.ONE, Expression.ONE)) : new Expression.Addition(Expression.ONE, Expression.ONE)).getPrecedence();
    };
    Expression.Polynomial.prototype.modulo = function(p) {
        if (p instanceof Expression.Polynomial) {
            return new Expression.Polynomial(this.polynomial.divideAndRemainder(p.polynomial).remainder);
        }
        throw new TypeError();
    };
    Expression.Polynomial.prototype.modInverse = function(p) {
        if (p instanceof Expression.Polynomial) {
            return new Expression.Polynomial(this.polynomial.primitivePart().modularInverse(p.polynomial).primitivePart().scale(this.polynomial.getContent().inverse()));
        }
        throw new TypeError();
    };
    Expression.Polynomial.prototype.isDivisibleBy = function(other) {
        if (other instanceof Expression.Polynomial) {
            return this.polynomial.isDivisibleBy(other.polynomial);
        }
        throw new TypeError();
    };

    Expression.unique = function(array) {
        var result = [];
        for (var i = 0; i < array.length; i += 1) {
            var value = array[i];
            var found = false;
            for (var j = 0; j < result.length; j += 1) {
                if (result[j] === value) {
                    found = true;
                }
            }
            if (!found) {
                result.push(value);
            }
        }
        return result;
    };

    Expression.Multiplication.prototype.compare4Multiplication = function(y) {
        var x = this;
        if (y instanceof Addition) { //TODO: fix
            return 0 - y.compare4Multiplication(x);
        }
        var i = x.factors();
        var j = y.factors();
        var a = i.next().value;
        var b = j.next().value;
        while (a != null && b != null) {
            var c = a.compare4Multiplication(b);
            if (c !== 0) {
                return c;
            }
            a = i.next().value;
            b = j.next().value;
        }
        return a != null ? +1 : (b != null ? -1 : 0);
    };

    Expression.Multiplication.compare4Addition = function(x, y) {
        var i = x.factors();
        var j = y.factors();
        var a = i.next().value;
        var b = j.next().value;
        while (a != null && b != null) {
            var c = a.compare4Addition(b);
            if (c !== 0) {
                return c;
            }
            a = i.next().value;
            b = j.next().value;
        }
        return a != null ? +1 : (b != null ? -1 : 0);
    };


    // cos(2 * x) * cos(x)
    Expression.Multiplication.prototype.compare4MultiplicationSymbol = function(x) {
        return 0 - this.compare4Multiplication(x);
    };

    Expression.Function.prototype.compare4Addition = function(y) {
        if (y instanceof Expression.Function) {
            return this.name < y.name ? -1 : (y.name < this.name ? +1 : this.a.compare4Addition(y.a));
        }
        if (y instanceof Multiplication) {
            var x = this;
            return Multiplication.compare4Addition(x, y);
        }
        if (y instanceof Addition) {
            var x = this;
            return Addition.compare4Addition(x, y);
        }
        return +1;
    };

    Expression.NthRoot.prototype.compare4Addition = function(y) {
        return y.compare4AdditionNthRoot(this);
    };
    Expression.prototype.compare4AdditionNthRoot = function(x) {
        return Expression.Function.prototype.compare4Addition.call(x, this);
    };
    Expression.NthRoot.prototype.compare4AdditionNthRoot = function(x) {
        return (this.n - x.n) || x.a.compare4Addition(this.a);
    };

    Expression.prototype.compare4AdditionSymbol = function(x) {
        var y = this;
        if (y instanceof Expression.Function) {
            return -1;
        }
        return Expression.prototype.compare4Addition.call(x, y);
    };

    Expression.Symbol.prototype.compare4Addition = function(y) {
        return y.compare4AdditionSymbol(this);
    };
    Expression.Symbol.prototype.compare4AdditionSymbol = function(x) { // for performance
        var y = this;
        return x.symbol < y.symbol ? -1 : (y.symbol < x.symbol ? +1 : 0);
    };

    Expression.Function.prototype.compare4Multiplication = function(y) {
        if (y instanceof Expression.NthRoot) {
            return +1;
        }
        if (y instanceof Expression.Function) {
            return this.name < y.name ? -1 : (y.name < this.name ? +1 : getBase(this.a).compare4Multiplication(getBase(y.a)) || getExponent(this.a).compare4AdditionSymbol(getExponent(y.a)));
        }
        if (y instanceof Expression.MatrixSymbol) {
            return -1;
        }
        return +1;
    };

    Expression.Function.prototype.compare4MultiplicationInteger = function(x) {
        return 0 - this.compare4Multiplication(x);
    };

    Expression.Function.prototype.compare4MultiplicationSymbol = function(x) {
        return -1; //?
    };

    Expression.Function.prototype.compare4MultiplicationNthRoot = function(x) {
        return 0 - this.compare4Multiplication(x);
    };

    Expression.Function.prototype.pow = function(y) {
        if (this instanceof Expression.NthRoot) {
            return Expression.prototype.pow.call(this, y);
        }
        if (y instanceof Expression.Integer) {
            if (y.compareTo(Expression.ONE) > 0) {
                return new Expression.Exponentiation(this, y);
            }
            return Expression.prototype.pow.call(this, y);
        }
        if (isIntegerOrN(y) && y instanceof Expression.Symbol) { //TODO: !?
            return new Expression.Exponentiation(this, y);
        }
        throw new RangeError("NotSupportedError");
    };

    function ExpressionWithCondition(e, condition) {
        this.e = e;
        this.condition = condition;
    }
    ExpressionWithCondition.prototype = Object.create(Expression.prototype);
    ExpressionWithCondition.prototype.toString = function() {
        return this.e.toString() + '; ' + this.condition.toString();
    };
    ExpressionWithCondition.prototype.toMathML = function(options) {
        return this.e.toMathML(options) + '<mtext>; </mtext>' + this.condition.toMathML(options);
    };

    ExpressionWithCondition.prototype.multiplyExpression =
        ExpressionWithCondition.prototype.multiplyMatrix = function(x) {
            //TODO: apply condition - ?
            return new ExpressionWithCondition(x.multiply(this.e), this.condition);
        };
    ExpressionWithCondition.prototype.multiply = function(y) {
        return y.multiplyExpressionWithCondition(this);
    };
    ExpressionWithCondition.prototype.multiplyExpressionWithCondition = function(x) {
        throw new TypeError("TODO:");
    };
    Expression.prototype.multiplyExpressionWithCondition = function(x) {
        //TODO: apply condition - ?
        return new ExpressionWithCondition(x.e.multiply(this), x.condition);
    };

    ExpressionWithCondition.prototype.add = function(y) {
        return y.addExpressionWithCondition(this);
    };
    ExpressionWithCondition.prototype.addExpressionWithCondition = function(x) {
        throw new TypeError("TODO:");
    };
    Expression.prototype.addExpressionWithCondition = function(x) {
        //TODO: apply condition - ?
        return new ExpressionWithCondition(x.e.add(this), x.condition);
    };

    Expression.ExpressionWithCondition = ExpressionWithCondition;

    self.Expression = Expression;

    //TODO: ?
    Addition.prototype.compare4MultiplicationNthRoot = function(x) {
        return +1;
    };
    Multiplication.prototype.compare4MultiplicationNthRoot = function(x) {
        return -1; //TODO: ?
    };



    // piecewise functions
    // https://en.wikipedia.org/wiki/Piecewise
    // https://en.wikibooks.org/wiki/LaTeX/Advanced_Mathematics#The_cases_environment

    function Cases(cases) {
        this.cases = cases;
    }

    Cases.prototype = Object.create(Expression.prototype);

    Cases.prototype._cross = function(x, f) {
        var y = this;
        var result = [];
        for (var i = 0; i < x.cases.length; i += 1) {
            for (var j = 0; j < y.cases.length; j += 1) {
                var condition = x.cases[i].condition.and(y.cases[j].condition);
                //TODO: check
                if (!condition.isFalse()) {
                    var e = f(x.cases[i].e, y.cases[j].e);
                    result.push(new ExpressionWithCondition(e, condition));
                }
            }
        }
        return new Expression.Cases(result);
    };

    Cases.prototype.multiply = function(y) {
        return y.multiplyCases(this);
    };
    Cases.prototype.multiplyCases = function(x) {
        return this._cross(x, function(a, b) {
            return a.multiply(b);
        });
    };
    Cases.prototype.toString = function() { //TODO: ?
        var s = '';
        for (var i = 0; i < this.cases.length; i += 1) {
            s += '(' + this.cases[i].toString() + ')' + ',';
        }
        return '{{' + s.slice(0, -1) + '}}';
    };
    Expression.prototype.multiplyCases = function(x) {
        var y = this;
        return new Cases(x.cases.map(function(c) {
            return c.multiply(y);
        }));
    };

    Cases.prototype.multiplyExpression =
        Cases.prototype.multiplyMatrix = function(x) {
            return new Cases(this.cases.map(function(c) {
                return x.multiply(c);
            }));
        };

    Cases.prototype.add = function(y) {
        return y.addCases(this);
    };
    Cases.prototype.addCases = function(x) {
        return this._cross(x, function(a, b) {
            return a.add(b);
        });
    };
    Expression.prototype.addCases = function(x) {
        var y = this;
        return new Cases(x.cases.map(function(c) {
            return c.add(y);
        }));
    };

    Cases.prototype.equals = function(b) {
        var a = this;
        if (a === b) {
            return true;
        }
        if (!(b instanceof Cases)) {
            //TODO: check that zero becomes zero
            return false;
        }
        //TODO: fix
        throw new TypeError();
        //return false;
    };

    Cases.prototype.toMathML = function(printOptions) {
        // https://www.w3.org/TR/2006/NOTE-arabic-math-20060131/#Moroccan
        var s = '';
        s += '<mrow>';
        s += '<mo>{</mo>';
        s += '<mtable rowspacing="0ex" columnalign="left">';
        for (var i = 0; i < this.cases.length; i += 1) {
            var x = this.cases[i];
            s += '<mtr>';
            s += '<mtd>';
            s += x.e.toMathML(printOptions);
            s += '</mtd>';
            s += '<mtd>';
            // <mtext> if </mtext> - ?
            s += x.condition.toMathML(printOptions);
            s += '</mtd>';
            s += '</mtr>';
        }
        s += '</mtable>';
        s += '</mrow>';
        return s;
    };

    Expression.Cases = Cases;


    Expression.Factorial = function(n) {
        this.n = n;
    };
    Expression.Factorial.prototype = Object.create(Expression.prototype);

    Expression.prototype.factorial = function() {
        //a = a.unwrap();
        var n = this;
        if (!(n instanceof Expression.Integer)) {
            throw new TypeError("NotSupportedError");
        }
        if (n.compareTo(Expression.ZERO) < 0) {
            throw new TypeError("NotSupportedError");
        }
        var f = Expression.ONE;
        for (var i = n; i.compareTo(Expression.ONE) >= 0; i = i.subtract(Expression.ONE)) {
            f = f.multiply(i);
        }
        return f;
    };

    Expression.prototype._abs = function() {
        return this.isNegative() ? this.negate() : this;
    };


    //?
    Expression.Comma = function(a, b) {
        BinaryOperation.call(this, a, b);
    };
    Expression.Comma.prototype = Object.create(BinaryOperation.prototype);
    Expression.Comma.prototype.getS = function() {
        return ",\u200B ";
    };
    Expression.prototype.transformComma = function(b) {
        var a = this;
        var equations = function(e) {
            if (e instanceof Expression.Equality) {
                return [{
                    left: e.a,
                    right: e.b
                }];
            }
            if (e instanceof Expression.NoAnswerExpression && e.name === 'system-of-equations') {
                return e.second.equations;
            }
            if (e instanceof Expression.Inequality) {
                return [{
                    left: e.a,
                    right: e.b,
                    sign: e.sign
                }];
            }
            if (e instanceof Expression.NoAnswerExpression && e.name === 'polynomial-roots') {
                var ee = e.second.polynomial.calcAt(e.second.variable);
                //TODO: use original input expression
                return [{
                    left: ee,
                    right: Expression.ZERO
                }];
            }
            return null;
        };
        var ae = equations(a);
        var be = equations(b);
        //TODO: do not use NonSimplifiedExpression - ? and systemo-of-equations (?) or change (!)
        if (ae != null && be != null) {
            return Expression.SystemOfEquations.from(ae.concat(be));
        }
        if (ae == null && be == null) {
            return new Expression.List((a instanceof Expression.List ? a.list : [a]).concat(b instanceof Expression.List ? b.list : [b]));
        }
        throw new TypeError("NotSupportedError");
    };

    Expression.List = function(list) {
        this.list = list;
    };
    Expression.List.prototype = Object.create(Expression.prototype);
    Expression.List.prototype.min = function() {
        return this.list.reduce(function(result, value) {
            return result.compareTo(value) > 0 ? value : result;
        });
    };
    Expression.List.prototype.max = function() {
        return this.list.reduce(function(result, value) {
            return result.compareTo(value) < 0 ? value : result;
        });
    };
    Expression.List.prototype.gcd = function() {
        return this.list.reduce(function(result, value) {
            return result.gcd(value);
        });
    };

    Expression.Logarithm = function(argument) {
        Expression.Function.call(this, "log", argument);
    };
    Expression.Logarithm.prototype = Object.create(Expression.Function.prototype);
    Expression.prototype.logarithm = function() {
        var arg = this;
        if (arg instanceof Expression.Integer) {
            if (arg.compareTo(Expression.ZERO) <= 0) {
                throw new TypeError("ArithmeticException"); //TODO: better message
            }
            if (arg.compareTo(Expression.ONE) === 0) {
                return Expression.ZERO;
            }
            var p = integerPrimeFactor(arg);
            if (p.equals(arg)) {
                return new Expression.Logarithm(arg);
            }
            var ctz = primeFactor._countTrailingZeros(arg.toBigInt(), p.toBigInt());
            return p.logarithm().multiply(Integer.fromNumber(ctz)).add(arg.truncatingDivide(p._pow(ctz)).logarithm());
        }
        if (arg instanceof Expression.Division) {
            var n = arg.getNumerator();
            var d = arg.getDenominator();
            if (d instanceof Integer || isConstant(n)) {
                return n.logarithm().subtract(d.logarithm());
            }
        }
        if (arg instanceof Expression.Multiplication) {
            var c = arg.a;
            if (isConstant(c)) {
                return c.logarithm().add(arg.divide(c).logarithm());
            }
            var c = getConstant(arg);
            if (c instanceof Integer && !c.equals(Expression.ONE)) {
                return c.logarithm().add(arg.divide(c).logarithm());
            }
            if (arg.b instanceof Expression.MatrixSymbol) { //?
                return arg.a.logarithm().add(arg.b.logarithm());
            }
        }
        if (arg instanceof Expression.ExpressionWithPolynomialRoot) {
            arg = arg.upgrade(); //?
        }
        if (arg instanceof Expression.ExpressionPolynomialRoot) {
            var g = arg.root.upgrade().getAlpha().polynomial.getGCDOfTermDegrees();
            if (g > 1) {
                return arg._pow(g).logarithm().divide(Expression.Integer.fromNumber(g));
            }
        }
        //TODO: other kinds of polynomial roots (?)
        if (arg instanceof Expression.Symbol) {
            if (arg === Expression.E) { //?
                return Expression.ONE;
            }
            return new Expression.Logarithm(arg);
        }
        if (arg instanceof Expression.NthRoot) {
            var a = arg.a;
            var n = arg.n;
            if (a instanceof Expression.Integer && a.compareTo(Expression.ONE) > 0) {
                return a.logarithm().divide(Expression.Integer.fromNumber(n));
            }
            if (isPositive(a)) {
                return a.logarithm().divide(Expression.Integer.fromNumber(n));
            }
        }
        if (arg instanceof Expression.Exponentiation) {
            var b = getBase(arg);
            var e = getExponent(arg);
            if (b === Expression.E) { //?
                return e;
            }
            if (b instanceof Expression.MatrixSymbol && e instanceof Integer) { //?
                return b.logarithm().multiply(e);
            }
            if (b instanceof Expression.Integer) {
                return b.logarithm().multiply(e);
            }
        }
        if (arg instanceof Expression.Matrix) {
            var matrix = arg.matrix;
            if (matrix.isDiagonal()) {
                return new Expression.Matrix(matrix.map(function(e, i, j) {
                    return i === j ? e.logarithm() : Expression.ZERO;
                }));
            }
            var eigenvalues = Expression.getEigenvalues(matrix);
            if (eigenvalues.length === matrix.cols()) {
                var eigenvectors = Expression.getEigenvectors(matrix, eigenvalues);
                if (eigenvectors.filter(function(v) {
                        return v != null;
                    }).length === matrix.cols()) {
                    if (Expression.callback != undefined) {
                        Expression.callback(new Expression.Event("logarithm-using-diagonalization", new Expression.Matrix(matrix))); //TODO:
                    }
                    var tmp = Expression.diagonalize(matrix, eigenvalues, eigenvectors);
                    // https://en.wikipedia.org/wiki/Logarithm_of_a_matrix#Calculating_the_logarithm_of_a_diagonalizable_matrix
                    return new Expression.Matrix(tmp.T).multiply(new Expression.Matrix(tmp.L).logarithm()).multiply(new Expression.Matrix(tmp.T_INVERSED));
                } else {
                    var tmp = Expression.getFormaDeJordan(matrix, eigenvalues);
                    // https://en.wikipedia.org/wiki/Logarithm_of_a_matrix#The_logarithm_of_a_non-diagonalizable_matrix
                    var J = tmp.J;
                    var logarithmOfJordanBlockMatrix = function(B) {
                        var K = B.map(function(e, i, j) {
                            return i !== j ? e.divide(B.e(i, i)) : Expression.ZERO;
                        });
                        var S = B.map(function(e, i, j) {
                            return i === j ? e.logarithm() : Expression.ZERO;
                        });
                        var n = B.cols();
                        for (var i = 1; i < n; i += 1) {
                            var x = K.pow(i).scale(Expression.ONE.divide(Expression.Integer.fromNumber(i)));
                            S = i % 2 === 1 ? S.add(x) : S.subtract(x);
                        }
                        return S;
                    };
                    var LJ = logarithmOfJordanBlockMatrix(J);
                    //if (!J.eql(matrix)) {
                    //TODO:
                    if (Expression.callback != undefined) {
                        Expression.callback(new Expression.Event("logarithm-using-Jordan-canonical-form", new Expression.Matrix(matrix)));
                    }
                    //}
                    return new Expression.Matrix(tmp.P).multiply(new Expression.Matrix(LJ)).multiply(new Expression.Matrix(tmp.P_INVERSED));
                }
            }
        }
        if (arg instanceof Expression.Addition) {
            var c = getConstant(arg);
            if (!c.equals(Expression.ONE)) {
                return c.logarithm().add(arg.divide(c).logarithm());
            }
            if (arg.a instanceof Expression.Symbol && arg.b instanceof Expression.Integer) {
                return new Expression.Logarithm(arg);
            }
            var v = getVariableInternal(getLastMultiplicationOperand(getFirstAdditionOperand(arg))).next().value.v; // avoid square roots
            if (v instanceof Expression.Symbol) {
                var p = Polynomial.toPolynomial(arg, v);
                var c = p.getContent();
                if (c.isNegative()) {
                    c = c.negate();
                }
                if (isPositive(c) && !c.equals(Expression.ONE)) {
                    return arg.divide(c).logarithm().add(c.logarithm());
                }
                //TODO: check
                var sf = p.getSquareFreePolynomial();
                var n = Math.floor(p.getDegree() / sf.getDegree());
                if (n > 1 && sf.calcAt(v)._pow(n).equals(arg)) {
                    return Expression.Integer.fromNumber(n).multiply(sf.calcAt(v).logarithm());
                }
            }
            if (isGoodPolynomial(arg)) { //?
                return new Expression.Logarithm(arg);
            }
        }
        var qi = QuadraticInteger.toQuadraticInteger(arg); //?
        if (qi != null && (Number(qi.a.toString()) > 0 || Number(qi.b.toString()) > 0) && qi.D > 0 && (qi.isValid() || qi.D === 5 || qi.D === 37)) {
            var f = qi.primeFactor();
            if (f.toExpression().equals(Expression.TWO)) { //TODO: !?
                qi = qi.truncatingDivide(f);
                f = qi.primeFactor();
            }
            if (!f.equals(qi)) {
                return f.toExpression().logarithm().add(arg.divide(f.toExpression()).logarithm());
            }
            if (Number(qi.a.toString()) > 0 && Number(qi.b.toString()) > 0) {
                //return new Expression.ExponentiationOfQuadraticInteger(x, y);
                return new Expression.Logarithm(arg);
            }
            if (Number(qi.a.toString()) < 0 || Number(qi.b.toString()) < 0) {
                var xc = qi.conjugate().toExpression();
                if (xc.isNegative()) {
                    xc = xc.negate();
                }
                return arg.multiply(xc).logarithm().subtract(xc.logarithm());
            }
        }
        if (arg instanceof Addition && arg.b instanceof NthRoot && arg.a instanceof NthRoot) { //TODO: ? multiple operands - ?
            var g = nthRootCommonFactor(arg.a, arg.b);
            if (!g.equals(Expression.ONE) && isPositive(g)) {
                return g.logarithm().add(arg.divide(g).logarithm());
            }
        }
        if (Expression.isConstant(arg)) {
            var sd = simpleDivisor(arg);
            if (!sd.equals(arg)) {
                return sd.logarithm().add(arg.divide(sd).logarithm());
            }
        }
        throw new TypeError("NotSupportedError");
    };


    //!new
    NthRoot.prototype.compare4MultiplicationExponentiation = Exponentiation.prototype.compare4MultiplicationExponentiation;
    Expression.Symbol.prototype.compare4MultiplicationExponentiation = Exponentiation.prototype.compare4MultiplicationExponentiation;


    //!new
    Expression.prototype.complexConjugate = function() {
        throw new TypeError("NotSupportedError");
    };
    Expression.Integer.prototype.complexConjugate = function() {
        return this;
    };
    // https://en.wikipedia.org/wiki/Complex_conjugate#Properties
    Expression.Division.prototype.complexConjugate = function() {
        return this.getNumerator().complexConjugate().divide(this.getDenominator().complexConjugate());
    };
    Expression.Multiplication.prototype.complexConjugate = function() {
        return this.a.complexConjugate().multiply(this.b.complexConjugate());
    };
    Expression.Addition.prototype.complexConjugate = function() {
        return this.a.complexConjugate().add(this.b.complexConjugate());
    };
    Expression.Function.prototype.complexConjugate = function() {
        if (this.a instanceof Integer || Expression.isReal(this)) {
            return this;
        }
        throw new TypeError("NotSupportedError"); //TODO: ?
    };
    Expression.Matrix.prototype.complexConjugate = function() {
        var a = this;
        return new Expression.Matrix(a.matrix.map(function(x) {
            return x.complexConjugate();
        }));
    };
    Expression.Symbol.prototype.complexConjugate = function() {
        if (this === Expression.E || this === Expression.PI || Expression.isReal(this)) {
            return this;
        }
        return new Expression.ComplexConjugate(this);
    };
    //TODO: complexConjugate(log(z)) = log(complexConjugate(z))
    Expression.Exponentiation.prototype.complexConjugate = function() {
        // complexConjugate(exp(z)) = exp(complexConjugate(z))
        if (getBase(this) === Expression.E) {
            return getBase(this).pow(getExponent(this).complexConjugate());
        }
        // complexConjugate(z**n) = complexConjugate(z)**n
        if (isIntegerOrN(getExponent(this))) { //?
            return getBase(this).complexConjugate().pow(getExponent(this));
        }
        if (isMatrixSymbolTranspose(this)) {
            //return getBase(this).complexConjugate().pow(getExponent(this));
            return new Expression.Exponentiation(getBase(this).complexConjugate(), getExponent(this));
        }
        if (Expression.isReal(this)) {
            return this;
        }
        throw new TypeError("NotSupportedError"); //TODO: ?
    };
    Expression.Logarithm.prototype.complexConjugate = function() {
        return this.a.complexConjugate().logarithm();
    };


    Expression.ComplexConjugate = function(a) {
        Expression.Function.call(this, "conjugate", a);
    };
    Expression.ComplexConjugate.prototype = Object.create(Expression.Function.prototype);

    Expression.ComplexConjugate.prototype.complexConjugate = function() {
        return this.a;
    };

    Expression.AugmentedMatrix = function(A, B) {
        Expression.Function.call(this, "augment", null);
        this.a = A;
        this.b = B;
    };
    Expression.AugmentedMatrix.prototype = Object.create(Expression.Function.prototype);
    Expression.AugmentedMatrix.prototype.toString = function(options) {
        //TODO:
        return '(' + this.a.toString(options) + '|' + this.b.toString(options) + ')';
    };
    Expression.AugmentedMatrix.prototype.toMathML = function(options) {
        //TODO:
        return '<mrow>' + '<mo>(</mo>' + this.a.toMathML(options) + '<mo>|</mo>' + this.b.toMathML(options) + '<mo>)</mo>' + '</mrow>';
    };

    Expression.Abs = function(a) {
        Expression.Function.call(this, "abs", a);
    };
    Expression.Abs.prototype = Object.create(Expression.Function.prototype);
    Expression.Abs.prototype.toMathML = function(options) {
        //TODO:
        return '<mrow>' + '<mo stretchy="false">|</mo>' + this.a.toMathML(options) + '<mo stretchy="false">|</mo>' + '</mrow>';
    };
    Expression.Abs.prototype.complexConjugate = function() {
        return this;
    };
    Expression.Abs.prototype.pow = function(y) {
        if (y instanceof Expression.Integer) {
            return this.a.pow(y).abs()
        }
        return Expression.Function.prototype.pow.call(this, y);
    };


    Expression.Matrix.prototype.pseudoinverse = function() {
        var tmp = Expression.SVD(this.matrix);
        // https://en.wikipedia.org/wiki/Moore–Penrose_inverse#Singular_value_decomposition_(SVD)
        return new Expression.Matrix(tmp.Vstar.conjugateTranspose().multiply(tmp.Sigma.map(function(e) {
            return e.equals(Expression.ZERO) ? Expression.ZERO : e.inverse();
        })).multiply(tmp.U.conjugateTranspose()));
    };
    Expression.Pseudoinverse = function(matrix) {
        Expression.Function.call(this, "pseudoinverse", matrix);
    };
    Expression.Pseudoinverse.prototype = Object.create(Expression.Function.prototype);

})();
(function() {
    "use strict";




    var BASE = 2;
    //var BASE = 10;

    function MakeMath(BigDecimal, BASE) {
        function BigDecimalMath() {}
        BigDecimalMath.nextAfter = function(a, rounding) {
            if (rounding == undefined) {
                throw new RangeError();
            }
            if (rounding.roundingMode !== 'floor' && rounding.roundingMode !== 'ceil') {
                throw new RangeError();
            }
            var t = BigDecimal.round(a, rounding);
            if (!BigDecimal.equal(a, t)) {
                return t;
            }
            var _nextAfter = function(a, k, v, rounding) {
                var small = BigDecimal.multiply(BigDecimal.BigDecimal(rounding.roundingMode === 'floor' ? -1 : 1), exponentiateBase(-k));
                var aim = BigDecimal.multiply(BigDecimal.abs(v), small);
                return BigDecimal.add(a, aim, rounding);
            };
            if (rounding.maximumFractionDigits != undefined) {
                return _nextAfter(a, rounding.maximumFractionDigits, BigDecimal.BigDecimal(1), rounding);
            }
            if (rounding.maximumSignificantDigits != undefined) {
                // a * (1 + 1 / Math.pow(2, maximumSignificantDigits))
                return _nextAfter(a, rounding.maximumSignificantDigits, a, rounding);
            }
            throw new RangeError();
        };
        //TODO: remove
        //BigDecimalMath.fma = function (a, b, c, rounding) { // a * b + c
        //  return BigDecimal.round(BigDecimal.add(BigDecimal.multiply(a, b), c), rounding);
        //};
        var exponentiateBase = function(n) {
            var BIG_DECIMAL_BASE = BigDecimal.round(BigDecimal.BigDecimal(BASE), {
                maximumSignificantDigits: 1,
                roundingMode: 'half-even'
            });
            var a = BIG_DECIMAL_BASE;
            if (n < 0) {
                return BigDecimal.divide(BigDecimal.BigDecimal(1), exponentiateBase(-n), null);
            }
            var y = BigDecimal.BigDecimal(1);
            while (n >= 1) {
                if (0 === n % 2) {
                    a = BigDecimal.multiply(a, a);
                    n = n / 2;
                } else {
                    y = y == undefined ? a : BigDecimal.multiply(a, y);
                    n = n - 1;
                }
            }
            return y;
        };
        return BigDecimalMath;
    }

    var BigDecimalMath = MakeMath(BigDecimal, 10);
    var BigFloatMath = MakeMath(BigFloat, 2);

    //BigDecimalMath.nthRoot(BigDecimal.BigDecimal(2), 2, 3);






    // https://en.wikipedia.org/wiki/Interval_arithmetic
    function Interval(a, b) {
        if (BigFloat.greaterThan(a, b)) {
            throw new TypeError();
        }
        this.a = a;
        this.b = b;
    }
    Interval._rounding = function(baseRounding, roundingMode) {
        if (baseRounding == null) {
            return null;
        }
        return baseRounding.maximumFractionDigits != undefined ?
            {
                maximumFractionDigits: baseRounding.maximumFractionDigits,
                roundingMode: roundingMode
            } :
            {
                maximumSignificantDigits: baseRounding.maximumSignificantDigits,
                roundingMode: roundingMode
            };
    };
    Interval.unaryMinus = function(x) {
        return new Interval(BigFloat.unaryMinus(x.b), BigFloat.unaryMinus(x.a));
    };
    Interval.add = function(x, y, rounding) {
        rounding = rounding == undefined ? null : rounding;

        return new Interval(BigFloat.add(x.a, y.a, Interval._rounding(rounding, 'floor')), BigFloat.add(x.b, y.b, Interval._rounding(rounding, 'ceil')));
    };
    Interval.subtract = function(x, y, rounding) {
        rounding = rounding == undefined ? null : rounding;

        return new Interval(BigFloat.subtract(x.a, y.b, Interval._rounding(rounding, 'floor')), BigFloat.subtract(x.b, y.a, Interval._rounding(rounding, 'ceil')));
    };
    Interval._multiply = function(x1, x2, y1, y2, f) {
        var sign = BigFloat.sign;
        var sx1 = sign(x1);
        var sx2 = sign(x2);
        var sy1 = sign(y1);
        var sy2 = sign(y2);
        if (sx1 >= 0) {
            if (sy1 >= 0) {
                return f(x1, y1, x2, y2);
            }
            if (sy2 <= 0) {
                return f(x2, y1, x1, y2);
            }
            // y1 < 0 && y2 > 0
            return f(x2, y1, x2, y2);
        }
        if (sx2 <= 0) {
            if (sy2 <= 0) {
                return f(x2, y2, x1, y1);
            }
            if (sy1 >= 0) {
                return f(x1, y2, x2, y1);
            }
            // y1 < 0 && y2 > 0
            return f(x1, y2, x1, y1);
        }
        if (sy1 >= 0) { // x1 < 0 && x2 > 0
            return f(x1, y2, x2, y2);
        }
        if (sy2 <= 0) { // x1 < 0 && x2 > 0
            return f(x2, y1, x1, y1);
        }
        // x1 < 0 && x2 > 0 && y1 < 0 && y2 > 0
        var interval1 = f(x1, y2, x1, y1);
        var interval2 = f(x2, y1, x2, y2);
        return new Interval(BigFloat.min(interval1.a, interval2.a),
            BigFloat.max(interval1.b, interval2.b));
    };
    Interval.multiply = function(x, y, rounding) {
        rounding = rounding == undefined ? null : rounding;

        var floorRounding = Interval._rounding(rounding, 'floor');
        var ceilRounding = Interval._rounding(rounding, 'ceil');
        if (BigFloat.equal(x.a, x.b) && BigFloat.equal(y.a, y.b)) {
            var product = BigFloat.multiply(x.a, y.a);
            return new Interval(BigFloat.round(product, floorRounding), BigFloat.round(product, ceilRounding));
        }
        var f = function(a, b, c, d) {
            return new Interval(BigFloat.multiply(a, b, floorRounding), BigFloat.multiply(c, d, ceilRounding));
        };
        return Interval._multiply(x.a, x.b, y.a, y.b, f);
    };
    Interval.divide = function(x, y, rounding) {
        var floorRounding = Interval._rounding(rounding, 'floor');
        var ceilRounding = Interval._rounding(rounding, 'ceil');
        if (BigFloat.sign(y.a) <= 0 && BigFloat.sign(y.b) >= 0) {
            if (BigFloat.equal(y.a, y.b)) {
                throw new RangeError();
            }
            return "CANNOT_DIVIDE"; //TODO: FIX
        }
        if (BigFloat.equal(x.a, x.b) && BigFloat.equal(y.a, y.b)) {
            //TODO: is it faster in all cases - ?
            var q = BigFloat.divide(x.a, y.a, floorRounding);
            var r = BigFloat.subtract(x.a, BigFloat.multiply(y.a, q));
            return new Interval(q, !BigFloat.equal(r, BigFloat.BigFloat(0)) ? BigFloatMath.nextAfter(q, ceilRounding) : q);
        }
        var f = function(a, d, c, b) {
            //Note: b and d are swapped
            return new Interval(BigFloat.divide(a, b, floorRounding), BigFloat.divide(c, d, ceilRounding));
        };
        return Interval._multiply(x.a, x.b, y.a, y.b, f);
    };
    Interval.sqrt = function(x, rounding) {
        if (BigFloat.sign(x.a) < 0 && BigFloat.sign(x.b) >= 0) {
            return "CANNOT_DIVIDE"; //TODO: FIX
        }
        if (BigFloat.equal(x.a, x.b)) {
            var ya = BigFloat.sqrt(x.a, Interval._rounding(rounding, 'floor'));
            var yb = BigFloat.equal(BigFloat.multiply(ya, ya), x.b) ? ya : BigFloatMath.nextAfter(ya, Interval._rounding(rounding, 'ceil'));
            return new Interval(ya, yb);
        }
        return Interval._map(x, function(x, rounding) {
            return BigFloat.sqrt(x, rounding);
        }, rounding);
    };
    Interval.exp = function(x, rounding) {
        return Interval._map(x, BigFloat.exp, rounding);
    };
    Interval.log = function(x, rounding) {
        if (BigFloat.sign(x.a) <= 0 && BigFloat.sign(x.b) > 0) {
            return "CANNOT_DIVIDE"; //TODO: FIX
        }
        if (BigFloat.equal(x.a, x.b) && BigFloat.equal(x.b, BigFloat.BigFloat(1))) {
            return new Interval(BigFloat.BigFloat(0), BigFloat.BigFloat(0));
        }
        return Interval._map(x, BigFloat.log, rounding);
    };
    Interval.atan = function(x, rounding) {
        return Interval._map(x, BigFloat.atan, rounding);
    };
    Interval._mapValue = function(value, callback, rounding) {
        var c = callback(value, Interval._rounding(rounding, 'floor')); // TODO: ?
        //var a = BigFloatMath.nextAfter(c, Interval._rounding(rounding, 'floor'));
        var a = c;
        var b = c;
        if (!BigFloat.equal(value, BigFloat.BigFloat(0))) {
            b = BigFloatMath.nextAfter(c, Interval._rounding(rounding, 'ceil'));
        }
        return new Interval(a, b);
    };
    Interval._map = function(x, callback, rounding) {
        if (BigFloat.equal(x.a, x.b)) {
            return Interval._mapValue(x.a, callback, rounding);
        }
        var a = callback(x.a, Interval._rounding(rounding, 'floor'));
        var b = callback(x.b, Interval._rounding(rounding, 'ceil'));
        return new Interval(a, b);
    };
    Interval._trigonometry = function(x, which, rounding) {
        if (BigFloat.equal(x.a, x.b)) {
            return Interval._mapValue(x.a, which === 'sin' ? BigFloat.sin : BigFloat.cos, rounding);
        }
        var anyRounding = Object.assign({}, Interval._rounding(rounding, 'floor'), {
            roundingMode: 'half-even'
        });
        var tau = BigFloat.multiply(BigFloat.BigFloat(8), BigFloat.atan(BigFloat.BigFloat(1), anyRounding));
        if (!BigFloat.lessThan(BigFloat.subtract(x.b, x.a), tau)) {
            return new Interval(BigFloat.BigFloat(-1), BigFloat.BigFloat(+1));
        }
        var f = function(x, rounding) {
            return which === 'sin' ? BigFloat.sin(x, rounding) : BigFloat.cos(x, rounding);
        };
        var middle = BigFloat.divide(BigFloat.add(x.a, x.b), BigFloat.BigFloat(2), anyRounding); // with rounding it works better in case the interval has huge significant digits difference
        var extremumPoint = function(q) {
            var shift = BigFloat.multiply(BigFloat.divide(BigFloat.BigFloat(q), BigFloat.BigFloat(4), anyRounding), tau);
            var k = BigFloat.round(BigFloat.divide(BigFloat.subtract(middle, shift, anyRounding), tau, anyRounding), {
                maximumFractionDigits: 0,
                roundingMode: 'half-even'
            });
            return BigFloat.add(BigFloat.multiply(tau, k), shift);
        };
        var minimumPoint = extremumPoint(which === 'sin' ? 3 : 2);
        var maximumPoint = extremumPoint(which === 'sin' ? 1 : 0);
        var floorRounding = Interval._rounding(rounding, 'floor');
        var ceilRounding = Interval._rounding(rounding, 'ceil');
        var fmin = BigFloat.lessThan(minimumPoint, x.a) ? f(x.a, floorRounding) : (BigFloat.greaterThan(minimumPoint, x.b) ? f(x.b, floorRounding) : BigFloat.BigFloat(-1));
        var fmax = BigFloat.lessThan(maximumPoint, x.a) ? f(x.a, ceilRounding) : (BigFloat.greaterThan(maximumPoint, x.b) ? f(x.b, ceilRounding) : BigFloat.BigFloat(+1));
        /**/
        return new Interval(fmin, fmax);
    };
    Interval.sin = function(x, rounding) {
        return Interval._trigonometry(x, 'sin', rounding);
    };
    Interval.cos = function(x, rounding) {
        return Interval._trigonometry(x, 'cos', rounding);
    };
    /*Interval.fromInteger = function (a) {
      if (BASE !== 2) {
        var abs = function (a) {
          return a < 0 ? BigInteger.unaryMinus(a) : a;
        };
        var k = a != 0 ? bitLength(abs(a)) - Math.ceil(Math.log2(10) * Interval._rounding(rounding, 'floor').maximumSignificantDigits) : 0;
        if (k > 42) {
          //TODO: move to BigFloat.round - ?
          // for performance
          var p2k = BigInteger.exponentiate(BigInteger.BigInt(2), BigInteger.BigInt(k));
          var q = BigInteger.divide(a, p2k);
          var from = a < 0 ? BigInteger.subtract(q, BigInteger.BigInt(1)) : q;
          var to = a < 0 ? q : BigInteger.add(q, BigInteger.BigInt(1));
          return Interval.multiply(Interval.fromIntegers(from, to), Interval.exponentiate(Interval.fromIntegers(2, 2), k));
        }
      }
      //var x = BigFloat.BigFloat(a);
      //if (BigInteger.equal(BigInteger.BigInt(BigFloat.toBigInt(x)), a)) { // TODO: ?
      //  return new Interval(x, x);
      //}
      a = BigFloat.BigFloat(a);
      return new Interval(a, a);
      //return Interval.fromIntegers(a, a);
    };*/
    Interval.fromIntegers = function(a, b) {
        var a1 = BigFloat.BigFloat(a);
        var b1 = BigFloat.BigFloat(b);
        //TODO: test case (!!!)
        console.assert(!BigFloat.lessThan(b1, a1));
        return new Interval(a1, b1);
    };
    Interval.abs = function(x) {
        if (BigFloat.lessThan(x.a, BigFloat.BigFloat(0))) {
            if (BigFloat.lessThan(x.b, BigFloat.BigFloat(0))) {
                return new Interval(BigFloat.unaryMinus(x.b), BigFloat.unaryMinus(x.a));
            } else {
                return new Interval(BigFloat.BigFloat(0), BigFloat.max(BigFloat.unaryMinus(x.a), x.b));
            }
        }
        return x;
    };
    Interval.exponentiate = function(x, n, contextRounding) {
        var y = undefined;
        while (n >= 1) {
            if (n === 2 * Math.floor(n / 2)) {
                x = Interval.multiply(x, x, contextRounding);
                n = Math.floor(n / 2);
            } else {
                y = y == undefined ? x : Interval.multiply(x, y, contextRounding);
                n -= 1;
            }
        }
        return y;
    };

    //?

    // todo: for exact notation (?):
    // 10000 -> Math.pow(10, 4)
    // 15000 -> 15*10**3
    // 0.00015 -> 15*10**(-5)



    Interval.formatToDecimal = function(x, rounding) {
        // assume, that the value is not exact
        var signA = BigFloat.sign(x.a);
        var signB = BigFloat.sign(x.b);
        var sign = (signA || signB) === (signB || signA) ? (signA || signB) : 0;
        x = Interval.abs(x);
        var stringify = function(a, roundingMode) {
            if (rounding.fractionDigits != undefined) {
                return a.toFixed(rounding.fractionDigits, roundingMode);
            }
            return a.toPrecision(rounding.significantDigits, roundingMode);
        };
        var a = stringify(x.a, "half-up");
        var b = BigFloat.equal(x.a, x.b) ? a : stringify(x.b, "half-down");
        var isZero = function(a) {
            return !/[^0\.]/.test(a);
        };
        if (a === b && (sign !== 0 || isZero(a) && isZero(b))) {
            return (sign < 0 ? '-' : (sign > 0 && isZero(a) && isZero(b) ? '+' : '')) + a;
        }
        return undefined;
    };
    Interval.prototype.toString = function() {
        return "[" + this.a.toString() + ";" + this.b.toString() + "]";
    };

    var calcAt = function(polynomial, x, contextRounding) {
        var result = evaluateExpression(Expression.ZERO, contextRounding);
        for (var i = polynomial.getDegree(); i >= 0; i--) {
            result = Interval.multiply(result, x, contextRounding);
            var tmp = evaluateExpression(polynomial.getCoefficient(i), contextRounding);
            if (tmp === "CANNOT_DIVIDE" || tmp == undefined) {
                return tmp;
            }
            result = Interval.add(result, tmp, contextRounding);
        }
        return result;
    };


    var evaluateExpression = function(e, contextRounding) {
        if (e instanceof Expression.Integer) {
            var n = e.value;
            return Interval.fromIntegers(n, n);
        } else if (e instanceof Expression.NthRoot) {
            var a = e.a;
            var n = e.n;
            var y = evaluateExpression(a, contextRounding);
            if (y === "CANNOT_DIVIDE" || y == undefined) {
                return y;
            }
            if (n == 2) {
                return Interval.sqrt(y, contextRounding);
            }
            return Interval.exp(Interval.divide(Interval.log(y, contextRounding), Interval.fromIntegers(n, n), contextRounding), contextRounding);
        } else if (e instanceof Expression.BinaryOperation) {
            // slow for some cases:
            if (e instanceof Expression.Addition && Expression.has(e, Expression.PolynomialRootSymbol)) {
                var root = Expression.getVariable(e); //?
                var p = Polynomial.toPolynomial(e, root);
                if (p.hasIntegerCoefficients()) { // trying to avoid slow cases (?)
                    //TODO: https://en.wikipedia.org/wiki/Horner%27s_method - ?
                    var zero = evaluateExpression(root, contextRounding);
                    //return evaluateExpression(p.calcAt(), contextRounding);
                    return calcAt(p, zero, contextRounding);
                }
            }
            if (e.a === Expression.E && e.getS() === "^") {
                var b = evaluateExpression(e.b, contextRounding);
                if (b === "CANNOT_DIVIDE" || b == undefined) {
                    return b;
                }
                return Interval.exp(b, contextRounding);
            }

            var a = evaluateExpression(e.a, contextRounding);
            if (a === "CANNOT_DIVIDE" || a == undefined) {
                return a;
            }
            var b = evaluateExpression(e.b, contextRounding);
            if (b === "CANNOT_DIVIDE" || b == undefined) {
                return b;
            }
            var operator = e.getS();
            if (operator === "+") {
                return Interval.add(a, b, contextRounding);
            } else if (operator === "-") {
                return Interval.subtract(a, b, contextRounding);
            } else if (operator === "*") {
                return Interval.multiply(a, b, contextRounding);
            } else if (operator === "/") {
                return Interval.divide(a, b, contextRounding);
            } else if (operator === "^") { // Expression.PolynomialRootSymbol^3, pi^2, 2**(sqrt(3)), (log(2))^2
                //TODO: to polynomial
                if (!(e.b instanceof Expression.Integer) || e.b.toNumber() <= 0 || e.b.toNumber() > Number.MAX_SAFE_INTEGER) {
                    //throw new TypeError();
                    var log = Interval.log(a, contextRounding);
                    if (log === "CANNOT_DIVIDE") {
                        return log;
                    }
                    return Interval.exp(Interval.multiply(log, b, contextRounding), contextRounding);
                }
                var n = e.b.toNumber(); //TODO: FIX!
                return Interval.exponentiate(a, n, contextRounding);
            }
        } else if (e instanceof Expression.PolynomialRootSymbol || e instanceof Expression.ExpressionPolynomialRoot) {
            var i = (e instanceof Expression.ExpressionPolynomialRoot ? e.root : e).toDecimal(contextRounding.maximumSignificantDigits || contextRounding.maximumFractionDigits);
            // "lcm" is too slow to compute (?)
            /*if (true) {
              var a = BigFloat.divide(BigFloat.BigFloat(i.a.getNumerator().value), BigFloat.BigFloat(i.a.getDenominator().value), context.floorRounding);
              var b = BigFloat.divide(BigFloat.BigFloat(i.b.getNumerator().value), BigFloat.BigFloat(i.b.getDenominator().value), context.ceilRounding);
              return new Interval(a, b);
            }*/
            var d = i.a.getDenominator().multiply(i.b.getDenominator()).value;
            return Interval.divide(Interval.fromIntegers(i.b.getDenominator().multiply(i.a.getNumerator()).value,
                    i.a.getDenominator().multiply(i.b.getNumerator()).value),
                Interval.fromIntegers(d, d),
                contextRounding);
        } else if (e === Expression.E) {
            return Interval.exp(Interval.fromIntegers(1, 1), contextRounding);
        } else if (e === Expression.PI) {
            return Interval.multiply(Interval.fromIntegers(4, 4), Interval.atan(Interval.fromIntegers(1, 1), contextRounding));
        } else if (e instanceof Expression.Function) {
            var x = evaluateExpression((e instanceof Expression.Sin || e instanceof Expression.Cos) && e.a instanceof Expression.Radians ? e.a.value : e.a, contextRounding);
            if (x === "CANNOT_DIVIDE" || x == undefined) {
                return x;
            }
            if (e instanceof Expression.Sin) {
                return Interval.sin(x, contextRounding);
            }
            if (e instanceof Expression.Cos) {
                return Interval.cos(x, contextRounding);
            }
            if (e instanceof Expression.Logarithm) {
                return Interval.log(x, contextRounding);
            }
            if (e instanceof Expression.Arctan) {
                return Interval.atan(x, contextRounding);
            }
        } else if (e instanceof Expression.ExpressionWithPolynomialRoot) {
            return evaluateExpression(e.e, contextRounding);
        }

        return undefined;
    };

    var decimalToString = function(decimal) {
        return decimal.replace(/[eE]/g, '*10^');
    };

    var complexToString = function(real, imaginary) {
        return real + (/^[\-\+]/.test(imaginary) ? imaginary.replace(/^([\-\+])[\s\S]+/g, '$1') : (real !== '' ? '+' : '')) + (imaginary !== '1' && imaginary !== '-1' ? imaginary.replace(/^[\-\+]/g, '') + '*' + 'i' : 'i');
    };

    //? ((n * 10**(fractionDigits + 1)) ~/ d + 5) ~/ 10

    var toDecimalStringInternal = function(expression, rounding, decimalToStringCallback, complexToStringCallback) {
        decimalToStringCallback = decimalToStringCallback || decimalToString;
        complexToStringCallback = complexToStringCallback || complexToString;
        if (rounding.fractionDigits == undefined && rounding.significantDigits == undefined ||
            rounding.fractionDigits != undefined && rounding.significantDigits != undefined) { //?
            throw new RangeError();
        }
        if (rounding.fractionDigits != undefined && (rounding.fractionDigits < 0 || rounding.fractionDigits > Number.MAX_SAFE_INTEGER) ||
            rounding.significantDigits != undefined && (rounding.significantDigits < 1 || rounding.significantDigits > Number.MAX_SAFE_INTEGER) ||
            rounding.roundingMode != undefined) {
            throw new RangeError();
        }

        if (expression instanceof Expression.Complex || Expression.has(expression, Expression.Complex)) { //?TODO: ?
            var numerator = expression.getNumerator(); //.unwrap();
            var denominator = expression.getDenominator(); //.unwrap();
            if (denominator instanceof Expression.Integer ||
                Expression.has(denominator, Expression.PolynomialRootSymbol) ||
                Expression.has(denominator, Expression.ExpressionPolynomialRoot) ||
                Expression._isPositive(denominator)) { // e^2
                if (numerator instanceof Expression.Addition || numerator instanceof Expression.Multiplication || numerator instanceof Expression.Complex) {
                    var tmp = Expression.getComplexNumberParts(numerator);
                    var realValue = tmp.real;
                    var imaginaryValue = tmp.imaginary;
                    if (!imaginaryValue.equals(Expression.ZERO)) {
                        realValue = realValue.divide(denominator);
                        imaginaryValue = imaginaryValue.divide(denominator);
                        var real = realValue.equals(Expression.ZERO) ? '' : toDecimalStringInternal(realValue, rounding, decimalToStringCallback, complexToStringCallback);
                        var imaginary = toDecimalStringInternal(imaginaryValue, rounding, decimalToStringCallback, complexToStringCallback);
                        return complexToStringCallback(real, imaginary);
                    }
                }
            }
        }

        if (expression instanceof Expression.Integer || expression instanceof Expression.Division && expression.a instanceof Expression.Integer && expression.b instanceof Expression.Integer) {
            //TODO: ?
            if (true) { //TODO: ?
                return decimalToStringCallback(primeFactor._rationalNumberToDecimalString(expression.getNumerator().toBigInt(), expression.getDenominator().toBigInt(), rounding));
            }
        }
        //TODO: remove - ?
        /*TODO: enable
        if (expression instanceof Expression.NthRoot) {
          var a = expression.a;//.unwrap();
          if (a instanceof Expression.Integer) {
            var A = a.value;
            var n = expression.n;
            var scale = BigInteger.exponentiate(BigInteger.BigInt(10), BigInteger.BigInt(fractionDigits));
            var sA = BigInteger.multiply(A, BigInteger.exponentiate(scale, BigInteger.BigInt(n)));

            var x0 = nthRoot(sA, n);
            var x1 = BigInteger.lessThan(BigInteger.exponentiate(x0, BigInteger.BigInt(n)), sA) ? BigInteger.add(x0, BigInteger.BigInt(1)) : x0;

            // root - x0 < x1 - root
            // 2root < x0 + x1
            // Math.pow(2, n) * A < (x0 + x1)**n
            var nearest = BigInteger.lessThan(BigInteger.multiply(BigInteger.exponentiate(BigInteger.BigInt(2), BigInteger.BigInt(n)), sA), BigInteger.exponentiate(BigInteger.add(x0, x1), BigInteger.BigInt(n))) ? x0 : x1;
            //return toDecimalStringInternal(new Expression.Division(new Expression.Integer(nearest), new Expression.Integer(scale)), fractionDigits, decimalToStringCallback, complexToStringCallback);
            var context = new Interval.Context(fractionDigits + 1);
            var a = BigFloat.divide(BigFloat.BigFloat(nearest), BigFloat.BigFloat(scale));
            var result = Interval.formatToDecimal(new Interval(a, BigFloatMath.nextAfter(a, {maximumFractionDigits: fractionDigits + 1, roundingMode: 'ceil'})), fractionDigits);
            return decimalToStringCallback(result);
          }
        }
        */
        //---
        console.assert(BASE % 2 === 0);
        var result = undefined;
        var guessedPrecision = 1; //TODO: ?
        //!new
        //TODO: !!!
        //if (expression instanceof Expression.Multiplication && expression.a instanceof Expression.Integer && rounding.fractionDigits != undefined) {
        //guessedPrecision = 2 * bitLength(expression.a.toBigInt());
        //guessedPrecision  = 128;
        //}
        //!
        var flag0 = Expression.has(expression, Expression.Function) || Expression.has(expression, Expression.Exponentiation);
        while (result == undefined) {
            if (guessedPrecision > 60000 && guessedPrecision > (rounding.fractionDigits || rounding.significantDigits) * 4 * Math.log2(10)) {
                debugger;
                throw new TypeError();
            }
            //if (guessedPrecision > 1024) throw new Error();
            var contextRounding = flag0 ? {
                maximumSignificantDigits: guessedPrecision
            } : {
                maximumFractionDigits: guessedPrecision - 1
            };
            var x = evaluateExpression(expression, contextRounding);
            if (x == undefined) {
                return undefined;
            }
            if (x !== "CANNOT_DIVIDE") { // continue the loop otherwise
                result = Interval.formatToDecimal(x, rounding);
            }
            if (guessedPrecision > 1 && result == undefined) {
                //console.count('guessedPrecision > 1  && result == undefined');
            }
            if (x !== "CANNOT_DIVIDE" && result == undefined && rounding.fractionDigits != undefined && guessedPrecision === 1) { //TODO: ?
                var log10OfValue = BigFloat.max(BigFloat.abs(x.a), BigFloat.abs(x.b)).toFixed(0).length;
                guessedPrecision = Math.ceil(Math.max(log10OfValue * Math.log2(10), 2) / 2 + Math.log2(10) * rounding.fractionDigits / 2 * 2);
            }
            if (x !== "CANNOT_DIVIDE" && result == undefined && rounding.significantDigits != undefined && guessedPrecision === 1) { //TODO: ?
                if (BigFloat.sign(x.a) === BigFloat.sign(x.b)) { // zero is not part of the interval, so we know the minimal value
                    var tmp = BigFloat.log(BigFloat.min(BigFloat.abs(x.a), BigFloat.abs(x.b)), {
                        maximumSignificantDigits: 1,
                        roundingMode: 'half-even'
                    }).toFixed(0).length;
                    guessedPrecision = Math.max(Math.ceil(tmp * Math.log2(10) / 2), 1);
                }
            }
            guessedPrecision *= 2;
        }
        if (guessedPrecision !== 256) {
            //console.log(guessedPrecision);
        }
        return decimalToStringCallback(result);
    };

    self.toDecimalStringInternal = toDecimalStringInternal;

    toDecimalStringInternal.testables = {
        BigDecimalMath: BigDecimalMath,
        BigDecimal: BigDecimal,
        BigFloat: BigFloat,
        Interval: Interval
    };

})();
(function() {
    "use strict";


    function GF2(a) {
        this.a = a;
    }
    GF2.prototype = Object.create(Expression.prototype);

    Expression.GF2 = GF2;
    Expression.GF2.prototype.toString = function(options) {
        return "GF2(" + this.a.toString(Expression.setTopLevel(true, options)) + ")";
    };

    function GF2Value(value) {
        //Expression.call(this);
        this.value = value;
    }
    Expression.GF2Value = GF2Value;

    GF2Value.prototype = Object.create(Expression.prototype);
    Expression.GF2Value.prototype.equals = function(b) {
        if (Expression.ZERO === b) {
            return this.value === 0; //!
        }
        return false; //?
    };
    Expression.GF2Value.prototype.negate = function() {
        return new GF2Value(this.value === 0 ? 0 : 2 - this.value);
    };

    GF2Value.prototype.add = function(x) {
        if (x === Expression.ZERO) {
            return new GF2Value(this.value);
        }
        if (!(x instanceof GF2Value)) {
            throw new RangeError();
        }
        var v = this.value - 2 + x.value;
        return new GF2Value(v >= 0 ? v : v + 2);
    };

    GF2Value.prototype.multiply = function(x) {
        if (x === Expression.ZERO) {
            return new GF2Value(0);
        }
        if (!(x instanceof GF2Value)) {
            throw new RangeError();
        }
        var v = this.value * x.value;
        return new GF2Value(v - 2 * Math.floor(v / 2));
    };

    GF2Value.prototype.divide = function(x) {
        //if (!(x instanceof GF2Value)) {
        //  throw new RangeError();
        //}
        return new GF2Value(this.value);
    };

    Expression.prototype.GF2 = function() {
        var x = this;
        if (!(x instanceof Expression.Matrix)) {
            throw new RangeError("NotSupportedError"); //?
        }
        return new Expression.Matrix(x.matrix.map(function(e, i, j) {
            if (!(e.equals(Expression.ZERO) || e.equals(Expression.ONE))) {
                throw new TypeError();
            }
            return new Expression.GF2Value(e.equals(Expression.ZERO) ? 0 : 1);
        }));
    };

    GF2Value.prototype.toString = function(options) {
        return this.value.toString();
    };

})();
(function() {
    "use strict";



    var Integer = Expression.Integer;
    var Addition = Expression.Addition;
    var Multiplication = Expression.Multiplication;
    var Division = Expression.Division;
    var Exponentiation = Expression.Exponentiation;
    var BinaryOperation = Expression.BinaryOperation;

    var separateSinCos = function(e) {
        if (!(e instanceof Multiplication)) {
            throw new TypeError();
        }
        var sinCos = undefined;
        var other = undefined;
        var x = e;
        for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
            var v = y;
            if (v instanceof Sin || v instanceof Cos ||
                (v instanceof Exponentiation && (v.a instanceof Sin || v.a instanceof Cos))) {
                sinCos = sinCos == undefined ? v : sinCos.multiply(v);
            } else {
                other = other == undefined ? v : other.multiply(v);
            }
        }
        return {
            sinCos: sinCos == undefined ? Expression.ONE : sinCos,
            other: other == undefined ? Expression.ONE : other
        };
    };

    var expandMainOp = function(u) {
        return u;
    };

    var contractTrigonometryInternal = function(a, b) {
        // sin(a) * sin(b) = (cos(a - b) - cos(a + b)) / 2
        // sin(a) * cos(b) = (sin(a + b) + sin(a - b)) / 2
        // cos(a) * sin(b) = (sin(a + b) - sin(a - b)) / 2
        // cos(a) * cos(b) = (cos(a - b) + cos(a + b)) / 2
        var ax = a.a;
        var bx = b.a;
        if (a instanceof Sin && b instanceof Sin) {
            return ax.subtract(bx).cos().divide(Expression.TWO).subtract(ax.add(bx).cos().divide(Expression.TWO));
        }
        if (a instanceof Sin && b instanceof Cos) {
            return ax.add(bx).sin().divide(Expression.TWO).add(ax.subtract(bx).sin().divide(Expression.TWO));
        }
        if (a instanceof Cos && b instanceof Sin) {
            return ax.add(bx).sin().divide(Expression.TWO).subtract(ax.subtract(bx).sin().divide(Expression.TWO));
        }
        if (a instanceof Cos && b instanceof Cos) {
            return ax.subtract(bx).cos().divide(Expression.TWO).add(ax.add(bx).cos().divide(Expression.TWO));
        }
        throw new TypeError();
    };

    // page 306
    var contractTrigonometryPower = function(u) {
        var b = u.a;
        if (!(b instanceof Sin) && !(b instanceof Cos)) {
            return u;
        }
        var e = contractTrigonometryInternal(b, b).multiply(u.divide(b.multiply(b)));
        return contractTrigonometryRules(e.getNumerator()).divide(e.getDenominator());
    };

    // page 318
    var contractTrigonometryProduct = function(u) {
        var i = u.factors();
        var a = i.next().value;
        var b = i.next().value;
        var rest = Expression.ONE;
        var y = i.next().value;
        while (y != null) {
            rest = y.multiply(rest); //TODO: fix
            y = i.next().value;
        }

        if (a instanceof Exponentiation) {
            a = contractTrigonometryPower(a);
            return contractTrigonometryRules(a.multiply(b).multiply(rest));
        }
        if (b instanceof Exponentiation) {
            b = contractTrigonometryPower(b);
            return contractTrigonometryRules(a.multiply(b).multiply(rest));
        }
        // (a instanceof Sin || a instanceof Cos) && (b instanceof Sin || b instanceof Cos)
        var c = contractTrigonometryInternal(a, b);

        return contractTrigonometryRules(c.multiply(rest));
    };

    // page 317
    var contractTrigonometryRules = function(u) {
        var v = expandMainOp(u);
        if (v instanceof Exponentiation) {
            return contractTrigonometryPower(v);
        }
        if (v instanceof Multiplication) {
            var tmp = separateSinCos(v);
            var c = tmp.other;
            var d = tmp.sinCos;
            if (d.equals(Expression.ONE)) {
                return v;
            }
            if (d instanceof Sin || d instanceof Cos) {
                return v;
            }
            if (d instanceof Exponentiation) {
                return expandMainOp(c.multiply(contractTrigonometryPower(d)));
            }
            if (d instanceof Multiplication) {
                return expandMainOp(c.multiply(contractTrigonometryProduct(d)));
            }
            throw new TypeError();
        }
        if (v instanceof Addition) {
            var s = Expression.ZERO;
            var e = v;
            for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
                if (x instanceof Multiplication || x instanceof Exponentiation) {
                    s = s.add(contractTrigonometryRules(x));
                } else {
                    s = s.add(x);
                }
            }
            return s;
        }
        return v;
    };

    var map = function(f, u) {
        if (u instanceof Integer) {
            return f(u);
        }
        if (u instanceof Addition) {
            return f(map(f, u.a).add(map(f, u.b)));
        }
        if (u instanceof Multiplication) {
            return f(map(f, u.a).multiply(map(f, u.b)));
        }
        if (u instanceof Division) {
            return f(map(f, u.a).divide(map(f, u.b)));
        }
        if (u instanceof Exponentiation) {
            return f(map(f, u.a).pow(map(f, u.b)));
        }
        if (u instanceof Sin) {
            return f(map(f, u.a).sin());
        }
        if (u instanceof Cos) {
            return f(map(f, u.a).cos());
        }
        if (u instanceof Expression.Matrix) {
            return new Expression.Matrix(u.matrix.map(function(e, i, j) {
                return map(f, e);
            }));
        }
        if (u instanceof Expression.Polynomial) { //TODO: test case
            return new Expression.Polynomial(u.polynomial.map(function(c, d) {
                return map(f, c);
            }));
        }
        if (u instanceof Expression.GF2Value) {
            return u;
        }
        if (u instanceof Expression.NthRoot) {
            return f(u);
        }
        if (u instanceof Expression.Negation) {
            return u; //?
        }
        if (u instanceof Expression.Complex) {
            return u; //?
        }
        if (u instanceof Expression.NonSimplifiedExpression) {
            //TODO: fix
            return u; //?
        }
        if (u instanceof Expression.Degrees) {
            return u; //?
        }
        if (u instanceof Expression.Radians) {
            return u; //?
        }
        if (u instanceof Expression.Symbol) {
            return f(u); //?
        }
        if (u instanceof Expression.Arctan) {
            return f(map(f, u.a).arctan());
        }
        if (u instanceof Expression.Logarithm) {
            return f(map(f, u.a).logarithm());
        }
        if (u instanceof Expression.Determinant) {
            return f(map(f, u.a).determinant());
        }
        if (u instanceof Expression.Inequality) {
            return f(map(f, u.a).transformInequality(map(f, u.b), u.sign));
        }
        if (u instanceof Expression.ComplexConjugate) {
            return f(map(f, u.a).complexConjugate());
        }
        if (u instanceof Expression.Abs) {
            return f(map(f, u.a).abs());
        }
        throw new TypeError();
    };

    Expression._map = map;

    // page 303

    var expandTrigonometryRulesInternal = function(a, b, type) {
        if (type === "cos") {
            // cos(a + b) = cos(a) * cos(b) - sin(a) * sin(b)
            return expandTrigonometryRules(a, "cos").multiply(expandTrigonometryRules(b, "cos")).subtract(expandTrigonometryRules(a, "sin").multiply(expandTrigonometryRules(b, "sin")));
        }
        if (type === "sin") {
            // sin(a + b) = sin(a) * cos(b) + cos(a) * sin(b)
            return expandTrigonometryRules(a, "sin").multiply(expandTrigonometryRules(b, "cos")).add(expandTrigonometryRules(a, "cos").multiply(expandTrigonometryRules(b, "sin")));
        }
        throw new TypeError(type);
    };

    var expandTrigonometryRules = function(A, type) {
        if (A instanceof Addition) {
            return expandTrigonometryRulesInternal(A.a, A.b, type);
        } else if (A instanceof Multiplication) {
            var i = Expression.ONE;
            for (var iteratory = A.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
                if (y instanceof Expression.Integer) {
                    i = i.multiply(y);
                }
            }
            var a = i;
            var b = A.divide(i);
            //var a = A.a;
            //var b = A.b;
            if (!(a instanceof Integer)) {
                throw new TypeError();
            }
            if (a.equals(Expression.ONE)) {
                if (type === "cos") {
                    return A.cos();
                }
                if (type === "sin") {
                    return A.sin();
                }
            }
            if (a.compareTo(Expression.ONE.negate()) === 0) {
                if (type === "cos") {
                    return expandTrigonometryRules(b, type);
                }
                if (type === "sin") {
                    return expandTrigonometryRules(b, type).negate();
                }
            }
            var c = a.compareTo(Expression.ZERO) > 0 ? Expression.ONE : Expression.ONE.negate();
            return expandTrigonometryRulesInternal(c.multiply(b), a.subtract(c).multiply(b), type);
        } else if (A instanceof Division) {
            var t = simplifyConstantValue(A, type);
            if (t != null) {
                return t;
            }
            var a = A.a;
            var b = A.b;
            if (a instanceof Addition) {
                return expandTrigonometryRulesInternal(a.a.divide(b), a.b.divide(b), type);
            }
        }
        if (A instanceof Expression.Symbol ||
            A instanceof Expression.Exponentiation && A.a instanceof Expression.Symbol && Expression.isScalar(A.a) && A.b instanceof Expression.Integer && A.b.compareTo(Expression.ONE) > 0 || // TODO: ?
            A instanceof Expression.Degrees ||
            A instanceof Expression.Radians ||
            A instanceof Expression.Complex ||
            A instanceof Expression.Arctan) {
            if (type === "cos") {
                return A.cos();
            }
            if (type === "sin") {
                return A.sin();
            }
        }
        throw new TypeError();
    };

    // CA and SC, EA, p. 303

    var expandTrigonometry = function(u) {
        return map(function(v) {
            if (v instanceof Sin) {
                return expandTrigonometryRules(v.a, "sin");
            }
            if (v instanceof Cos) {
                return expandTrigonometryRules(v.a, "cos");
            }
            return v;
        }, u);
    };

    Expression._expandTrigonometry = expandTrigonometry; //!

    var contractTrigonometry = function(u) {
        return map(function(v) {
            if (v instanceof Multiplication || v instanceof Exponentiation || v instanceof Addition) { //! Addition - ?
                return contractTrigonometryRules(v);
            }
            if (v instanceof Division) {
                return contractTrigonometryRules(v.getNumerator()).divide(v.getDenominator());
            }
            return v;
        }, u);
    };

    // page 323

    var hasTrigonometry = function(e) { //TODO: remove
        if (e instanceof BinaryOperation) {
            return hasTrigonometry(e.a) || hasTrigonometry(e.b);
        }
        return e instanceof Cos || e instanceof Sin;
    };

    var simplifyTrigonometry = function(u) {
        if (!hasTrigonometry(u)) {
            return u;
        }
        //!new
        var v = null;
        var r = null;
        Expression._map(function(e) {
            // sin(x/2) -> sin(t), t = 2x
            if (e instanceof Expression.Sin || e instanceof Expression.Cos) {
                var a = e.a;
                if (a instanceof Division) {
                    var n = a.getNumerator();
                    var d = a.getDenominator();
                    if (!d.equals(Expression.ONE)) {
                        for (var iteratorx = n.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
                            var g = x.gcd(d);
                            if (!g.equals(d)) {
                                for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
                                    if (y instanceof Expression.Symbol && y !== Expression.PI) {
                                        r = d.divide(g);
                                        v = y;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return e;
        }, u);
        if (v != null && r != null) {
            // sin(x/2) -> sin(x)
            u = Expression._substitute(u, v, v.multiply(r), v.divide(r));
            u = simplifyTrigonometry(u);
            // sin(x) -> sin(x/2)
            u = Expression._substitute(u, v, v.divide(r), v.multiply(r));
            return u;
        }

        //!
        // TODO: https://en.wikipedia.org/wiki/Euler%27s_formula#Relationship_to_trigonometry - is it possible to do this with anoher method?
        var n = u.getNumerator();
        n = expandTrigonometry(n);
        n = contractTrigonometry(n);
        var d = u.getDenominator();
        d = expandTrigonometry(d);
        d = contractTrigonometry(d);
        return n.divide(d);
    };

    Expression.Division.prototype.compare4Multiplication = function(y) {
        if (y instanceof Division) {
            return this.a.compare4Multiplication(y.a) || this.b.compare4Multiplication(y.b);
        }
        return -1; //TODO:
    };
    Expression.Division.prototype.compare4MultiplicationSymbol = function() {
        return +1; //TODO:
    };
    Expression.Division.prototype.compare4MultiplicationInteger = function() {
        return +1; //TODO:
    };
    Expression.Division.prototype.compare4MultiplicationNthRoot = function() {
        return +1; //TODO:
    };

    Expression.simplifyTrigonometry = simplifyTrigonometry; //?


    function Sin(x) {
        Expression.Function.call(this, "sin", x);
    }
    Sin.prototype = Object.create(Expression.Function.prototype);

    //TODO: new 2017-04-26
    var simplifyConstantValueInternal = function(d, fraction) {
        fraction = fraction || Expression.ZERO;
        if (d >= +360 || d <= -360) {
            throw new RangeError();
        }
        if (d < 0) {
            d = 0 - d;
            fraction = fraction.negate();
        }
        if (d >= 180) {
            d = d - 180;
            var tmp = simplifyConstantValueInternal(d, fraction);
            return tmp == null ? null : tmp.negate();
        }
        if (d > 90) {
            d = 0 - d;
            fraction = fraction.negate();
            d = d + 180;
            var tmp = simplifyConstantValueInternal(d, fraction);
            return tmp == null ? null : tmp.negate();
        }
        console.assert(d >= 0 && d <= 90);
        console.assert(fraction.getNumerator().abs().compareTo(fraction.getDenominator()) < 0);

        function f(x) {
            // https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals#Calculated_trigonometric_values_for_sine_and_cosine
            // cos(x) = sqrt(2+2cos(2x))/2 - sign - ?
            var y = simplifyConstantValueInternal(x * 2);
            return y == null ? null : Expression.TWO.add(Expression.TWO.multiply(y)).squareRoot().divide(Expression.TWO);
        }

        function cosapb(a, b) { // cos(d) = cos(a + b)
            var cosa = simplifyConstantValueInternal(a);
            var cosb = simplifyConstantValueInternal(b);
            var sina = simplifyConstantValueInternal(90 - a);
            var sinb = simplifyConstantValueInternal(90 - b);
            return cosa.multiply(cosb).subtract(sina.multiply(sinb));
        }

        function phi() {
            return Expression.ONE.add(Expression.TWO.add(Expression.TWO).add(Expression.ONE).squareRoot()).divide(Expression.TWO);
        }

        //function cos2x(d) { // cos(d) = cos(a + b)
        // cos(2x) = 2cos^2(x)-1
        //var y = simplifyConstantValueInternal(d / 2);
        //return Expression.TWO.multiply(y.multiply(y)).subtract(Expression.ONE);
        //}


        //if (d === 24) {
        // https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals#24°:_sum_12°_+_12°
        //return ExpressionParser.parse('(sqrt(6*(5-sqrt(5)))+sqrt(5)+1)/8');
        //return cosapb(60, -36);
        //}
        //if (d === 42) {
        // cos(42) = sin(48) = 2*sin(24)*cos(24)
        //return ExpressionParser.parse('2*sin(24)*cos(24)');
        //}

        // 0, 15, 30, 36, 45, 60, 72, 75, 90 - more simple

        if (fraction.equals(Expression.ZERO)) {
            if (d === 0) {
                return Expression.ONE;
            }
            if (d === 30) {
                return Expression.ONE.add(Expression.TWO).squareRoot().divide(Expression.TWO);
            }
            if (d === 45) {
                return Expression.ONE.divide(Expression.TWO.squareRoot());
            }
            if (d === 60) {
                return Expression.ONE.divide(Expression.TWO);
            }
            if (d === 90) {
                return Expression.ZERO;
            }

            if (d === 15) {
                return f(d);
            }
            if (d === 75) {
                return f(d);
            }

            if (d === 36) {
                return phi().divide(Expression.TWO);
            }
            if (d === 72) {
                return phi().subtract(Expression.ONE).divide(Expression.TWO);
            }

            if (d === 18) {
                return Expression.TWO.add(phi()).squareRoot().divide(Expression.TWO);
            }
            // http://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Fibonacci/simpleTrig.html#section4.2
            if (d === 54) {
                //return Expression.TWO.subtract(Expression.TWO.subtract(phi()).squareRoot()).squareRoot().divide(Expression.TWO);
                // https://www.cut-the-knot.org/pythagoras/cos36.shtml
                return Expression.TWO.add(Expression.ONE).subtract(phi()).squareRoot().divide(Expression.TWO);
            }

            // https://en.wikipedia.org/wiki/Sine


            //for (var d = 3; d <= 90; d += 3) {
            //  if (d % 15 !== 0 && d % 18 !== 0) {
            //    for (var a = 75; a > 0; a -= 15) {
            //      var b = -(a - d);
            //      if (b % 18 === 0) {
            //        console.log(`cos(${d})=cos(${a}+${b})`);
            //      }
            //    }
            //  }
            //}


            //if (d === 3) {
            // https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals#3°:_regular_hexacontagon_(60-sided_polygon)
            //return cosapb(18, -15);
            //}

            if (d % 3 === 0) {
                var a = 90 - (Math.floor(d / 3) % 6) * 15;
                var b = -(a - d);
                return cosapb(a, b);
            }
        }

        if (fraction.multiply(Expression.TWO).getDenominator().equals(Expression.ONE)) {
            var dd = d + fraction.multiply(Expression.TWO).toNumber() / 2;
            if (dd === 7.5) {
                return cosapb(30, -22.5);
            }
            if (dd === 22.5) {
                return f(dd);
            }
            if (dd === 37.5) {
                return cosapb(60, -22.5);
            }
            if (dd === 52.5) {
                return cosapb(30, +22.5);
            }
            if (dd === 67.5) {
                return f(dd);
            }
            if (dd === 82.5) {
                return cosapb(60, +22.5);
            }
        }

        //TODO: sin(1.5)

        // https://math.stackexchange.com/questions/125774/how-to-expand-cos-nx-with-cos-x#answer-125826
        if (d % 1 === 0) { //TODO: !!!
            var rational = Integer.fromNumber(d).add(fraction).divide(Integer.fromNumber(60));
            //var n = 360 / Math.gcd(360, d);
            var n = rational.getDenominator().toNumber();
            var a = rational.getNumerator().toNumber();
            if (n > Number.MAX_SAFE_INTEGER || a > Number.MAX_SAFE_INTEGER) {
                return undefined;
            }
            var T = function(n) {
                // https://en.wikipedia.org/wiki/Chebyshev_polynomials#Definition
                var x = Polynomial.of(Expression.ZERO, Expression.ONE);
                var Tprevious = Polynomial.of(Expression.ONE);
                var Tcurrent = x;
                var i = 1;
                while (i < n) {
                    var Tnext = Polynomial.of(Expression.TWO).multiply(x).multiply(Tcurrent).subtract(Tprevious);
                    Tprevious = Tcurrent;
                    Tcurrent = Tnext;
                    i += 1;
                }
                return Tcurrent;
            };
            var polynomial = T(n).subtract(Polynomial.of(simplifyConstantValueInternal(60 * (a % 6), Expression.ZERO)));
            polynomial = polynomial.scale(polynomial.getContent().inverse());
            //TODO: ?
            var approximate = Math.cos((d + fraction.getNumerator().toNumber() / fraction.getDenominator().toNumber()) / 180 * Math.PI);
            var tmp = Math.floor(approximate * Math.pow(2, 24) + 0.5);
            var scale = Expression.Integer.fromNumber(Math.pow(2, 24));
            var interval = {
                a: Expression.Integer.fromNumber(tmp - 1).divide(scale),
                b: Expression.Integer.fromNumber(tmp + 1).divide(scale)
            };
            return Expression.ExpressionPolynomialRoot.create(polynomial, interval);
        }

        return undefined;
    };

    var simplifyConstantValue = function(x, type) {
        var a = undefined;
        var b = undefined;
        if (x instanceof Integer && x.compareTo(Expression.ZERO) === 0) {
            a = Expression.ZERO;
            b = Expression.ONE;
        } else if (x === Expression.PI) {
            a = Expression.ONE;
            b = Expression.ONE;
        } else if (x instanceof Multiplication && x.a instanceof Integer && x.b === Expression.PI) {
            a = x.a;
            b = Expression.ONE;
        } else if (x instanceof Division && x.b instanceof Integer && x.a === Expression.PI) {
            a = Expression.ONE;
            b = x.b;
        } else if (x instanceof Division && x.b instanceof Integer && x.a instanceof Multiplication && x.a.a instanceof Integer && x.a.b === Expression.PI) {
            a = x.a.a;
            b = x.b;
        } else if (x instanceof Expression.Degrees) {
            var t = x.value.simplify();
            t = t.multiply(Expression.PI).divide(Integer.fromNumber(180));
            if (type === 'sin') {
                return t.sin();
            }
            if (type === 'cos') {
                return t.cos();
            }
        }
        if (a != undefined && b != undefined) {
            //b = b.toNumber();
            //var k = Math.pow(2, 44);
            //if (b >= 1 && b <= 180 && (180 * k) % b === 0) {
            //var d = a.multiply(Integer.fromNumber(Math.floor((180 * k) / b))).remainder(Integer.fromNumber(360 * k)).toNumber();
            //d /= k;
            var integer = a.multiply(Integer.fromNumber(180)).truncatingDivide(b);
            var fraction = a.multiply(Integer.fromNumber(180)).subtract(integer.multiply(b)).divide(b);
            //var degrees = integer.remainder(Integer.fromNumber(360)).add(fraction);
            var d = integer.remainder(Integer.fromNumber(360)).toNumber();
            if (type === "sin") {
                d = 90 - d;
                fraction = fraction.negate();
                if (d >= 360 - 90) {
                    d -= 360;
                }
            } else if (type !== "cos") {
                throw new TypeError();
            }
            return simplifyConstantValueInternal(d, fraction);
            //}
        }
        if (x instanceof Expression.Radians && x.value.equals(Expression.ZERO)) {
            return simplifyConstantValue(x.value, type);
        }
        if (Expression.has(x, Expression.Complex)) {
            if (type === "sin") {
                return Expression.I.multiply(x.divide(Expression.I).sinh());
            }
            if (type === "cos") {
                return x.divide(Expression.I).cosh();
            }
        }
        if (x instanceof Expression.Arctan) {
            if (Expression.callback != undefined) {
                Expression.callback(new Expression.Event("trigonometric-function-of-inverse-trigonometric-function-arg", new Expression.Matrix(Matrix.I(1))));
            }
            // https://www.rapidtables.com/math/trigonometry/arctan.html#rules
            // https://en.wikipedia.org/wiki/Inverse_trigonometric_functions#Relationships_between_trigonometric_functions_and_inverse_trigonometric_functions
            //TODO: lin in details
            //TODO: test
            var a = x.a;
            if (type === "sin") {
                //TODO: fix (sign - ?), fix complex numbers - ?
                return a.getNumerator().divide(a.getDenominator()._pow(2).add(a.getNumerator()._pow(2)).squareRoot());
            }
            if (type === "cos") {
                //TODO: fix (sign - ?), fix complex numbers - ?
                return a.getDenominator().divide(a.getDenominator()._pow(2).add(a.getNumerator()._pow(2)).squareRoot());
            }
            //TODO:
        }
        if (x instanceof Expression.ExpressionWithPolynomialRoot) {
            return simplifyConstantValue(x.upgrade(), type);
        }
        return undefined;
    };

    Expression.prototype.cosh = function() {
        var a = this;
        return a.exp().add(a.negate().exp()).divide(Expression.TWO);
    };

    Expression.prototype.sinh = function() {
        var a = this;
        return a.exp().subtract(a.negate().exp()).divide(Expression.TWO);
    };

    Expression.prototype.tanh = function() {
        var a = this;
        return a.exp().subtract(a.negate().exp()).divide(a.exp().add(a.negate().exp()));
    };

    Expression.prototype.coth = function() {
        var a = this;
        return a.exp().add(a.negate().exp()).divide(a.exp().subtract(a.negate().exp()));
    };

    Expression.prototype.arccos = function() {
        var a = this;
        //return a.pow(Expression.TWO).subtract(Expression.ONE).negate().squareRoot().divide(a).arctan();
        return a.arcsin().subtract(Expression.PI.divide(Expression.TWO)).negate();
    };

    Expression.prototype.arcsin = function() {
        var a = this;
        // see https://en.wikipedia.org/wiki/Inverse_trigonometric_functions#:~:text=Useful%20identities%20if%20one%20only%20has%20a%20fragment%20of%20a%20sine%20table:
        return a.divide(a.pow(Expression.TWO).subtract(Expression.ONE).negate().squareRoot()).arctan();
    };

    Expression.prototype.arccot = function() {
        var a = this;
        //TODO: details ?
        // see https://en.wikipedia.org/wiki/Inverse_trigonometric_functions#:~:text=Useful%20identities%20if%20one%20only%20has%20a%20fragment%20of%20a%20sine%20table:
        return a.arctan().subtract(Expression.PI.divide(Expression.TWO)).negate();
    };

    Expression.prototype.arcosh = function() {
        var x = this;
        // https://en.wikipedia.org/wiki/Inverse_hyperbolic_functions#Inverse_hyperbolic_cosine
        return x.add(x.multiply(x).subtract(Expression.ONE).squareRoot()).logarithm();
    };
    Expression.prototype.arsinh = function() {
        var x = this;
        // https://en.wikipedia.org/wiki/Inverse_hyperbolic_functions#Inverse_hyperbolic_cosine
        return x.add(x.multiply(x).add(Expression.ONE).squareRoot()).logarithm();
    };
    Expression.prototype.artanh = function() {
        var x = this;
        // https://en.wikipedia.org/wiki/Inverse_hyperbolic_functions#Inverse_hyperbolic_tangent
        return x.add(Expression.ONE).divide(x.subtract(Expression.ONE).negate()).logarithm().divide(Expression.TWO);
    };
    Expression.prototype.arcoth = function() {
        var x = this;
        // https://en.wikipedia.org/wiki/Inverse_hyperbolic_functions#Inverse_hyperbolic_tangent
        return x.add(Expression.ONE).divide(x.subtract(Expression.ONE)).logarithm().divide(Expression.TWO);
    };

    Expression.isRealAlgebraicNumber = function isRealAlgebraicNumber(x) {
        return x instanceof Expression.Integer ||
            x instanceof Expression.NthRoot && typeof x.n === "number" && x.n % 1 === 0 && isRealAlgebraicNumber(x.a) && (x.n % 2 !== 0 || Expression._isPositive(x.a)) ||
            x instanceof Expression.Division && isRealAlgebraicNumber(x.getNumerator()) && isRealAlgebraicNumber(x.getDenominator()) ||
            x instanceof Expression.Addition && isRealAlgebraicNumber(x.a) && isRealAlgebraicNumber(x.b) ||
            x instanceof Expression.Multiplication && isRealAlgebraicNumber(x.a) && isRealAlgebraicNumber(x.b);
    };

    var isArgumentValid = function(x, type) {
        if (x instanceof Expression.Radians) {
            // https://ru.wikipedia.org/wiki/Трансцендентное_число#Примеры_трансцендентных_чисел
            return Expression.isRealAlgebraicNumber(x.value);
        }
        if (x instanceof Expression.Degrees) {
            return simplifyConstantValue(x, type) != undefined;
        }
        if (x instanceof Expression.Symbol) {
            return Expression.isScalar(x);
        }
        if (x instanceof Expression.Exponentiation) {
            //TODO: ?
            return x.a instanceof Expression.Symbol && Expression.isScalar(x.a) && x.b instanceof Expression.Integer && x.b.compareTo(Expression.ONE) > 0;
        }
        if (x instanceof Addition) {
            return isArgumentValid(x.a, type) && isArgumentValid(x.b, type);
        }
        if (x instanceof Expression.Arctan) {
            return true; //?
        }
        if (x instanceof Multiplication) {
            if (x.a instanceof Integer && Expression.isScalar(x.b) && x.b instanceof Expression.Symbol) {
                return true;
            }
            if (x.a instanceof Integer && Expression.isScalar(x.b) && x.b instanceof Expression.Arctan) {
                return true;
            }
            if (Expression.isScalar(x.b) && x.b instanceof Expression.Symbol) {
                if (x.a instanceof Expression.NthRoot && x.a.a instanceof Integer) {
                    return true;
                }
                if (x.a instanceof Multiplication && x.a.a instanceof Integer && x.a.b instanceof Expression.NthRoot && x.a.b.a instanceof Integer) {
                    return true;
                }
            }
            var c = Expression.getConstant(x);
            var t = x.divide(c);
            if (Expression.isScalar(x) &&
                (c instanceof Integer || c instanceof Expression.Complex) &&
                (t instanceof Multiplication || t instanceof Expression.Symbol || t instanceof Expression.Exponentiation)) {
                for (var iteratory = t.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
                    if (!(y instanceof Expression.NthRoot) &&
                        !(y instanceof Expression.Symbol) &&
                        !(y instanceof Expression.Exponentiation && y.a instanceof Expression.Symbol && Expression.isScalar(y.a) && y.b instanceof Expression.Integer && y.b.compareTo(Expression.ONE) > 0)) {
                        return false;
                    }
                }
                //TODO: is it correct ?
                return true; //!?
            }
        }
        if (x instanceof Division) {
            if (x.b instanceof Integer) {
                return isArgumentValid(x.a);
            }
        }
        if (x instanceof Expression.Complex) {
            return true; //?
        }
        return false;
    };

    Expression.prototype.sin = function() {
        var x = this;
        var t = simplifyConstantValue(x, "sin");
        if (t != undefined) {
            return t;
        }
        if (x.isNegative()) {
            return x.negate().sin().negate();
        }
        if (!isArgumentValid(x, "sin")) {
            throw new RangeError("NotSupportedError");
        }
        return new Sin(x);
    };

    function Cos(x) {
        Expression.Function.call(this, "cos", x);
    }
    Cos.prototype = Object.create(Expression.Function.prototype);

    Expression.prototype.cos = function() {
        var x = this;
        var t = simplifyConstantValue(x, "cos");
        if (t != undefined) {
            return t;
        }
        if (x.isNegative()) {
            return x.negate().cos();
        }
        if (!isArgumentValid(x, "cos")) {
            throw new RangeError("NotSupportedError");
        }
        return new Cos(x);
    };

    Expression.simplifications.push(Expression.simplifyTrigonometry);

    Expression.Sin = Sin;
    Expression.Cos = Cos;

    //Expression.Negation.prototype.compare4Multiplication = function (y) {
    //TODO: fix, more tests
    //  return new Expression.Multiplication(Expression.ONE.negate(), this.a).compare4Multiplication(y);
    //};

    Expression.Addition.prototype.compare4Addition = function(y) {
        // cos(a + b) + cos(a + b)
        var x = this;
        return Expression.Addition.compare4Addition(x, y);
    };

    Expression.Multiplication.prototype.compare4MultiplicationInteger = function(x) {
        return -1;
    };

    /*
    Expression.MatrixSymbol.prototype.compare4MultiplicationExponentiation = function (x) {
      return -1;//?
    };
    */

    //!!!
    Expression.Addition.prototype.compare4Multiplication = function(y) {
        if (y instanceof Integer) {
            return -1;
        }
        if (y instanceof Expression.MatrixSymbol) {
            return +1;
        }
        //TODO: fix

        var x = this;
        var i = x.summands();
        var j = y.summands();
        var a = i.next().value;
        var b = j.next().value;
        while (a != null && b != null) {
            var c = a.compare4Multiplication(b);
            if (c !== 0) {
                return c;
            }
            a = i.next().value;
            b = j.next().value;
        }
        return a != null ? +1 : (b != null ? -1 : 0);
    };

    Expression.Addition.prototype.compare4MultiplicationSymbol = function(x) {
        return 0 - this.compare4Multiplication(x);
    };

    Expression.Addition.prototype.compare4MultiplicationInteger = function(x) {
        return +1;
    };

    Expression.Addition.compare4Addition = function(x, y) {
        var i = x.summands();
        var j = y.summands();
        var a = i.next().value;
        var b = j.next().value;
        while (a != null && b != null) {
            var c = a.compare4Addition(b);
            if (c !== 0) {
                return c;
            }
            a = i.next().value;
            b = j.next().value;
        }
        return a != null ? +1 : (b != null ? -1 : 0);
    };

    //!!!


    // unit of measurement
    Expression.Unit = function(value) {
        this.value = value;
    };
    Expression.Unit.prototype = Object.create(Expression.prototype);
    Expression.Unit.prototype.toString = function(options) {
        var b = this.value;
        var fb = b instanceof Expression.Integer ? false : true;
        return (fb ? "(" : "") + b.toString(options) + (fb ? ")" : "") + this.unitSymbol();
    };
    Expression.Unit.prototype.equals = function(y) {
        return y instanceof Expression.Unit && this.unitSymbol() === y.unitSymbol() && this.value.equals(y.value);
    };
    Expression.Unit.prototype.compare4AdditionSymbol = function(x) {
        //return -1;
        return x.compare4Addition(this.value);
    };
    Expression.Unit.prototype.compare4Addition = function(y) {
        return this.value.compare4Addition(y instanceof Expression.Unit && this.unitSymbol() === y.unitSymbol() ? y.value : y);
    };
    Expression.Unit.prototype.compare4Multiplication = function(y) {
        return this.value.compare4Multiplication(y instanceof Expression.Unit && this.unitSymbol() === y.unitSymbol() ? y.value : y);
    };
    Expression.Unit.prototype.compare4MultiplicationSymbol = function(x) {
        return x.compare4Multiplication(this.value);
    };
    Expression.Unit.prototype.compare4MultiplicationInteger = function(x) {
        return +1;
    };
    Expression.Unit.prototype.negate = function() {
        return this.create(this.value.negate());
    };
    Expression.Unit.prototype.multiply = function(y) {
        return this.create(this.value.multiply(y));
    };
    Expression.Unit.prototype.multiplyInteger = function(x) {
        return this.create(x.multiply(this.value));
    };

    Expression.Unit.prototype.add = function(y) {
        if (y instanceof Expression.Unit && this.unitSymbol() === y.unitSymbol()) {
            var x = this.value.add(y.value);
            if (x.equals(Expression.ZERO)) {
                return x; //!?
            }
            return this.create(x); //!?
        }
        return Expression.prototype.add.call(this, y);
    };


    //!new 2017-04-26
    Expression.Degrees = function(value) {
        Expression.Unit.call(this, value);
    };
    Expression.Degrees.prototype = Object.create(Expression.Unit.prototype);
    Expression.Degrees.prototype.unitSymbol = function() {
        return "\u00B0";
    };
    Expression.Degrees.prototype.create = function(value) {
        return new Expression.Degrees(value);
    };

    //!new 2019-12-27
    Expression.Radians = function(value) {
        this.value = value;
    };
    Expression.Radians.prototype = Object.create(Expression.Unit.prototype);
    Expression.Radians.prototype.unitSymbol = function() {
        return " rad";
    };
    Expression.Radians.prototype.create = function(value) {
        return new Expression.Radians(value);
    };


    //!new 2019-11-23
    // https://en.wikipedia.org/wiki/Trigonometric_functions_of_matrices#cite_note-3
    Expression.Matrix.prototype.sin = function() {
        var X = this;
        var i = Expression.I;
        var TWO = Expression.TWO;
        return i.multiply(X).exp().subtract(i.negate().multiply(X).exp()).divide(TWO.multiply(i));
    };
    Expression.Matrix.prototype.cos = function() {
        var X = this;
        var i = Expression.I;
        var TWO = Expression.TWO;
        return i.multiply(X).exp().add(i.negate().multiply(X).exp()).divide(TWO);
    };



    //!
    (function() {
        var i = new Expression.Symbol('_i');

        function replaceSinCos(e) {
            return Expression._map(function(x) {
                if (x instanceof Expression.Sin) {
                    var a = x.a;
                    // Euler's formula
                    return i.multiply(a).exp().subtract(i.multiply(a).negate().exp()).divide(Expression.TWO.multiply(Expression.I));
                }
                if (x instanceof Expression.Cos) {
                    var a = x.a;
                    // Euler's formula
                    return i.multiply(a).exp().add(i.multiply(a).negate().exp()).divide(Expression.TWO);
                }
                return x;
            }, e);
        }

        function replaceBySinCos(e) {
            return Expression._map(function(x) {
                if (x instanceof Expression.Exponentiation && x.a === Expression.E) {
                    var b = x.b;
                    //var p = Polynomial.toPolynomial(b, i);
                    var p = Polynomial.toPolynomial(b.getNumerator(), i).scale(b.getDenominator().inverse()); // as denominator may be not equal 1 and Polynomial.toPolynomial throws in that case
                    if (p.getDegree() === 1) {
                        var q = p.getCoefficient(0);
                        var w = p.getCoefficient(1);
                        // Euler's formula
                        return w.cos().add(Expression.I.multiply(w.sin())).multiply(q.exp());
                    }
                    if (p.getDegree() > 1) {
                        throw new TypeError("!?");
                    }
                }
                return x;
            }, e);
        }

        Expression._replaceSinCos = replaceSinCos;
        Expression._replaceBySinCos = replaceBySinCos;
    }());

    // Arctangent
    function Arctan(x) {
        Expression.Function.call(this, "arctan", x);
    }
    Arctan.prototype = Object.create(Expression.Function.prototype);
    Expression.Arctan = Arctan;

    // https://en.wikipedia.org/wiki/Continued_fraction#Infinite_continued_fractions_and_convergents
    // https://stackoverflow.com/a/14011299/839199
    function getlowestfraction(x0) {
        var eps = 1.0E-15;
        var h, h1, h2, k, k1, k2, a, x;

        x = x0;
        a = Math.floor(x);
        h1 = 1;
        k1 = 0;
        h = a;
        k = 1;

        while (x - a > eps * k * k) {
            x = 1 / (x - a);
            a = Math.floor(x);
            h2 = h1;
            h1 = h;
            k2 = k1;
            k1 = k;
            h = h2 + a * h1;
            k = k2 + a * k1;
        }

        return h + "/" + k;
    }

    Expression.prototype.arctan = function() {
        var x = this;
        if (x.isNegative()) {
            return x.negate().arctan().negate();
        }
        if (Expression.isConstant(x) && !(x instanceof Expression.Logarithm)) {
            var value = Number(toDecimalStringInternal(x, {
                fractionDigits: 15
            }));
            console.assert(!Number.isNaN(value));
            var tmp = getlowestfraction(Math.atan(value) / Math.PI).split("/");
            var guess = Expression.Integer.fromNumber(Number(tmp[0])).divide(Expression.Integer.fromNumber(tmp[1])).multiply(Expression.PI);
            if (guess.getDenominator().toNumber() < 10000 && guess.tan().subtract(x).equals(Expression.ZERO)) {
                return guess;
            }
            throw new RangeError("NotSupportedError");
        }
        if (x instanceof Division) {
            var n = x.getNumerator();
            var d = x.getDenominator();
            if (d.subtract(Expression.ONE).subtract(n).multiply(d.subtract(Expression.ONE).add(n)).subtract(Expression.ONE).equals(Expression.ZERO)) {
                var y = Expression.TWO.multiply(x).divide(Expression.ONE.subtract(x._pow(2)));
                return (new Arctan(y)).divide(Expression.TWO);
            }
        }
        if (x instanceof Expression.Matrix) {
            if (x.matrix.isDiagonal()) {
                return new Expression.Matrix(x.matrix.map(function(e, i, j) {
                    return i === j ? e.arctan() : Expression.ZERO;
                }));
            }
            // https://math.stackexchange.com/questions/2077674/what-is-the-alternate-form-of-arcsin-x
            // y = arctan(x)
            // tan(y) = x
            // -i*(e**(iy)-e**(-iy))/(e**(iy)+e**(-iy)) = x
            // y = ln((i-x)/(i+x))/(2i)
            // y = (ln((i-x)/(i+x)/i)+ln(i))/(2i)
            //TODO: details (a link or a formula - ?)
            var b = Expression.I.subtract(x).divide(Expression.I.add(x)).matrix;
            //var tmp = Expression.getFormaDeJordan(b, Expression.getEigenvalues(b));
            //var J = tmp.J;
            var c = b.map(function(e, i, j) {
                return i === j ? e : Expression.ZERO;
            });
            //c = tmp.P.multiply(c).multiply(tmp.P_INVERSED);
            var complexLogarithm = function(e) {
                if (e instanceof Division) {
                    return complexLogarithm(e.a).subtract(e.b.logarithm());
                }
                var c = Expression.getComplexNumberParts(e);
                if (c != undefined && !c.imaginary.equals(Expression.ZERO)) {
                    var real = c.real;
                    var imaginary = c.imaginary;
                    var phi = real.equals(Expression.ZERO) ? Expression.PI.divide(Expression.TWO) : imaginary.divide(real).arctan();
                    if (real.isNegative()) { //?
                        phi = phi.add(Expression.PI);
                    }
                    // https://www.varsitytutors.com/hotmath/hotmath_help/topics/polar-form-of-a-complex-number
                    return e.divide(Expression.I.multiply(phi).exp()).logarithm().add(Expression.I.multiply(phi));
                }
                return e.logarithm();
            };
            var lnC = new Expression.Matrix(c.map(function(e, i, j) {
                return i === j ? complexLogarithm(e) : Expression.ZERO;
            }));
            //Expression.I.multiply(Expression.PI).divide(Expression.TWO);
            return new Expression.Matrix(b.multiply(c.inverse())).logarithm().add(lnC).divide(Expression.TWO.multiply(Expression.I));
        }
        /*
        var t = simplifyConstantValue(x, "sin");
        if (t != undefined) {
          return t;
        }
        if (!isArgumentValid(x, "sin")) {
          throw new RangeError("NotSupportedError");
        }
        */
        return new Arctan(x);
    };

    Expression.prototype.tan = function() {
        var a = this;
        //return a.sin().divide(a.cos());
        var a2 = a.multiply(Expression.TWO);
        return a2.sin().divide(a2.cos().add(Expression.ONE));
    };
    Expression.prototype.cot = function() {
        var a = this;
        if (a instanceof Expression.Matrix) {
            return a.cos().divide(a.sin());
        }
        //return a.cos().divide(a.sin());
        var a2 = a.multiply(Expression.TWO);
        return a2.cos().add(Expression.ONE).divide(a2.sin());
    };

    Expression.Radians.prototype.complexConjugate = function() {
        return new Expression.Radians(this.value.complexConjugate());
    };
    Expression.Sin.prototype.complexConjugate = function() {
        return this.a.complexConjugate().sin();
    };
    Expression.Cos.prototype.complexConjugate = function() {
        return this.a.complexConjugate().cos();
    };


    Expression.Sin.prototype.compare4MultiplicationExponentiation = function() {
        return -1;
    };

})();
(function() {
    "use strict";



    var Integer = Expression.Integer;

    function Complex(real, imaginary) {
        //Expression.call(this);
        if (!(real instanceof Integer) || !(imaginary instanceof Integer) || imaginary.compareTo(Expression.ZERO) === 0) {
            throw new RangeError();
        }
        this.real = real;
        this.imaginary = imaginary;
    }

    Complex.prototype = Object.create(Expression.prototype);

    Expression.I = new Complex(Expression.ZERO, Expression.ONE);
    Expression.Complex = Complex;

    Complex.prototype.add = function(y) {
        return y.addComplex(this);
    };
    Expression.prototype.addComplex = function(x) {
        return this.addExpression(x);
    };
    Integer.prototype.addComplex = function(x) {
        return new Complex(x.real.add(this), x.imaginary);
    };
    Complex.prototype.addComplex = function(x) {
        var real = x.real.add(this.real);
        var imaginary = x.imaginary.add(this.imaginary);
        return imaginary.compareTo(Expression.ZERO) === 0 ? real : new Complex(real, imaginary);
    };
    Complex.prototype.addInteger = function(x) {
        return new Complex(x.add(this.real), this.imaginary);
    };

    Complex.prototype.equals = function(y) {
        return y instanceof Complex && this.real.equals(y.real) && this.imaginary.equals(y.imaginary) ? true : false;
    };

    Complex.prototype.compare4AdditionSymbol = function(x) {
        return +1;
    };
    Complex.prototype.compare4MultiplicationNthRoot = function(x) {
        return +1;
    };
    Complex.prototype.compare4Addition = function(y) {
        if (y instanceof Complex) {
            if (this.equals(y)) {
                return 0;
            }
            return this.real.compareTo(y.real) || this.imaginary.compareTo(y.imaginary);
        }
        if (y instanceof Integer) {
            return +1;
        }
        if (y instanceof Expression.Division) {
            return Expression.prototype.compare4Addition.call(this, y);
        }
        if (y instanceof Expression.Exponentiation) {
            return Expression.prototype.compare4Addition.call(this, y);
        }
        if (y instanceof Expression.Matrix) {
            return Expression.prototype.compare4Addition.call(this, y);
        }
        return -1;
    };
    // ? zero in case of same "base"
    Complex.prototype.compare4Multiplication = function(y) {
        if (y instanceof Complex) {
            if (y.equals(this)) {
                return 0;
            }
            return this.real.abs().compareTo(y.real.abs()) || this.imaginary.abs().compareTo(y.imaginary.abs());
            //return 0;
            //TODO: fix
            //throw new RangeError("NotSupportedError");//TODO:
        }
        return y.compare4MultiplicationComplex(this);
    };
    Expression.prototype.compare4MultiplicationComplex = function(x) {
        return -1; //?
    };
    Complex.prototype.compare4MultiplicationSymbol = function(x) {
        return +1;
    };
    Complex.prototype.multiply = function(y) {
        return y.multiplyComplex(this);
    };
    Complex.prototype.multiplyComplex = function(x) {
        var real = x.real.multiply(this.real).subtract(x.imaginary.multiply(this.imaginary));
        var imaginary = x.real.multiply(this.imaginary).add(x.imaginary.multiply(this.real));
        return imaginary.compareTo(Expression.ZERO) === 0 ? real : new Complex(real, imaginary);
    };
    Expression.prototype.multiplyComplex = function(x) {
        return this.multiplyExpression(x);
    };
    Integer.prototype.multiplyComplex = function(x) {
        if (this.compareTo(Expression.ZERO) === 0) {
            return this;
        }
        return new Complex(x.real.multiply(this), x.imaginary.multiply(this));
    };
    Complex.prototype.multiplyInteger = function(x) {
        if (x.compareTo(Expression.ZERO) === 0) {
            return x;
        }
        return new Complex(x.multiply(this.real), x.multiply(this.imaginary));
    };

    Complex.prototype.conjugate = function() {
        return new Complex(this.real, this.imaginary.negate());
    };
    //Complex.prototype.divideExpression = function (x) {
    //  var y = this;
    //  return x.multiply(y.conjugate()).divide(y.multiply(y.conjugate()));
    //};
    Complex.prototype.getPrecedence = function() {
        return this.real.equals(Expression.ZERO) ? (this.imaginary.equals(Expression.ONE) ? 1000 : 3) : 2; // precedence.binary['+']
    };

    Complex.prototype.truncatingDivide = function(f) {
        if (f instanceof Integer) {
            return new Complex(this.real.truncatingDivide(f), this.imaginary.truncatingDivide(f));
        }
        return this.multiply(f.conjugate()).truncatingDivide(f.multiply(f.conjugate()));
    };

    Complex.prototype.toStringInternal = function(options, times, i, minus, plus, start, end, toString) {
        if (this.real.equals(Expression.ZERO)) {
            if (this.imaginary.equals(Expression.ONE)) {
                return i;
            }
            if (this.imaginary.equals(Expression.ONE.negate())) {
                return start + minus + i + end;
            }
            return start + toString(this.imaginary, options) + times + i + end;
        }
        var isNegative = this.imaginary.isNegative();
        var imaginary = (isNegative ? this.imaginary.negateCarefully() : this.imaginary);
        var si = (imaginary.equals(Expression.ONE) ? i : start + toString(imaginary, options) + times + i + end);
        var sr = toString(this.real, options);
        return start + sr + (isNegative ? minus : plus) + si + end;
    };

    Complex.prototype.toString = function(options) {
        return this.toStringInternal(options, "", "i", "-", "+", "", "", function(x, options) {
            return x.toString(options);
        });
    };

    Complex.prototype.compare4MultiplicationInteger = function(x) {
        return +1;
    };

    Complex.prototype.remainderInteger = function(x) {
        return Complex.prototype.remainder.call(x, this);
    };

    Complex.prototype.remainder = function(y) {
        function norm(x) {
            return x instanceof Expression.Integer ? x.multiply(x) : x.multiply(x.conjugate());
        }

        function roundDivision(a, b) {
            if (b.compareTo(Expression.ZERO) < 0) {
                b = b.negate();
                a = a.negate();
            }
            var e = b.truncatingDivide(Expression.TWO);
            if (a.compareTo(Expression.ONE) < 0) {
                e = e.negate();
            }
            return a.add(e).truncatingDivide(b);
        }
        var x = this;
        var n = y instanceof Expression.Integer ? x : x.multiply(y.conjugate());
        var d = y instanceof Expression.Integer ? y : y.multiply(y.conjugate());
        //TODO: fix
        var q1 = roundDivision(n instanceof Complex ? n.real : n, d);
        var q2 = roundDivision(n instanceof Complex ? n.imaginary : Expression.ZERO, d);
        var q = q2.compareTo(Expression.ZERO) === 0 ? q1 : new Complex(q1, q2);
        var r = x.subtract(y.multiply(q));
        if (norm(r).compareTo(norm(y)) >= 0) {
            throw new TypeError();
        }
        return r;
    };

    Complex.prototype.primeFactor = function() {
        return QuadraticInteger._complexIntegerPrimeFactor(this.real.toBigInt(), this.imaginary.toBigInt());
    };

    Expression.Complex = Complex;

    Expression.Complex.prototype.complexConjugate = function() {
        return this.conjugate();
    };

    /*
    //!
    Expression.Complex.prototype.isValid = function () {
      return true;
    };
    //!
    Expression.Complex.prototype.isPositive = function () {
      return this.imaginary.compareTo(Expression.ZERO) > 0;// || (this.imaginary.compareTo(Expression.ZERO) === 0 && this.real.compareTo(Expression.ZERO) > 0);
    };
    Expression.Complex.prototype.isUnit = function () {
      return this.multiply(this.conjugate()).equals(Expression.ONE);
    };
    Expression.Complex.prototype.truncatingDivideInteger = function (x) {
      debugger;
      return x.multiply(this.conjugate()).divide(this.multiply(this.conjugate()));
    };

    Expression.Complex.prototype.isDivisibleBy = function (y) {
      return !(this.divide(y) instanceof Expression.Division);
    };
    Expression.Complex.prototype.isDivisibleByInteger = function (x) {
      return !(x.multiply(this.conjugate()).divide(this.multiply(this.conjugate())) instanceof Expression.Division);
    };
    Expression.Complex.prototype.toExpression = function () {
      return this;
    };
    */

    Expression.Complex.prototype.compare4MultiplicationExponentiation = function() {
        return +1;
    };

})();
(function() {
    "use strict";





    var idCounter = 0;

    function NonSimplifiedExpression(e, position, length, input) {
        //Expression.call(this);
        this.e = e;
        this.position = position == undefined ? -1 : position;
        this.length = length == undefined ? -1 : length;
        this.input = input == undefined ? "" : input;
        this.id = (idCounter += 1);
    }

    NonSimplifiedExpression.prototype = Object.create(Expression.prototype);

    // same set of public properties (and same order) as for Expressions ...
    NonSimplifiedExpression.prototype.negate = function() {
        return new NonSimplifiedExpression(new Expression.Negation(this));
    };
    NonSimplifiedExpression.prototype.add = function(y) {
        return new NonSimplifiedExpression(new Expression.Addition(this, y));
    };
    NonSimplifiedExpression.prototype.subtract = function(y) {
        return new NonSimplifiedExpression(new Expression.Subtraction(this, y));
    };
    NonSimplifiedExpression.prototype.divide = function(y) {
        return new NonSimplifiedExpression(new Expression.Division(this, y));
    };
    NonSimplifiedExpression.prototype.multiply = function(y) {
        return new NonSimplifiedExpression(new Expression.Multiplication(this, y));
    };
    NonSimplifiedExpression.prototype.pow = function(y) {
        return new NonSimplifiedExpression(new Expression.Exponentiation(this, y));
    };

    NonSimplifiedExpression.prototype.exp = function() {
        return new NonSimplifiedExpression(Expression.E).pow(this);
    };
    NonSimplifiedExpression.prototype.logarithm = function() {
        return new NonSimplifiedExpression(new Expression.Logarithm(this));
    };
    NonSimplifiedExpression.prototype.inverse = function() {
        return new NonSimplifiedExpression(new Expression.Exponentiation(this, Expression.ONE.negate())); // to support the MathML serialization of the `inverse(B)`
        //return new NonSimplifiedExpression(Expression.ONE).divide(this);
    };

    NonSimplifiedExpression.prototype.factorial = function() {
        return new NonSimplifiedExpression(new Expression.Factorial(this));
    };

    /*
      NonSimplifiedExpression.prototype.powExpression = function (x) {
        return new NonSimplifiedExpression(new Expression.Exponentiation(x, this));
      };
      NonSimplifiedExpression.prototype.multiplyAddition = function (x) {
        return new NonSimplifiedExpression(new Expression.Multiplication(x, this));
      };
      NonSimplifiedExpression.prototype.multiplyDivision = function (x) {
        return new NonSimplifiedExpression(new Expression.Multiplication(x, this));
      };
      NonSimplifiedExpression.prototype.multiplyMatrix = function (x) {
        return new NonSimplifiedExpression(new Expression.Multiplication(x, this));
      };
      NonSimplifiedExpression.prototype.addDivision = function (x) {
        return new NonSimplifiedExpression(new Expression.Addition(x, this));
      };

      //?
      NonSimplifiedExpression.prototype.addMatrix = function (x) {
        return new NonSimplifiedExpression(new Expression.Addition(x, this));
      };

      NonSimplifiedExpression.prototype.addExpression = function (x) {
        return new NonSimplifiedExpression(new Expression.Addition(x, this));
      };
      NonSimplifiedExpression.prototype.multiplyExpression = function (x) {
        return new NonSimplifiedExpression(new Expression.Multiplication(x, this));
      };
      NonSimplifiedExpression.prototype.divideExpression = function (x) {
        return new NonSimplifiedExpression(new Expression.Division(x, this));
      };
    */

    NonSimplifiedExpression.prototype.addExpression = function(x) {
        throw new TypeError();
    };

    NonSimplifiedExpression.prototype.squareRoot = function() {
        return new NonSimplifiedExpression(new Expression.SquareRoot(this));
    };
    NonSimplifiedExpression.prototype._nthRoot = function(n) {
        return new NonSimplifiedExpression(new Expression.NthRoot(n + "-root", this, n));
    };
    NonSimplifiedExpression.prototype.abs = function() {
        return new NonSimplifiedExpression(new Expression.Function("abs", this));
    };
    NonSimplifiedExpression.prototype.cos = function() {
        return new NonSimplifiedExpression(new Expression.Function("cos", this));
    };
    NonSimplifiedExpression.prototype.sin = function() {
        return new NonSimplifiedExpression(new Expression.Function("sin", this));
    };
    NonSimplifiedExpression.prototype.tan = function() {
        return new NonSimplifiedExpression(new Expression.Function("tan", this));
    };
    NonSimplifiedExpression.prototype.cot = function() {
        return new NonSimplifiedExpression(new Expression.Function("cot", this));
    };
    NonSimplifiedExpression.prototype.cosh = function() {
        return new NonSimplifiedExpression(new Expression.Function("cosh", this));
    };
    NonSimplifiedExpression.prototype.sinh = function() {
        return new NonSimplifiedExpression(new Expression.Function("sinh", this));
    };
    NonSimplifiedExpression.prototype.tanh = function() {
        return new NonSimplifiedExpression(new Expression.Function("tanh", this));
    };
    NonSimplifiedExpression.prototype.coth = function() {
        return new NonSimplifiedExpression(new Expression.Function("coth", this));
    };
    NonSimplifiedExpression.prototype.arccos = function() {
        return new NonSimplifiedExpression(new Expression.Function("arccos", this));
    };
    NonSimplifiedExpression.prototype.arcsin = function() {
        return new NonSimplifiedExpression(new Expression.Function("arcsin", this));
    };
    NonSimplifiedExpression.prototype.arctan = function() {
        return new NonSimplifiedExpression(new Expression.Function("arctan", this));
    };
    NonSimplifiedExpression.prototype.arccot = function() {
        return new NonSimplifiedExpression(new Expression.Function("arccot", this));
    };
    NonSimplifiedExpression.prototype.arcosh = function() {
        return new NonSimplifiedExpression(new Expression.Function("arcosh", this));
    };
    NonSimplifiedExpression.prototype.arsinh = function() {
        return new NonSimplifiedExpression(new Expression.Function("arsinh", this));
    };
    NonSimplifiedExpression.prototype.artanh = function() {
        return new NonSimplifiedExpression(new Expression.Function("artanh", this));
    };
    NonSimplifiedExpression.prototype.arcoth = function() {
        return new NonSimplifiedExpression(new Expression.Function("arcoth", this));
    };
    NonSimplifiedExpression.prototype.rank = function() {
        return new NonSimplifiedExpression(new Expression.Rank(this));
    };
    NonSimplifiedExpression.prototype.determinant = function() {
        return new NonSimplifiedExpression(new Expression.Determinant(this));
    };

    Expression.Pseudoinverse.prototype.simplifyInternal = function(holder) {
        return prepare(this.a, holder).pseudoinverse();
    };
    NonSimplifiedExpression.prototype.pseudoinverse = function() {
        return new NonSimplifiedExpression(new Expression.Pseudoinverse(this));
    };

    NonSimplifiedExpression.prototype.rowReduce = function() {
        return new NonSimplifiedExpression(new Expression.RowReduce(this));
    };
    //?
    NonSimplifiedExpression.prototype.GF2 = function() {
        return new NonSimplifiedExpression(new Expression.GF2(this));
    };
    NonSimplifiedExpression.prototype.transpose = function() {
        return new NonSimplifiedExpression(new Expression.Transpose(this));
    };
    NonSimplifiedExpression.prototype.complexConjugate = function() {
        return new NonSimplifiedExpression(new Expression.ComplexConjugate(this));
    };
    NonSimplifiedExpression.prototype.adjugate = function() {
        return new NonSimplifiedExpression(new Expression.Adjugate(this));
    };

    NonSimplifiedExpression.prototype.elementWisePower = function(a) {
        return new NonSimplifiedExpression(new Expression.ElementWisePower(this, a));
    };
    NonSimplifiedExpression.prototype.transformNoAnswerExpression = function(name, second) {
        return new NonSimplifiedExpression(new Expression.NoAnswerExpression(this, name, second));
    };
    NonSimplifiedExpression.prototype.transformEquality = function(b) {
        return new NonSimplifiedExpression(new Expression.Equality(this, b));
    };
    NonSimplifiedExpression.prototype.transformInequality = function(b, sign) {
        return new NonSimplifiedExpression(new Expression.Inequality(this, b, sign));
    };
    NonSimplifiedExpression.prototype.transformComma = function(b) {
        return new NonSimplifiedExpression(new Expression.Comma(this, b));
    };

    NonSimplifiedExpression.prototype.addPosition = function(position, length, input) {
        return new NonSimplifiedExpression(this.e, position, length, input);
    };

    var prepare = function(x, holder) {
        var e = x.simplify();
        ExpressionParser.startPosition = holder.position;
        ExpressionParser.endPosition = holder.position + holder.length;
        ExpressionParser.input = holder.input;
        return e;
    };

    //TODO:
    Expression.prototype.simplifyInternal = function(holder) {
        return this;
    };
    Expression.Exponentiation.prototype.simplifyInternal = function(holder) {
        return prepare(this.a, holder).pow(prepare(this.b, holder));
    };
    Expression.Multiplication.prototype.simplifyInternal = function(holder) {
        return prepare(this.a, holder).multiply(prepare(this.b, holder));
    };
    Expression.Addition.prototype.simplifyInternal = function(holder) {
        return prepare(this.a, holder).add(prepare(this.b, holder));
    };
    Expression.Division.prototype.simplifyInternal = function(holder) {
        return prepare(this.a, holder).divide(prepare(this.b, holder));
    };
    Expression.SquareRoot.prototype.simplifyInternal = function(holder) {
        return prepare(this.a, holder).squareRoot();
    };
    Expression.NthRoot.prototype.simplifyInternal = function(holder) {
        return prepare(this.a, holder)._nthRoot(this.n);
    };
    Expression.Function.prototype.simplifyInternal = function(holder) {
        return prepare(this.a, holder)[this.name]();
    };
    Expression.Logarithm.prototype.simplifyInternal = function(holder) {
        return prepare(this.a, holder).logarithm();
    };
    Expression.Rank.prototype.simplifyInternal = function(holder) {
        return prepare(this.a, holder).rank();
    };
    Expression.Determinant.prototype.simplifyInternal = function(holder) {
        return prepare(this.a, holder).determinant();
    };
    Expression.RowReduce.prototype.simplifyInternal = function(holder) {
        return prepare(this.a, holder).rowReduce();
    };
    Expression.GF2.prototype.simplifyInternal = function(holder) {
        return prepare(this.a, holder).GF2();
    };
    Expression.Transpose.prototype.simplifyInternal = function(holder) {
        return prepare(this.a, holder).transpose();
    };
    Expression.ComplexConjugate.prototype.simplifyInternal = function(holder) {
        return prepare(this.a, holder).complexConjugate();
    };
    Expression.Adjugate.prototype.simplifyInternal = function(holder) {
        return prepare(this.a, holder).adjugate();
    };
    Expression.NoAnswerExpression.prototype.simplifyInternal = function(holder) {
        return prepare(this.a, holder).transformNoAnswerExpression(this.name, this.second == undefined ? undefined : prepare(this.second, holder));
    };
    Expression.Equality.prototype.simplifyInternal = function(holder) {
        return prepare(this.a, holder).transformEquality(prepare(this.b, holder));
    };
    Expression.Inequality.prototype.simplifyInternal = function(holder) {
        return prepare(this.a, holder).transformInequality(prepare(this.b, holder), this.sign);
    };
    Expression.Matrix.prototype.simplifyInternal = function(holder) {
        return new Expression.Matrix(this.matrix.map(function(e, i, j) {
            return prepare(e, holder);
        }));
    };

    Expression.Radians.prototype.simplifyInternal = function(holder) {
        return new Expression.Radians(prepare(this.value, holder));
    };

    Expression.Comma.prototype.simplifyInternal = function(holder) {
        return prepare(this.a, holder).transformComma(prepare(this.b, holder));
    };

    Expression.prototype.simplify = function() {
        return this; //? this.simplifyInternal(undefined);
    };
    NonSimplifiedExpression.prototype.simplify = function() {
        //return this.e.simplifyInternal(this);
        //return this.e.simplifyInternal(this).simplifyExpression();//new

        // to get an expression after a double "wrapping"
        return this.e.simplify().simplifyInternal(this).simplifyExpression(); //new
    };
    NonSimplifiedExpression.prototype.toString = function(options) {
        return this.e.toString(options);
    };
    NonSimplifiedExpression.prototype.equals = function(y) {
        return this.simplify().equals(y.simplify());
    };

    //!
    NonSimplifiedExpression.prototype.unwrap = function() {
        return this.e;
    };
    Expression.Negation.prototype.simplifyInternal = function(holder) {
        return prepare(this.b, holder).negate();
    };
    Expression.Subtraction.prototype.simplifyInternal = function(holder) {
        return prepare(this.a, holder).subtract(prepare(this.b, holder));
    };
    NonSimplifiedExpression.prototype.isUnaryPlusMinus = function() {
        return this.e.isUnaryPlusMinus();
    };
    NonSimplifiedExpression.prototype.getPrecedence = function() {
        return this.e.getPrecedence();
    };

    Expression.ElementWisePower.prototype.simplifyInternal = function(holder) {
        return prepare(this.a, holder).elementWisePower(prepare(this.b, holder));
    };
    Expression.Factorial.prototype.simplifyInternal = function(holder) {
        return prepare(this.n, holder).factorial();
    };

    //?
    NonSimplifiedExpression.prototype.getId = function() {
        return "e" + this.id.toString();
    };
    Expression.prototype.getIds = function() {
        return "";
    };
    Expression.BinaryOperation.prototype.getIds = function() {
        var a = this.a.getIds();
        var b = this.b.getIds();
        return a === "" ? b : (b === "" ? a : a + ", " + b);
    };
    NonSimplifiedExpression.prototype.getIds = function() {
        var a = this.getId();
        var b = this.e.getIds();
        return a === "" ? b : (b === "" ? a : a + ", " + b);
    };

    NonSimplifiedExpression.prototype.isNegative = function() {
        //return this.e.isNegative();
        return false;
    };
    NonSimplifiedExpression.prototype.negateCarefully = function() {
        return new NonSimplifiedExpression(this.e.negateCarefully());
    };
    NonSimplifiedExpression.prototype.isRightToLeftAssociative = function() {
        return this.e.isRightToLeftAssociative();
    };

    NonSimplifiedExpression.prototype.isExact = function() {
        return this.e.isExact();
    };

    Expression.DecimalFraction = function(integer, transient, repetend, exponent) {
        this.integer = integer;
        this.transient = transient;
        this.repetend = repetend;
        this.exponent = exponent;
    };
    Expression.DecimalFraction.prototype = Object.create(Expression.prototype);
    Expression.DecimalFraction.prototype.getPrecedence = function() {
        //TODO: comma may affect precedence - ?
        return 1000; //TODO: ?
    };
    Expression.DecimalFraction.prototype.simplifyInternal = function() {
        return ExpressionParser._getDecimalFraction(this.integer, this.transient, this.repetend, this.exponent);
    };
    Expression.DecimalFraction.prototype.toString = function() {
        return (this.integer || '0') + '.' + (this.transient || '') + (this.repetend != undefined ? '(' + this.repetend + ')' : '') + (this.exponent != undefined ? 'E' + this.exponent : '');
    };

    NonSimplifiedExpression.prototype.augment = function(other) {
        return new NonSimplifiedExpression(new Expression.AugmentedMatrix(this, other));
    };
    Expression.AugmentedMatrix.prototype.simplifyInternal = function(holder) {
        return prepare(this.a, holder).augment(prepare(this.b, holder));
    };

    Expression.NonSimplifiedExpression = NonSimplifiedExpression;

    self.NonSimplifiedExpression = NonSimplifiedExpression;

})();
(function() {
    "use strict";
    /*jslint plusplus: true, vars: true, indent: 2 */




    //var isAlpha = function (code) {
    //  return (code >= "a".charCodeAt(0) && code <= "z".charCodeAt(0)) ||
    //         (code >= "A".charCodeAt(0) && code <= "Z".charCodeAt(0));
    //};

    // http://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B#Operator_precedence

    var LEFT_TO_RIGHT = 0;
    var RIGHT_TO_LEFT = 1;

    var COMMA_PRECEDENCE = 1;
    var EQUALITY_PRECEDENCE = 2;
    var ADDITIVE_PRECEDENCE = 3;
    var MULTIPLICATIVE_PRECEDENCE = 4;
    var UNARY_PRECEDENCE = 6;

    var UNARY_PRECEDENCE_PLUS_ONE = UNARY_PRECEDENCE + 1; // TODO: remove
    var UNARY_PRECEDENCE_PLUS_TWO = UNARY_PRECEDENCE + 2;

    function Operator(name, arity, rightToLeftAssociative, precedence, i) {
        this.name = name;
        this.arity = arity;
        this.rightToLeftAssociative = rightToLeftAssociative;
        this.precedence = precedence;
        this.i = i;
        //this.xyz = isAlpha(name.charCodeAt(0)) && isAlpha(name.charCodeAt(name.length - 1));
    }

    Operator.trigonometry = function(name) {
        return new Operator(name, 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function(a) {
            a = prepareTrigonometricArgument(a);
            return a[name]();
        });
    };
    Operator.simple = function(name) {
        return new Operator(name, 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function(a) {
            return a[name]();
        });
    };



    var UNARY_PLUS = new Operator("+", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function(e) {
        return e;
    });
    var UNARY_MINUS = new Operator("-", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function(e) {
        return e.negate();
    });

    var prepareTrigonometricArgument = function(a) {
        if (a instanceof Expression.Integer) {
            return new Expression.Degrees(a);
        }
        if (a instanceof Expression.NonSimplifiedExpression) {
            var isGood = function(a) {
                if (a instanceof Expression.NonSimplifiedExpression) {
                    return isGood(a.e);
                }
                if (a instanceof Expression.Integer) {
                    return true;
                }
                if (a instanceof Expression.Negation) {
                    return isGood(a.b);
                }
                if (a instanceof Expression.Multiplication || a instanceof Expression.Addition) {
                    return isGood(a.a) && isGood(a.b);
                }
                return false;
            };
            if (isGood(a)) {
                return toDegrees(a);
            }
        }
        return a;
    };

    var toDegrees = function(a) {
        return a instanceof Expression.NonSimplifiedExpression ? new Expression.NonSimplifiedExpression(new Expression.Degrees(a)) : new Expression.Degrees(a);
    };

    var toRadians = function(a) {
        return a instanceof Expression.NonSimplifiedExpression ? new Expression.NonSimplifiedExpression(new Expression.Radians(a)) : new Expression.Radians(a);
    };

    var notSupported = function(a) {
        throw new TypeError();
    };

    var conjugateTranspose = function(a) {
        return a.transpose().complexConjugate();
    };

    var inequalityOperator = function(name, sign) {
        return new Operator(name, 2, LEFT_TO_RIGHT, EQUALITY_PRECEDENCE, function(a, b) {
            return a.transformInequality(b, sign); //TODO:
        });
    };

    var operations = [
        new Operator("=", 2, LEFT_TO_RIGHT, EQUALITY_PRECEDENCE, function(a, b) {
            return a.transformEquality(b);
        }),

        inequalityOperator('≠', '!='),
        inequalityOperator('!=', '!='),
        inequalityOperator('>', '>'),
        inequalityOperator('<', '<'),
        inequalityOperator('⩽', '>='),
        inequalityOperator('⩾', '<='),

        new Operator(";", 2, LEFT_TO_RIGHT, COMMA_PRECEDENCE, function(a, b) {
            return a.transformComma(b);
        }),
        new Operator(",", 2, LEFT_TO_RIGHT, COMMA_PRECEDENCE, function(a, b) {
            return a.transformComma(b);
        }),

        new Operator("+", 2, LEFT_TO_RIGHT, ADDITIVE_PRECEDENCE, function(a, b) {
            return a.add(b);
        }),
        new Operator("-", 2, LEFT_TO_RIGHT, ADDITIVE_PRECEDENCE, function(a, b) {
            return a.subtract(b);
        }),
        new Operator("*", 2, LEFT_TO_RIGHT, MULTIPLICATIVE_PRECEDENCE, function(a, b) {
            return a.multiply(b);
        }),
        new Operator("/", 2, LEFT_TO_RIGHT, MULTIPLICATIVE_PRECEDENCE, function(a, b) {
            return a.divide(b);
        }),
        new Operator("\\", 2, LEFT_TO_RIGHT, MULTIPLICATIVE_PRECEDENCE, function(a, b) {
            return a.inverse().multiply(b);
        }),
        //new Operator("%", 2, LEFT_TO_RIGHT, MULTIPLICATIVE_PRECEDENCE, function (a, b) {
        //  return a.remainder(b);
        //}),
        //UNARY_PLUS,
        //UNARY_MINUS,
        // Exponentiation has precedence as unary operators
        new Operator("^", 2, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function(a, b) {
            return a.pow(b);
        }),
        new Operator("**", 2, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function(a, b) {
            return a.pow(b);
        }),
        new Operator(".^", 2, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function(a, b) {
            return a.elementWisePower(b);
        }), //?
        new Operator("\u221A", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function(a) {
            return a.squareRoot();
        }),
        new Operator("sqrt", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function(a) {
            return a.squareRoot();
        }),
        new Operator("radical", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function(a) {
            return a.squareRoot();
        }),
        new Operator("\u221B", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function(a) {
            return a._nthRoot(3);
        }),
        new Operator("cbrt", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function(a) {
            return a._nthRoot(3);
        }),
        new Operator("\u221C", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function(a) {
            return a._nthRoot(4);
        }),
        new Operator("rank", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function(a) {
            return a.rank();
        }),
        new Operator("adj", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function(a) { //?
            return a.adjugate();
        }),
        new Operator("adjugate", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function(a) {
            return a.adjugate();
        }),
        //new Operator("trace", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
        //  return Expression.transformTrace(a);
        //}),
        new Operator("inverse", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function(a) {
            return a.inverse();
        }),
        new Operator("det", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function(a) { //?
            return a.determinant();
        }),
        new Operator("determinant", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function(a) {
            return a.determinant();
        }),
        new Operator("row-reduce", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function(a) {
            return a.rowReduce();
        }),
        new Operator("transpose", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function(a) {
            return a.transpose();
        }),
        //new Operator("^T", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE, function (a) {
        //  return a.transpose();
        //}),
        //new Operator("^t", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE, function (a) {
        //  return a.transpose();
        //}),
        new Operator("'", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE, function(a) {
            return a.transpose();
        }),
        //TODO: https://en.wikipedia.org/wiki/Conjugate_transpose
        new Operator("^*", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE, conjugateTranspose),
        new Operator("^{*}", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE, conjugateTranspose),
        new Operator("⃰", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE, conjugateTranspose),

        //?
        new Operator("solve", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function(a) {
            return a.transformNoAnswerExpression("solve"); //?
        }),

        new Operator("GF2", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function(a) {
            return a.GF2();
        }),

        new Operator("°", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE_PLUS_TWO, function(a) {
            return toDegrees(a);
        }),
        new Operator("deg", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE_PLUS_TWO, function(a) {
            return toDegrees(a);
        }),
        new Operator("rad", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE_PLUS_TWO, function(a) {
            return toRadians(a);
        }),

        new Operator("exp", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function(a) {
            return a.exp();
        }),
        new Operator("log", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function(a) {
            return a.logarithm();
        }),
        new Operator("lg", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function(a) {
            return a.logarithm().divide(Expression.TEN.logarithm());
        }),
        new Operator("ln", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function(a) {
            return a.logarithm();
        }),

        new Operator("abs", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function(a) {
            return a.abs();
        }),

        new Operator("min", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function(a) {
            return a.min();
        }),
        new Operator("max", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function(a) {
            return a.max();
        }),
        new Operator("gcd", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function(a) {
            return a.gcd();
        }),

        new Operator("conjugate", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function(a) {
            return a.complexConjugate();
        }),
        new Operator("overline", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function(a) {
            return a.complexConjugate();
        }),

        new Operator("\\left", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function(a) {
            return a;
        }),
        new Operator("\\right", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE_PLUS_ONE, function(a) {
            return a;
        }),
        new Operator("├", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function(a) { // like \\left
            return a;
        }),
        new Operator("┤", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE_PLUS_ONE, function(a) { // like \\right
            return a;
        }),

        new Operator("frac", 2, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function(a, b) {
            return a.divide(b);
        }),
        new Operator("\\cdot", 2, LEFT_TO_RIGHT, MULTIPLICATIVE_PRECEDENCE, function(a, b) {
            return a.multiply(b);
        }),
        new Operator("\\times", 2, LEFT_TO_RIGHT, MULTIPLICATIVE_PRECEDENCE, function(a, b) {
            return a.multiply(b);
        }),
        //new Operator("\\:", 0, RIGHT_TO_LEFT, 42, function (a, b) {
        //  return a;
        //}),

        new Operator("!", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE, function(a) {
            return a.factorial();
        }),
        new Operator("!!", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE, notSupported), // to not parse 3!! as (3!)!, see https://en.wikipedia.org/wiki/Double_factorial
        new Operator("!!!", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE, notSupported),


        new Operator("pseudoinverse", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function(a) {
            return a.pseudoinverse();
        }),
        new Operator("root of", 1, RIGHT_TO_LEFT, EQUALITY_PRECEDENCE, function(a) {
            //TODO: !?
            var tmp = Expression.getMultivariatePolynomial(a.simplify());
            return SomePolynomialRoot.create(tmp.p);
        }),
        new Operator("near", 2, RIGHT_TO_LEFT, COMMA_PRECEDENCE, function(a, b) {
            //TODO: !?
            //TODO: optimize, use in tests
            if (a instanceof Expression.Integer) {
                return a;
            }
            if (a instanceof SomePolynomialRoot && a.e.toString() === 'alpha') {
                var point = b.simplify();
                var p = a.polynomial;
                var zeros = p.getZeros();
                var min = 1 / 0;
                var candidate = null;
                var distance = function(x, y) {
                    return x.subtract(y);
                };
                for (var iteratorzero = zeros[globalThis.Symbol.iterator](), zero = iteratorzero.next().value; zero != null; zero = iteratorzero.next().value) {
                    var d = Math.abs(Number(distance(point, zero).toString({
                        rounding: {
                            fractionDigits: 2 * p.getDegree() + Math.ceil(p._log2hypot())
                        }
                    }))); //TODO: ?
                    if (candidate == null || d < min) {
                        min = d;
                        candidate = zero;
                    }
                }
                var result = candidate.upgrade();
                if (b instanceof Expression.NonSimplifiedExpression) { //TODO: !?
                    return new Expression.NonSimplifiedExpression(result);
                }
                return result;
            }
            throw new TypeError();
        })
    ];

    function OperationSearchCache() {
        this.map = {};
        this.re = null;
    }

    OperationSearchCache.prototype.append = function(operator) {
        this.map[operator.name.toLowerCase()] = operator;
        this.re = null;
    };
    OperationSearchCache.prototype.getByName = function(name) {
        return this.map[name.toLowerCase()];
    };
    OperationSearchCache.prototype.getRegExp = function() {
        // https://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
        var escapeRegExp = function(s) {
            // "-" is not escaped
            return s.replace(/[\/\\^$*+?.()|[\]{}]/g, '\\$&');
        };
        // longest: ? "^T" and "^"
        // ignore case
        if (this.re == null) { //TODO: ?
            var names = [];
            for (var name in this.map) {
                if (Object.prototype.hasOwnProperty.call(this.map, name)) {
                    names.push(name);
                }
            }
            names.sort(function(a, b) {
                // longest is lesser then shortest when one of strings is a prefix of another
                return a < b && b.lastIndexOf(a, 0) !== 0 || a.lastIndexOf(b, 0) === 0 ? -1 : +1;
            });
            var separator = String.fromCharCode(0x0000);
            this.re = new RegExp('^(?:' + escapeRegExp(names.join(separator)).split(separator).join('|').replace(/\|ch\|/g, '|ch(?!i)|').replace(/\|th\|/g, '|th(?!eta)|') + ')', 'i');
        }
        return this.re;
    };

    var operationSearchCache = new OperationSearchCache();
    var trigonometryFunctions = {};

    var i = -1;
    while (++i < operations.length) {
        operationSearchCache.append(operations[i]);
    }
    for (var iteratorname = 'cos sin tan cot'.split(' ')[globalThis.Symbol.iterator](), name = iteratorname.next().value; name != null; name = iteratorname.next().value) {
        operationSearchCache.append(Operator.trigonometry(name));
        trigonometryFunctions[name] = true;
    }
    for (var iteratorname = 'cosh sinh tanh coth arccos arcsin arctan arccot arcosh arsinh artanh arcoth'.split(' ')[globalThis.Symbol.iterator](), name = iteratorname.next().value; name != null; name = iteratorname.next().value) {
        operationSearchCache.append(Operator.simple(name));
    }

    var nextToken = function(tokenizer) {
        var token = null;
        do {
            token = tokenizer.next();
        } while (token.type === 'whitespace');
        return token;
    };

    var parsePunctuator = function(tokenizer, token, punctuator) {
        if (token.type !== 'punctuator' || token.value !== punctuator) {
            ExpressionParser.startPosition = tokenizer.previousPosition;
            ExpressionParser.endPosition = tokenizer.position;
            ExpressionParser.input = tokenizer.input;
            if (token.type === 'EOF') {
                throw new RangeError("UserError: unexpected end of input, '" + punctuator + "' expected");
            }
            throw new RangeError("UserError: unexpected '" + tokenizer.input.slice(tokenizer.previousPosition, tokenizer.position) + "', '" + punctuator + "' expected");
        }
        token = nextToken(tokenizer);
        return token;
    };

    function ParseResult(result, token) {
        this.result = result;
        this.token = token;
    }

    var parseMatrix = function(tokenizer, token, context) {
        var openingBracket = "{";
        var closingBracket = "}";

        var rows = [];
        var hasNextRow = true;
        while (hasNextRow) {
            token = parsePunctuator(tokenizer, token, openingBracket);
            var row = [];
            var hasNextCell = true;
            while (hasNextCell) {
                var tmp = parseExpression(tokenizer, token, context, COMMA_PRECEDENCE, undefined);
                token = tmp.token;
                row.push(tmp.result);
                if (token.type === 'punctuator' && token.value === ",") {
                    hasNextCell = true;
                    token = nextToken(tokenizer);
                } else {
                    hasNextCell = false;
                }
            }
            token = parsePunctuator(tokenizer, token, closingBracket);
            rows.push(row);
            if (token.type === 'punctuator' && token.value === ",") {
                hasNextRow = true;
                token = nextToken(tokenizer);
            } else {
                hasNextRow = false;
            }
        }
        token = parsePunctuator(tokenizer, token, "}");
        return new ParseResult(context.wrap(Expression.Matrix.fromArray(rows)), token);
    };

    var parseLaTeXMatrix = function(tokenizer, token, context, rowSeparator) {
        var rows = [];
        var firstRow = true;
        while (firstRow || (token.type === 'punctuator' && token.value === rowSeparator)) {
            if (firstRow) {
                firstRow = false;
            } else {
                token = nextToken(tokenizer);
            }
            var row = [];
            var firstCell = true;
            while (firstCell || token.type === 'punctuator' && token.value === "&") {
                if (firstCell) {
                    firstCell = false;
                } else {
                    token = nextToken(tokenizer);
                }
                var tmp = parseExpression(tokenizer, token, context, COMMA_PRECEDENCE, undefined);
                token = tmp.token;
                row.push(tmp.result);
            }
            rows.push(row);
        }
        return new ParseResult(context.wrap(Expression.Matrix.fromArray(rows)), token);
    };

    var parseLaTeXArgument = function(tokenizer, token, context) {
        return parseExpression(tokenizer, token, context, 0, undefined);
    };

    var getVulgarFraction = function(vulgarFraction) {
        var input = normalizeVulgarFractions(vulgarFraction).replace(/[\u2044]/g, "/");
        var e = Expression.Integer.fromString(input.slice(0, input.indexOf('/'))).divide(Expression.Integer.fromString(input.slice(input.indexOf('/') + '/'.length)));
        return e;
    };

    var getDecimalFraction = function(integerPart, nonRepeatingFractionalPart, repeatingFractionalPart, exponentPart) {
        var numerator = Expression.ZERO;
        var denominator = Expression.ONE;

        if (integerPart != undefined) {
            numerator = Expression.Integer.fromString(integerPart);
        }
        if (nonRepeatingFractionalPart != undefined) {
            var factor = Expression.pow(Expression.TEN, nonRepeatingFractionalPart.length);
            numerator = numerator.multiply(factor).add(Expression.Integer.fromString(nonRepeatingFractionalPart));
            denominator = denominator.multiply(factor);
        }
        if (repeatingFractionalPart != undefined) {
            var factor = Expression.pow(Expression.TEN, repeatingFractionalPart.length).subtract(Expression.ONE);
            numerator = numerator.multiply(factor).add(Expression.Integer.fromString(repeatingFractionalPart));
            denominator = denominator.multiply(factor);
        }
        if (exponentPart != undefined) {
            var exponent = 0 + Number(exponentPart);
            var factor = Expression.pow(Expression.TEN, exponent < 0 ? -exponent : exponent);
            if (exponent < 0) {
                denominator = denominator.multiply(factor);
            } else {
                numerator = numerator.multiply(factor);
            }
        }

        var value = numerator.divide(denominator);
        return value;
    };
    ExpressionParser._getDecimalFraction = getDecimalFraction;

    var parseDecimalFraction = function(tokenizer, token, context) {
        var isOnlyInteger = true;
        var result = undefined;
        if (token.type === 'integerLiteral') {
            result = Expression.Integer.fromString(token.value);
            result = context.wrap(result);
            token = nextToken(tokenizer);
        } else if (token.type === 'numericLiteral') {
            var value = token.value;
            //var match = token.match;
            var match = decimalFractionWithGroups.exec(value);
            isOnlyInteger = false;
            if (!context.needsWrap) {
                result = getDecimalFraction(match[1], match[2], match[3], match[4]);
            } else {
                result = new Expression.DecimalFraction(match[1], match[2], match[3], match[4]);
            }
            result = context.wrap(result);
            token = nextToken(tokenizer);
        }
        //!
        if (isOnlyInteger || result == undefined) {
            if (token.type === 'vulgarFraction') {
                var fraction = context.wrap(getVulgarFraction(token.value, context));
                if (result != undefined) {
                    result = result.add(fraction).addPosition(tokenizer.previousPosition, tokenizer.previousPosition, tokenizer.input);
                } else {
                    result = fraction;
                }
                token = nextToken(tokenizer);
            }
        }
        return result != undefined ? new ParseResult(result, token) : undefined;
    };

    // TODO: sticky flags - /\s+/y
    var whiteSpaces = /^\s+/;
    var punctuators = /^(?:[,&(){}|■@]|\\\\|(?:\\begin|\\end)(?:\{[bvp]?matrix\})?)/;
    var integerLiteral = /^\d+(?![\d.])(?![eEЕ]|اس)(?!,(?:\d|\(\d+\)))/; // for performance
    var integerLiteralWithoutComma = /^\d+(?![\d.])(?![eEЕ]|اس)/; // for performance
    var decimalFraction = /^(?=[.,]?\d)\d*(?:(?:[.]|[.,](?=\d|\(\d+\)))\d*(?:\(\d+\))?)?(?:(?:[eEЕ]|اس)[\+\-]?\d+)?/;
    var decimalFractionWithoutComma = new RegExp(decimalFraction.source.replace(/,/g, ''));
    // Base Latin, Base Latin upper case, Base Cyrillic, Base Cyrillic upper case, Greek alphabet
    // + https://en.wikipedia.org/wiki/Modern_Arabic_mathematical_notation#Mathematical_letters
    var greek = "alpha beta gamma delta epsilon zeta eta theta iota kappa lambda mu nu xi omicron pi rho varsigma sigma tau upsilon phi chi psi omega".split(" ");
    var ARABIC_MATHEMATIC_LETTER = /(?:[\u0627\u066E\u062D\u062F\u0633\u0634\u0635\u0639\u0637\u06BE\u062A]|\u062d\u0640\u0640\u0640\u0640)(?![\u0600-\u06FF])/;
    var symbols = new RegExp(/^(?:GREEK|circ|∞|[a-zA-Zа-яА-Яα-ωß]|ARABIC_MATHEMATIC_LETTER)(?:\_[0-9]+|\_\([a-z0-9]+,[a-z0-9]+\)|[\u2080-\u2089]+)?/.source.replace(/GREEK/g, greek.join('|')).replace(/ARABIC_MATHEMATIC_LETTER/g, ARABIC_MATHEMATIC_LETTER.source));
    var superscripts = /^[\u00B2\u00B3\u00B9\u2070\u2071\u2074-\u207F]+/; // superscript characters "2310i456789+−=()n"
    var vulgarFractions = /^[\u00BC-\u00BE\u2150-\u215E]/;
    //var other = /^\S/u;
    var other = /^(?:[\uD800-\uDBFF][\uDC00-\uDFFF]|\S)/; // should not split surrogate pairs (for Tokenizer and other things)

    var decimalFractionWithGroups = /^(\d+)?(?:[.,](\d+)?(?:\((\d+)\))?)?(?:(?:[eEЕ]|اس)([\+\-]?\d+))?$/;

    // s.normalize("NFKD")
    var normalizeSuperscripts = function(s) {
        return s.replace(/[\u00B2\u00B3\u00B9\u2070\u2071\u2074-\u207F]/g, function(c) {
            var charCode = c.charCodeAt(0);
            if (charCode === 0x00B2) {
                return "2";
            }
            if (charCode === 0x00B3) {
                return "3";
            }
            if (charCode === 0x00B9) {
                return "1";
            }
            var i = charCode - 0x2070;
            return "0i  456789+-=()n".slice(i, i + 1);
        });
    };

    // s.normalize("NFKD")
    var normalizeVulgarFractions = function(s) {
        return s.replace(/[\u00BC-\u00BE\u2150-\u215E]/g, function(c) {
            var charCode = c.charCodeAt(0);
            var i = charCode - 0x2150 < 0 ? (charCode - 0x00BC) * 2 : (3 + charCode - 0x2150) * 2;
            return "141234171911132315253545165618385878".slice(i, i + 2).replace(/^\S/g, "$&\u2044").replace(/1\u20441/g, "1\u204410");
        });
    };

    var normalizeSubscripts = function(s) {
        var i = s.length - 1;
        while (i >= 0 && s.charCodeAt(i) >= 0x2080 && s.charCodeAt(i) <= 0x2089) {
            i -= 1;
        }
        return i === s.length - 1 ? s : s.slice(0, i + 1) + "_" + s.slice(i + 1).replace(/[\u2080-\u2089]/g, function(c) {
            return String.fromCharCode(c.charCodeAt(0) - 0x2080 + "0".charCodeAt(0));
        });
    };

    var normalizeGreek = function(s) {
        var i = s.indexOf("_");
        var k = i === -1 ? s.length : i;
        if (k > 1) {
            var name = s.slice(0, k);
            var j = greek.indexOf(name);
            if (j !== -1) {
                return String.fromCharCode(0x03B1 + j) + s.slice(k);
            }
        }
        return s;
    };

    var parseExpression = function(tokenizer, token, context, precedence, left) {
        var ok = true;
        var isDecimalFraction = false;
        var tmp = undefined;
        var right = undefined;
        //!

        while (token.type !== 'EOF' && ok) {
            var op = undefined;
            var operand = undefined;

            var bestMatch = token.type === 'operator' || (token.type === 'punctuator' && token.value === ',') ? operationSearchCache.getByName(token.value) : null;
            if (bestMatch != null) {
                op = left == null && bestMatch.name === '+' ? UNARY_PLUS : (left == null && bestMatch.name === '-' ? UNARY_MINUS : bestMatch);
            }
            //  if (Input.startsWith(input, position, '\\begin') || Input.startsWith(input, position, '\\end')) {
            //    op = null;
            //  }

            //if (op != null && op.name === "\\" && Input.startsWith(input, position, "\\\\")) {
            //  if (isMatrixElement) {//TODO: optimize
            //    op = null;
            //} else if (Input.startsWith(input, position + 1, "begin") || Input.startsWith(input, position + 1, "left")) {
            //  op = null;
            //  }
            //}

            if (op != null && op.name === "frac") { // !isAlpha(Input.getFirst(input, position + "frac".length))
                if (!(left == null && precedence <= UNARY_PRECEDENCE_PLUS_ONE || precedence < MULTIPLICATIVE_PRECEDENCE)) {
                    ok = false;
                } else {
                    // https://en.wikipedia.org/wiki/Operand#Positioning_of_operands - prefix notation

                    token = nextToken(tokenizer);
                    tmp = parseExpression(tokenizer, token, context, MULTIPLICATIVE_PRECEDENCE, undefined);
                    var a = tmp.result;
                    token = tmp.token;
                    tmp = parseExpression(tokenizer, token, context, MULTIPLICATIVE_PRECEDENCE, undefined);
                    var b = tmp.result;
                    token = tmp.token;
                    // addPosition - ?
                    operand = op.i(a, b);
                    ok = true;
                }
            } else if (op != undefined) {
                // TODO: check if the checks are needed (tests - ?)
                if (!(left != undefined && (op.arity !== 1 || op.rightToLeftAssociative !== RIGHT_TO_LEFT || precedence < MULTIPLICATIVE_PRECEDENCE) ||
                        left == undefined && op.arity === 1 && op.rightToLeftAssociative === RIGHT_TO_LEFT) ||
                    //!(!candidate.xyz || !isAlpha(Input.getFirst(input, position + candidate.name.length))) ||//TODO: fix - ExpressionParser.parse("George")
                    precedence > op.precedence + (op.rightToLeftAssociative === RIGHT_TO_LEFT ? 0 : -1)) {
                    ok = false;
                } else {
                    var operatorPosition = tokenizer.previousPosition;
                    token = nextToken(tokenizer);
                    if (op.arity === 1 && op.rightToLeftAssociative !== RIGHT_TO_LEFT) {
                        //TODO: fix
                        ExpressionParser.startPosition = operatorPosition;
                        ExpressionParser.endPosition = operatorPosition + op.name.length;
                        ExpressionParser.input = tokenizer.input;
                        left = op.i(left).addPosition(operatorPosition, op.name.length, tokenizer.input);
                    } else {
                        if (op.arity === 1 && op.rightToLeftAssociative === RIGHT_TO_LEFT && op.precedence === UNARY_PRECEDENCE_PLUS_ONE && op.name.length > 1 &&
                            trigonometryFunctions[op.name] === true &&
                            (token.type === 'operator' && token.value === '^' || token.type === 'superscript' && /^\d+$/.test(normalizeSuperscripts(token.value)))) {
                            // https://en.wikipedia.org/wiki/Exponentiation#Exponential_notation_for_function_names

                            // cos^2(x)
                            //!new 2017-11-04
                            // parse an operator for the exponentiation
                            var exponentiationPosition = tokenizer.position;

                            var exponentiationLength = 0;
                            var middle = null;
                            if (token.type === 'superscript') {
                                middle = Expression.Integer.fromString(normalizeSuperscripts(token.value));
                                exponentiationLength = tokenizer.position - tokenizer.previousPosition;
                                token = nextToken(tokenizer);
                            } else {
                                exponentiationLength = '^'.length;
                                token = nextToken(tokenizer);
                                if (token.type !== 'integerLiteral') {
                                    ok = false;
                                } else {
                                    tmp = parseExpression(tokenizer, token, context, UNARY_PRECEDENCE, undefined);
                                    middle = tmp.result;
                                    token = tmp.token;
                                }
                            }
                            if (ok) {
                                // parse an operator for the current operator
                                tmp = parseExpression(tokenizer, token, context, op.precedence, undefined);
                                right = tmp.result;
                                token = tmp.token;
                                operand = op.i(right).addPosition(operatorPosition, op.name.length, tokenizer.input).pow(middle).addPosition(exponentiationPosition, exponentiationLength, tokenizer.input);
                            }
                        } else {
                            tmp = parseExpression(tokenizer, token, context, op.precedence, undefined);
                            right = tmp.result;
                            token = tmp.token;
                            //TODO: fix `1/(2-2)`
                            ExpressionParser.startPosition = operatorPosition;
                            ExpressionParser.endPosition = operatorPosition + op.name.length;
                            ExpressionParser.input = tokenizer.input;
                            if (op.arity === 1) {
                                // left <implicit multiplication> operand
                                operand = op.i(right).addPosition(operatorPosition, op.name.length, tokenizer.input);
                            } else if (op.arity === 2) {
                                left = op.i(left, right).addPosition(operatorPosition, op.name.length, tokenizer.input);
                            } else {
                                throw new RangeError();
                            }
                        }
                    }
                }
            } else if (left == undefined || precedence < MULTIPLICATIVE_PRECEDENCE || (precedence === UNARY_PRECEDENCE_PLUS_ONE && isDecimalFraction && token.type === 'symbol')) {
                if ((tmp = parseDecimalFraction(tokenizer, token, context)) != undefined) {
                    operand = tmp.result;
                    token = tmp.token;
                    isDecimalFraction = true;
                } else if (token.type === 'punctuator' && token.value === "(") {
                    token = parsePunctuator(tokenizer, token, "(");
                    tmp = parseExpression(tokenizer, token, context, 0, undefined);
                    operand = tmp.result;
                    token = tmp.token;
                    token = parsePunctuator(tokenizer, token, ")");
                } else if (token.type === 'punctuator' && token.value === "{") {
                    token = parsePunctuator(tokenizer, token, "{");
                    if (token.type === 'punctuator' && token.value === "{") {
                        tmp = parseMatrix(tokenizer, token, context);
                        operand = tmp.result;
                        token = tmp.token;
                    } else {
                        tmp = parseLaTeXArgument(tokenizer, token, context);
                        operand = tmp.result;
                        token = tmp.token;
                        token = parsePunctuator(tokenizer, token, "}");
                    }
                } else if (token.type === 'punctuator' && (token.value === "\\begin{bmatrix}" ||
                        token.value === "\\begin{vmatrix}" ||
                        token.value === "\\begin{pmatrix}" ||
                        token.value === "\\begin{matrix}")) {
                    var kind = token.value.slice('\\begin{'.length, -1);
                    token = nextToken(tokenizer);
                    tmp = parseLaTeXMatrix(tokenizer, token, context, '\\\\');
                    operand = tmp.result;
                    token = tmp.token;
                    if (token.type === 'punctuator' && token.value === "\\end{" + kind + "}") {
                        token = nextToken(tokenizer);
                    }
                    if (kind === 'vmatrix') {
                        operand = operand.determinant(); //!
                    }
                } else if (token.type === 'symbol') {
                    var symbolName = token.value;
                    symbolName = normalizeSubscripts(symbolName);
                    symbolName = normalizeGreek(symbolName);
                    operand = context.get(symbolName);
                    operand = context.wrap(operand);
                    token = nextToken(tokenizer);
                } else if (token.type === 'punctuator' && token.value === "|") {
                    if (left == undefined || Expression.isScalar(left)) { //!
                        if (left != undefined && precedence >= COMMA_PRECEDENCE) {
                            debugger;
                        }
                        token = parsePunctuator(tokenizer, token, "|");
                        tmp = parseExpression(tokenizer, token, context, COMMA_PRECEDENCE, undefined);
                        operand = tmp.result;
                        token = tmp.token;
                        token = parsePunctuator(tokenizer, token, "|");
                        if (Expression.isScalar(operand)) { //TODO: !?
                            operand = operand.abs();
                        } else {
                            operand = operand.determinant(); //!
                        }
                    } else if (precedence < COMMA_PRECEDENCE) {
                        //TODO: fix
                        token = parsePunctuator(tokenizer, token, "|");
                        tmp = parseExpression(tokenizer, token, context, 0, undefined);
                        operand = tmp.result;
                        token = tmp.token;
                        operand = left.augment(operand);
                        left = undefined;
                    } else {
                        ok = false;
                    }
                } else if (token.type === 'punctuator' && token.value === '■') {
                    token = nextToken(tokenizer);
                    token = parsePunctuator(tokenizer, token, '(');
                    tmp = parseLaTeXMatrix(tokenizer, token, context, '@');
                    operand = tmp.result;
                    token = tmp.token;
                    token = parsePunctuator(tokenizer, token, ')');
                } else {
                    ok = false;
                }
            } else {
                ok = false;
            }

            //!TODO: fix
            if (!ok && left != undefined && precedence <= UNARY_PRECEDENCE + (RIGHT_TO_LEFT === RIGHT_TO_LEFT ? 0 : -1)) {
                if (token.type === 'superscript') {
                    // implicit exponentiation
                    //TODO: check position
                    var x = ExpressionParser.parse(normalizeSuperscripts(token.value), context); //?
                    left = left.pow(x).addPosition(tokenizer.previousPosition, tokenizer.previousPosition, tokenizer.input);
                    token = nextToken(tokenizer);
                    ok = true; //!
                }
            }

            if (!ok && token.type === 'operator' && token.value === "\\") { // isAlpha(Input.getFirst(input, position + 1))
                // TODO: LaTeX - ?
                ok = true;
                token = nextToken(tokenizer);
            }

            if (operand != undefined) {
                if (left != undefined) {
                    // implied multiplication
                    var oldPosition = tokenizer.position;
                    tmp = parseExpression(tokenizer, token, context, MULTIPLICATIVE_PRECEDENCE, operand);
                    var right1 = tmp.result;
                    token = tmp.token;
                    left = left.multiply(right1).addPosition(oldPosition, "*".length, tokenizer.input);
                } else {
                    left = operand;
                }
            }
        }

        if (left == undefined) {
            ExpressionParser.startPosition = tokenizer.previousPosition;
            ExpressionParser.endPosition = tokenizer.position;
            ExpressionParser.input = tokenizer.input;
            if (token.type === 'EOF') {
                throw new RangeError("UserError: unexpected end of input"); //TODO: fix
            }
            //TODO: ?
            throw new RangeError("UserError: unexpected '" + tokenizer.input.slice(tokenizer.previousPosition, tokenizer.position) + "'"); //TODO: fix
        }
        return new ParseResult(left, token);
    };

    var decimalNumberRegExp = new RegExp('\\p{Decimal_Number}', 'u');
    var replaceSimpleDigit = function(codePoint) {
        var i = 0;
        while (decimalNumberRegExp.test(String.fromCodePoint(codePoint - i))) {
            i += 1;
        }
        return i === 0 ? -1 : (i - 1) % 10;
    };

    var map = {
        ":": "/",
        "[": "(",
        "]": ")",
        "·": "*",
        "×": "*",
        "÷": "/",
        "ˆ": "^",
        "ϕ": "φ",
        "А": "A",
        "В": "B",
        "С": "C",
        "Т": "T",
        "а": "A",
        "в": "B",
        "с": "C",
        "т": "T",
        "،": ",",
        "٫": ",",
        "\u200B": " ",
        "‐": "-",
        "‑": "-",
        "‒": "-",
        "–": "-",
        "—": "-",
        "―": "-",
        "•": "*",
        "\u2061": " ",
        "\u2062": "*",
        "\u2063": ",",
        "\u2064": " ",
        "ⅇ": "e",
        "ⅈ": "i",
        "−": "-",
        "∕": "/",
        "∙": "*",
        "≤": "⩽",
        "≥": "⩾",
        "⋅": "*",
        "│": "|",
        "█": "■",
        "✓": "√",
        "〇": "0",
        "〖": "(",
        "〗": ")",
        "ー": "-",
        "一": "1",
        "七": "7",
        "三": "3",
        "九": "9",
        "二": "2",
        "五": "5",
        "八": "8",
        "六": "6",
        "四": "4"
    };


    //if (charCode === "Х".charCodeAt(0)) {
    //  return "X";
    //}
    //if (charCode === "х".charCodeAt(0)) {
    //  return "X";
    //}
    // 0x003A - Deutsch
    // "\u2064" is replaced by " ", not "+", as "+" has smaller priority
    // "ϕ".normalize("NFKD") === "φ"
    //if (/\p{Cf}/u.test(String.fromCodePoint(codePoint))) {
    //  return " ".charCodeAt(0);
    //}
    // hanidec digits

    var isBidiControl = function(codePoint) {
        // /\p{Bidi_Control}/u.test(String.fromCodePoint(codePoint))
        return codePoint === 0x061C ||
            codePoint === 0x200E ||
            codePoint === 0x200F ||
            codePoint >= 0x202A && codePoint <= 0x202E ||
            codePoint >= 0x2066 && codePoint <= 0x2069;
    };

    var getCodePointReplacement = function(codePoint) {
        if (codePoint >= 0xFF01 && codePoint <= 0xFF5E) {
            // normalize full-width forms:
            return codePoint - 0xFF01 + 0x0021;
        }
        var digit = replaceSimpleDigit(codePoint);
        if (digit !== -1) {
            return digit + "0".charCodeAt(0);
        }
        if (isBidiControl(codePoint)) {
            return " ".charCodeAt(0);
        }
        if (codePoint >= 0x0000 && codePoint <= 0xFFFF) {
            // today map contains only BMP characters in keys and values
            var replacement = map[String.fromCharCode(codePoint)];
            if (replacement != undefined && replacement.length === 1) {
                return replacement.charCodeAt(0);
            }
        }
        return -1;
    };

    //input = input.replace(replaceRegExp, replaceFunction); - slow in Chrome
    var replaceSomeChars = function(input) {
        var lastIndex = 0;
        var result = '';
        var i = 0;
        while (i < input.length) {
            var codePoint = input.codePointAt(i);
            var width = codePoint <= 0xFFFF ? 1 : 2;
            if (codePoint > 0x007F || codePoint === 0x003A || codePoint === 0x005B || codePoint === 0x005D) {
                var x = getCodePointReplacement(codePoint);
                if (x !== -1) {
                    if (!(x >= 0x0000 && x <= 0xFFFF)) {
                        throw new RangeError(); // assertion
                    }
                    result += input.slice(lastIndex, i);
                    result += String.fromCharCode(x);
                    lastIndex = i + width;
                }
            }
            i += width;
        }
        result += input.slice(lastIndex);
        return result;
    };

    var config = [{
            type: 'integerLiteral',
            re: null
        },
        {
            type: 'numericLiteral',
            re: null
        },
        {
            type: 'whitespace',
            re: whiteSpaces
        },
        {
            type: 'punctuator',
            re: punctuators
        },
        {
            type: 'operator',
            re: null
        },
        {
            type: 'symbol',
            re: symbols
        },
        {
            type: 'vulgarFraction',
            re: vulgarFractions
        },
        {
            type: 'superscript',
            re: superscripts
        },
        {
            type: 'OTHER',
            re: other
        }
    ];

    function Token(type, value) {
        this.type = type;
        this.value = value;
    }

    Token.EOF = new Token('EOF', '');

    function Tokenizer(input, position, states) {
        this._preparedInput = replaceSomeChars(input.slice(position)); //TODO: fix ???
        this.input = input;
        this._preparedInputPosition = 0;
        this.previousPosition = position;
        this.position = position;
        this.states = states;
    }

    Tokenizer.prototype.next = function() {
        this.previousPosition = this.position;
        if (this.position >= this.input.length) {
            return Token.EOF;
        }
        // iteration by object keys is slower (?)
        for (var i = 0; i < config.length; i += 1) {
            var c = config[i];
            var type = c.type;
            var re = c.re;
            if (re == null) {
                if (type === 'integerLiteral') {
                    if (this.states != null && this.states.value === '{}') {
                        re = integerLiteralWithoutComma;
                    } else {
                        re = integerLiteral;
                    }
                } else if (type === 'numericLiteral') {
                    if (this.states != null && this.states.value === '{}') {
                        re = decimalFractionWithoutComma;
                    } else {
                        re = decimalFraction;
                    }
                } else if (type === 'operator') {
                    re = operationSearchCache.getRegExp(); //?TODO:
                }
            }
            var tmp = re.exec(this._preparedInput.slice(this._preparedInputPosition));
            if (tmp != null) {
                var value = tmp[0];
                if (type === 'punctuator') {
                    if (value === '(') {
                        this.states = {
                            previous: this.states,
                            value: '()'
                        };
                    } else if (value === ')') {
                        if (this.states != null && this.states.value === '()') {
                            this.states = this.states.previous;
                        }
                    } else if (value === '{') {
                        this.states = {
                            previous: this.states,
                            value: '{}'
                        };
                    } else if (value === '}') {
                        if (this.states != null && this.states.value === '{}') {
                            this.states = this.states.previous;
                        }
                    }
                }
                for (var j = 0; j < value.length; j += (value.codePointAt(j) <= 0xFFFF ? 1 : 2)) {
                    this.position += this.input.codePointAt(this.position) <= 0xFFFF ? 1 : 2;
                }
                this._preparedInputPosition += value.length;
                return new Token(type, value);
            }
        }
        throw new TypeError();
    };

    var fs = {}; //!TODO: remove!!!

    function ExpressionParser() {}

    ExpressionParser.parse = function(input, context) {
        context = context == undefined ? new ExpressionParser.Context(undefined, false) : context;

        ExpressionParser.startPosition = -1;
        ExpressionParser.endPosition = -1;
        ExpressionParser.input = input; //?

        // TODO: remove
        if (typeof input !== "string") {
            throw new RangeError();
        }

        if (typeof hit === "function" && context.getter != undefined) {
            var re = /[a-z][a-z][a-z\-]+/gi;
            var m = null;
            while ((m = re.exec(input)) != null) {
                var t = m[0];
                if (!(t in fs) && t.indexOf("-") === -1) {
                    fs[t] = true;
                    hit({
                        fs: t
                    });
                }
            }
        }

        var tokenizer = new Tokenizer(input, 0, null);
        var token = nextToken(tokenizer);
        var tmp = parseExpression(tokenizer, token, context, 0, undefined);
        token = tmp.token;
        if (token.type !== 'EOF') {
            ExpressionParser.startPosition = tokenizer.previousPosition;
            ExpressionParser.endPosition = tokenizer.position;
            ExpressionParser.input = tokenizer.input;
            throw new RangeError("UserError: unexpected '" + tokenizer.input.slice(tokenizer.previousPosition, tokenizer.position) + "'");
        }

        return tmp.result;
    };

    globalThis.Tokenizer = Tokenizer;

    ExpressionParser.startPosition = -1;
    ExpressionParser.endPosition = -1;
    ExpressionParser.input = "";

    var getConstant = function(symbolName) {
        if (symbolName === "pi" || symbolName === "\u03C0" || symbolName === "\u0637") {
            return Expression.PI;
        }
        if (symbolName === "e" || symbolName === "\u06BE") {
            return Expression.E;
        }
        if (symbolName === "i" || symbolName === "\u062A") {
            return Expression.I;
        }
        if (symbolName === "I" || symbolName === "U" || symbolName === "E") {
            return new Expression.IdentityMatrix(symbolName);
        }
        if (symbolName === "circ") { //TODO: ○ - ?
            return Expression.CIRCLE;
        }
        if (symbolName === "∞") {
            return Expression.INFINITY;
        }
        return new Expression.Symbol(symbolName);
    };

    ExpressionParser.Context = function(getter, needsWrap) {
        this.getter = getter;
        this.needsWrap = needsWrap == undefined ? true : needsWrap;
    };
    ExpressionParser.Context.prototype.get = function(symbolName) {
        if (this.getter != undefined) {
            var x = this.getter(symbolName);
            if (x != undefined) {
                return x;
            }
        }
        return getConstant(symbolName);
    };
    ExpressionParser.Context.prototype.wrap = function(e) {
        if (!this.needsWrap) {
            return e;
        }
        return new Expression.NonSimplifiedExpression(e);
    };

    ExpressionParser.addOperation = function(denotation, arity) {
        //TODO: UNARY_PRECEDENCE -> UNARY_PRECEDENCE_PLUS_ONE - ???
        var newOperation = arity === 1 ? new Operator(denotation, arity, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function(a) {
            return a.transformNoAnswerExpression(denotation);
        }) : new Operator(denotation, arity, RIGHT_TO_LEFT, MULTIPLICATIVE_PRECEDENCE, function(a, b) {
            return a.transformNoAnswerExpression(denotation, b);
        });
        //operations.push(newOperation);
        operationSearchCache.append(newOperation);
    };

    ExpressionParser.addDenotations = function(denotationsByOperation) {
        for (var operationName in denotationsByOperation) {
            if (Object.prototype.hasOwnProperty.call(denotationsByOperation, operationName)) {
                var denotations = denotationsByOperation[operationName];
                var operation = operationSearchCache.getByName(operationName);
                var added = {};
                added[operationName] = true;
                for (var key in denotations) {
                    if (Object.prototype.hasOwnProperty.call(denotations, key)) {
                        var denotation = denotations[key];
                        if (added[denotation] == undefined) {
                            added[denotation] = true;
                            var newOperation = new Operator(denotation, operation.arity, operation.rightToLeftAssociative, operation.precedence, operation.i);
                            //operations.push(newOperation);
                            operationSearchCache.append(newOperation);
                            if (trigonometryFunctions[operationName]) {
                                trigonometryFunctions[denotation] = true;
                            }
                        }
                    }
                }
            }
        }
    };

    self.ExpressionParser = ExpressionParser;

})();
(function() {
    "use strict";
    /*jslint plusplus: true, vars: true, indent: 2 */

    //(function (exports) {
    //"use strict";

    function Heap(compareTo) {
        this.data = [];
        this.compareTo = compareTo;
    }

    Heap.prototype.push = function(value) {
        var data = this.data;
        var compareTo = this.compareTo;
        data.push(value);
        // bubbleUp(size - 1)
        var size = data.length;
        var j = size - 1;
        var tmp = data[j];
        var parent = -1;
        while (j > 0 && compareTo(tmp, data[parent = Math.floor((j - 1) / 2)]) < 0) {
            data[j] = data[parent];
            j = parent;
        }
        data[j] = tmp;
    };

    Heap.prototype.pop = function() {
        var data = this.data;
        var compareTo = this.compareTo;
        var size = data.length;
        if (size === 0) {
            return undefined;
        }
        if (size === 1) {
            return data.pop();
        }
        var value = data[0];
        data[0] = data.pop();
        --size;
        // bubbleDown(0)
        var j = 0;
        if (j < size) {
            var tmp = data[j];
            do {
                var child = size;
                var t = tmp;
                var c = j * 2;
                if (++c < size && compareTo(data[c], t) < 0) {
                    child = c;
                    t = data[child];
                }
                if (++c < size && compareTo(data[c], t) < 0) {
                    child = c;
                    t = data[child];
                }
                data[j] = t;
                j = child;
            } while (j < size);
        }
        return value;
    };

    Heap.prototype.peek = function() {
        var data = this.data;
        return data.length > 0 ? data[0] : undefined;
    };

    Heap.prototype.size = function() {
        var data = this.data;
        return data.length;
    };

    Heap.prototype.replace = function(newItem) {
        this.data.push(newItem);
        return this.pop();
    };

    //exports.Heap = Heap;

    //}(this));
    self.Heap = Heap;

})();
(function() {
    "use strict";
    /*global hit*/

    // Transformation methods:

    //   Polynomial#_exponentiateRoots(n) (α_1 = α**n or x = x_1**(1/n)) - ? - throws when cannot do it (?)
    //   Polynomial#_scaleRoots(s) (α_1 = α * s or x = x_1 / s)
    //   Polynomial#_translateRoots(h) (α_1 = α + h or x = x_1 - h)





    //


    var isPrime = primeFactor._isPrime;

    //var freeze = Object.freeze; - too slow
    var freeze = function(x) {
        return x;
    };

    // similar to https://developer.android.com/reference/android/util/SparseArray
    function PolynomialData(length) {
        this.degrees = new Array(length);
        this.coefficients = new Array(length);
        this.size = 0; // public
    }

    PolynomialData.prototype.add = function(degree, coefficient) {
        var k = this.size;
        if (!(Math.floor(degree) === degree && degree >= 0 && degree <= Number.MAX_SAFE_INTEGER)) {
            throw new RangeError("NotSupportedError");
        }
        if (k > 0 && !(degree < this.degrees[k - 1]) || k >= this.degrees.length || k >= this.coefficients.length) {
            throw new RangeError();
        }
        this.degrees[k] = degree;
        this.coefficients[k] = coefficient;
        this.size = k + 1;
    };
    PolynomialData.prototype.degree = function(i) {
        return this.degrees[i];
    };
    PolynomialData.prototype.coefficient = function(i) {
        return this.coefficients[i];
    };
    PolynomialData.prototype.trim = function() {
        if (this.size < Math.max(this.degrees.length, this.coefficients.length)) {
            this.degrees.length = this.size;
            this.coefficients.length = this.size;
        }
        return this;
    };

    // Polynomial([a0, a1, a2, ...., an]);
    // an*x^n+ an-1 x ^n-1 +... + a0
    function Polynomial(a) {
        this.a = a.trim();
    }
    Polynomial.of = function() {
        var newData = new PolynomialData(arguments.length);
        for (var i = arguments.length - 1; i >= 0; i -= 1) {
            var a = arguments[i];
            if (!a.equals(Expression.ZERO)) {
                newData.add(i, a);
            }
        }
        return new Polynomial(newData);
    };
    Polynomial.from = function(array) {
        var newData = new PolynomialData(array.length);
        for (var i = array.length - 1; i >= 0; i -= 1) {
            var degree = i;
            var coefficient = array[i];
            if (!coefficient.equals(Expression.ZERO)) {
                newData.add(degree, coefficient);
            }
        }
        return new Polynomial(newData);
    };
    Polynomial.ZERO = Polynomial.of();
    Polynomial.prototype.getDegree = function() {
        return this.a.size === 0 ? -1 : this.a.degree(0);
    };
    Polynomial.prototype.getCoefficient = function(degree) {
        var from = 0;
        var to = this.a.size;
        while (from < to) {
            var middle = from + Math.floor((to - from) / 2);
            var y = this.a.degree(middle);
            if (y > degree) {
                from = middle + 1;
            } else if (y < degree) {
                to = middle;
            } else {
                return this.a.coefficient(middle);
            }
        }
        return Expression.ZERO;
    };
    Polynomial.prototype.getLeadingCoefficient = function() {
        return this.a.size === 0 ? Expression.ZERO : this.a.coefficient(0);
    };
    Polynomial.prototype.map = function(mapFunction) {
        //?
        if (mapFunction.length !== 1) {
            throw new RangeError("deprecated");
        }
        var newData = new PolynomialData(this.a.size);
        for (var i = 0; i < this.a.size; i += 1) {
            var degree = this.a.degree(i);
            var coefficient = this.a.coefficient(i);
            var c = mapFunction(coefficient);
            if (!c.equals(Expression.ZERO)) {
                newData.add(degree, c);
            }
        }
        return new Polynomial(newData);
    };
    Polynomial.prototype.equals = function(p) {
        if (p === Expression.ZERO) {
            return this.a.size === 0;
        }
        if (this.a.size !== p.a.size) {
            return false;
        }
        var i = 0;
        var j = 0;
        while (i < this.a.size && j < p.a.size) {
            if (this.a.degree(i) !== p.a.degree(j) || !this.a.coefficient(i).equals(p.a.coefficient(j))) {
                return false;
            }
            i += 1;
            j += 1;
        }
        return true;
    };

    // mapFunction(0, 0) === 0
    function _join(A, B, mapFunction) {
        var newData = new PolynomialData(A.a.size + B.a.size);
        var i = -1;
        var x = -2;
        var xc = Expression.ZERO;
        var j = -1;
        var y = -2;
        var yc = Expression.ZERO;
        while (x !== -1 || y !== -1) {
            var d = Math.max(x, y);
            if (d !== -2) {
                //var c = x > y ? xc : (y > x ? yc : xc.add(yc));
                var c = mapFunction(x >= y ? xc : Expression.ZERO, y >= x ? yc : Expression.ZERO);
                if (x !== y || !c.equals(Expression.ZERO)) {
                    newData.add(d, c);
                }
            }
            if (x === d) {
                i += 1;
                if (i < A.a.size) {
                    x = A.a.degree(i);
                    xc = A.a.coefficient(i);
                } else {
                    x = -1;
                    xc = Expression.ZERO;
                }
            }
            if (y === d) {
                j += 1;
                if (j < B.a.size) {
                    y = B.a.degree(j);
                    yc = B.a.coefficient(j);
                } else {
                    y = -1;
                    yc = Expression.ZERO;
                }
            }
        }
        return new Polynomial(newData);
    }
    Polynomial.prototype.add = function(p) {
        if (p.a.size === 0) {
            return this;
        }
        if (this.a.size === 0) {
            return p;
        }
        return _join(this, p, function(xc, yc) {
            if (xc === Expression.ZERO) {
                return yc;
            }
            if (yc === Expression.ZERO) {
                return xc;
            }
            return xc.add(yc);
        });
    };

    function split_at(p, d) {
        var tmp = p.divideAndRemainder(Polynomial.of(Expression.ONE).shift(d));
        return [tmp.quotient, tmp.remainder];
    }
    var KARATSUBA_THRESHOLD = 17;

    // https://en.wikipedia.org/wiki/Karatsuba_algorithm#Pseudocode
    function karatsuba(p1, p2) {
        if (p1.a.size < KARATSUBA_THRESHOLD || p2.a.size < KARATSUBA_THRESHOLD) {
            return p1.multiply(p2);
        }

        /* Calculates the size of the numbers. */
        var m = Math.min(p1.a.size, p2.a.size);
        var m2 = (p2.a.size <= p1.a.size ? p2 : p1).a.degree(Math.floor(m / 2));
        /* var m2 = Math.ceil(m / 2) will also work */

        /* Split the digit sequences in the middle. */
        var $tmphigh1_low1 = split_at(p1, m2);
        var high1 = $tmphigh1_low1[0];
        var low1 = $tmphigh1_low1[1];
        var $tmphigh2_low2 = split_at(p2, m2);
        var high2 = $tmphigh2_low2[0];
        var low2 = $tmphigh2_low2[1];

        /* 3 calls made to numbers approximately half the size. */
        var z0 = karatsuba(low1, low2);
        var z1 = karatsuba(low1.add(high1), low2.add(high2));
        var z2 = karatsuba(high1, high2);
        return z2.shift(m2 * 2).add(z1.subtract(z2).subtract(z0).shift(m2)).add(z0);
    }

    function multiplyInternal(A, B, fromLeft) {
        var npmp1 = A.getDegree() + B.getDegree() + 1;
        if ((A.a.size + B.a.size + Math.min(A.a.size, B.a.size)) * 4 >= npmp1) {
            // "dense"
            var result = new Array(npmp1).fill(Expression.ZERO);
            for (var i = 0; i < A.a.size; i += 1) {
                var d = A.a.degree(i);
                var c = A.a.coefficient(i);
                for (var j = 0; j < B.a.size; j += 1) {
                    var bd = B.a.degree(j);
                    var bj = B.a.coefficient(j);
                    var degree = d + bd;
                    var coefficient = fromLeft ? c.multiply(bj) : bj.multiply(c);
                    result[degree] = result[degree].add(coefficient);
                }
            }
            return Polynomial.from(result);
        } else {
            var result = new FastAdditionPolynomial();
            for (var i = 0; i < A.a.size; i += 1) {
                var d = A.a.degree(i);
                var c = A.a.coefficient(i);
                result.add(c, d, B, fromLeft);
            }
            return result.toPolynomial();
        }
    }
    Polynomial.prototype.multiply = function(p) {
        if (this.a.size === 0 || p.a.size === 0) {
            return Polynomial.ZERO;
        }
        if (p.a.size === 1 && p.a.coefficient(0) instanceof Expression.Integer) {
            // commutative multiplication
            return this.shift(p.a.degree(0)).scale(p.a.coefficient(0));
        }
        if (p.a.size >= KARATSUBA_THRESHOLD && this.a.size >= KARATSUBA_THRESHOLD) {
            //debugger;
            //console.count('KARATSUBA_THRESHOLD');
            return karatsuba(this, p);
        }
        if (this.a.size <= p.a.size) {
            return multiplyInternal(this, p, true);
        } else {
            return multiplyInternal(p, this, false);
        }
    };
    Polynomial.prototype.shift = function(n) {
        // *= x**n, n >= 0
        if (!(n >= 0)) {
            throw new TypeError();
        }
        if (n === 0) {
            return this;
        }
        var newData = new PolynomialData(this.a.size);
        for (var i = 0; i < this.a.size; i += 1) {
            newData.add(this.a.degree(i) + n, this.a.coefficient(i));
        }
        return new Polynomial(newData);
    };

    //note: no Map is needed
    function FastAdditionPolynomial() {
        // see http://www.cecm.sfu.ca/~mmonagan/teaching/TopicsinCA11/johnson.pdf
        // see https://en.wikipedia.org/wiki/K-way_merge_algorithm#Heap
        this.maxHeap = new Heap(function(a, b) {
            return b.degree - a.degree;
        });
        this.degree = -1;
        this.leadingCoefficient = Expression.ZERO;
    }
    FastAdditionPolynomial.prototype.add = function(scale, shift, polynomial, fromLeft) {
        var i = 0;
        var iterator = {
            next: function() {
                if (i === polynomial.a.size) {
                    return undefined;
                }
                var d = polynomial.a.degree(i);
                var c = polynomial.a.coefficient(i);
                i += 1;
                return freeze({
                    degree: d + shift,
                    coefficient: c === Expression.ONE ? scale : scale === Expression.ONE ? c : fromLeft ? scale.multiply(c) : c.multiply(scale),
                    iterator: iterator
                });
            }
        };
        var newEntry = iterator.next();
        if (newEntry.degree > this.degree && this.degree !== -1) {
            throw new RangeError();
        } else if (newEntry.degree < this.degree) {
            this.maxHeap.push(newEntry);
        } else {
            if (this.degree === -1) {
                this.leadingCoefficient = newEntry.coefficient;
                this.degree = newEntry.degree;
            } else {
                this.leadingCoefficient = this.leadingCoefficient.add(newEntry.coefficient);
            }
            newEntry = newEntry.iterator.next();
            if (newEntry != undefined) {
                this.maxHeap.push(newEntry);
            }
            // Computation of the leading coefficient:
            while (this.maxHeap.size() > 0 && (this.degree === this.maxHeap.peek().degree || this.leadingCoefficient.equals(Expression.ZERO))) {
                var tmp = this.maxHeap.peek();
                this.leadingCoefficient = this.leadingCoefficient.add(tmp.coefficient);
                this.degree = tmp.degree;
                var next = tmp.iterator.next();
                if (next != undefined) {
                    //this.maxHeap.pop();
                    //this.maxHeap.push(next);
                    this.maxHeap.replace(next);
                } else {
                    this.maxHeap.pop();
                }
            }
            if (this.maxHeap.size() === 0 && this.leadingCoefficient.equals(Expression.ZERO)) {
                this.degree = -1;
            }
        }
    };
    FastAdditionPolynomial.prototype.getDegree = function() {
        return this.degree;
    };
    FastAdditionPolynomial.prototype.getLeadingCoefficient = function() {
        return this.leadingCoefficient;
    };
    FastAdditionPolynomial.prototype.toPolynomial = function() {
        var terms = [];
        var ONE = Polynomial.of(Expression.ONE);
        while (this.getDegree() >= 0) {
            var degree = this.getDegree();
            var coefficient = this.getLeadingCoefficient();
            this.add(coefficient.negate(), degree, ONE, true);
            terms.push({
                degree: degree,
                coefficient: coefficient
            });
        }
        return Polynomial.fromTerms(terms);
    };
    Polynomial.prototype.divideAndRemainder = function(p, w, callback0) {
        w = w || undefined;
        if (p.equals(Polynomial.ZERO)) {
            throw new TypeError("ArithmeticException");
        }
        if (this.getDegree() < p.getDegree()) {
            return {
                quotient: Polynomial.ZERO,
                remainder: this
            };
        }
        if (p.a.size === 1 && p.a.coefficient(0).equals(Expression.ONE) && (w == undefined || this._hasIntegerLikeCoefficients())) {
            //TODO: !!!
            if (p.a.degree(0) === 0) {
                return {
                    quotient: this,
                    remainder: Polynomial.ZERO
                };
            }
            var s = p.a.degree(0);
            var k = 0;
            while (this.a.degree(k) >= s && k < this.a.size) {
                k += 1;
            }
            var q = new PolynomialData(k);
            for (var i = 0; i < k; i += 1) {
                q.add(this.a.degree(i) - s, this.a.coefficient(i));
            }
            var r = new PolynomialData(this.a.size - k);
            for (var i = k; i < this.a.size; i += 1) {
                r.add(this.a.degree(i), this.a.coefficient(i));
            }
            return {
                quotient: new Polynomial(q),
                remainder: new Polynomial(r)
            };
        }
        var lcp = p.getLeadingCoefficient();
        var lcpInv = lcp instanceof Expression.ExpressionWithPolynomialRoot ? lcp.inverse() : undefined; // TODO: ?
        if (p.a.size === 1 && p.a.degree(0) === 0 && lcpInv == undefined && (w == undefined || w === "throw")) {
            return {
                quotient: this.map(function(c) {
                    var q = c.divide(lcp);
                    if (w != undefined) {
                        if (q instanceof Expression.Division) {
                            throw new RangeError(); // AssertionError
                        }
                    }

                    return q;
                }),
                remainder: Polynomial.ZERO
            };
        }
        var quotient = [];
        var isSparse = this.a.size / this.getDegree() < 1 / 4 && callback0 == undefined; //TODO: ?
        var remainder = this;
        if (isSparse) {
            remainder = new FastAdditionPolynomial();
            remainder.add(Expression.ONE, 0, this, true);
        }
        var minusP = p.negate();
        while (remainder.getDegree() >= p.getDegree()) {
            var n = remainder.getDegree() - p.getDegree();
            var lcr = remainder.getLeadingCoefficient();
            var q = lcpInv == undefined ? lcr.divide(lcp) : lcr.multiply(lcpInv);
            if (callback0 != undefined) {
                q = callback0(q);
            }
            if (w != undefined) {
                if (q instanceof Expression.Division) {
                    if (w === "throw") {
                        throw new TypeError(this.toString() + " " + p.toString()); // AssertionError
                    } else if (w === "undefined") {
                        return undefined;
                    } else {
                        throw new TypeError();
                    }
                }
            }
            //TODO: optimize - ?
            quotient.push({
                degree: n,
                coefficient: q
            });
            //TODO: optimize - ?
            if (isSparse) {
                remainder.add(q, n, minusP, true);
            } else {
                if (!(q instanceof Expression.Integer)) {
                    remainder = remainder.add(Polynomial.of(q).shift(n).multiply(minusP));
                } else {
                    remainder = remainder.add(minusP.shift(n).scale(q));
                }
            }
            if (callback0 != undefined) {
                while (remainder.getDegree() >= 0 && callback0(remainder.getLeadingCoefficient()).equals(Expression.ZERO)) {
                    remainder = remainder.subtract(Polynomial.of(remainder.getLeadingCoefficient()).shift(remainder.getDegree()));
                }
            }
            if (remainder.getDegree() - p.getDegree() === n) {
                // to avoid the infite loop
                throw new TypeError("there is a some problem with the expression evaluation"); //!
            }
        }

        if (isSparse) {
            remainder = remainder.toPolynomial();
        }
        return {
            quotient: Polynomial.fromTerms(quotient),
            remainder: remainder
        };
    };
    Polynomial.prototype.divideAndRemainderModP = function(divisor, p) {
        var divisorLeadingCoefficient = divisor.getLeadingCoefficient();
        if (!(divisorLeadingCoefficient instanceof Expression.Polynomial) && !divisorLeadingCoefficient.equals(Expression.ONE) || divisorLeadingCoefficient instanceof Expression.Polynomial && divisorLeadingCoefficient.polynomial.getDegree() !== 0) {
            throw new RangeError();
        }
        var tmp = this.divideAndRemainder(divisor, "throw", function(c) {
            return c.modulo(p);
        });
        return {
            quotient: tmp.quotient,
            remainder: tmp.remainder.mod(p)
        };
    };
    Polynomial.pseudoRemainder = function(A, B) {
        var d = A.getDegree() - B.getDegree();
        // assertion
        if (d < 0) {
            throw new RangeError();
        }
        return A.scale(B.getLeadingCoefficient()._pow(d + 1)).divideAndRemainder(B, "throw").remainder;
    };
    Polynomial.polynomialGCD = function(a, b) {
        var g = Math.gcd(a.getGCDOfTermDegrees(), b.getGCDOfTermDegrees());
        if (g > 1) {
            return Polynomial.polynomialGCD(a._exponentiateRoots(g), b._exponentiateRoots(g))._exponentiateRoots(1 / g);
        }
        //!optimization 2021-03-15
        if (b.getDegree() > 0 && a.getDegree() > 0) {
            var ctz = function(p) {
                var i = 0;
                while (p.getCoefficient(i).equals(Expression.ZERO)) {
                    i += 1;
                }
                return i;
            };
            var i = ctz(b);
            var j = ctz(a);
            if (i !== 0 || j !== 0) {
                //TODO: optimize (?)
                return Polynomial.polynomialGCD(a.divideAndRemainder(Polynomial.of(Expression.ONE).shift(j), undefined).quotient, b.divideAndRemainder(Polynomial.of(Expression.ONE).shift(i), undefined).quotient).shift(Math.min(i, j));
            }
        }
        //!
        //TODO: fix (place condition for degrees earlier - ?)
        if (a.getDegree() < b.getDegree()) {
            //!!!
            var tmp = a;
            a = b;
            b = tmp;
        }
        if (b.equals(Polynomial.ZERO)) {
            return a;
        }

        //!
        if (a.getDegree() === 1 && b.getDegree() === 0) {
            return Polynomial.of(b.getCoefficient(0).gcd(a.getCoefficient(0)).gcd(a.getCoefficient(1))); //?
        }
        //!

        var contentA = a.getContent();
        var contentB = b.getContent();
        var ppA = a.divideAndRemainder(Polynomial.of(contentA), "throw").quotient;
        var ppB = b.divideAndRemainder(Polynomial.of(contentB), "throw").quotient;
        var ppGCD = gcdOfPrimitivePolynomials(ppA, ppB);
        var contentGCD = contentA.gcd(contentB);
        return Polynomial.of(contentGCD).multiply(ppGCD);
    };

    function hasQuadraticInteger(c) {
        if (c instanceof Expression.NthRoot) {
            return !(c instanceof Expression.Integer);
        }
        if (c instanceof Expression.ExponentiationOfMinusOne) {
            return true; //TODO: RENAME or remove, add a test, other classes
        }

        if (c instanceof Expression.BinaryOperation) {
            return hasQuadraticInteger(c.a) || hasQuadraticInteger(c.b);
        }
        //if (c instanceof Expression.ExpressionWithPolynomialRoot) {//TODO: rename function or remove (?)
        //  return true;
        //}
        if (c instanceof Expression.Integer || c instanceof Expression.Symbol || c instanceof Expression.Complex) {
            return false;
        }
        //console.debug(c);//?
        return false;
    }

    /*

        if (!a._hasIntegerLikeCoefficients() || !b._hasIntegerLikeCoefficients()) {
          var g = gcdOfPrimitivePolynomials(a, b);
          g = g.scale(g.getLeadingCoefficient().inverse()).primitivePart();
          return g;//TODO: rename, change, ..., check - ?
        }

        if (B.getDegree() > 0) {
          var g1 = gcdUsingPseudoRemainderSequence(A, B, "subresultant");//?
          return g1.scale(g1.getLeadingCoefficient().inverse()).primitivePart();//?
        }

    */

    //TODO: ? 
    var getY = function(p, other) {
        var visited = {};
        for (var i = 0; i < p.a.size; i++) {
            var c = p.a.coefficient(i);
            var v = Expression.getVariable(c, {
                avoidNthRoots: true
            });
            if (v != null) {
                if (v instanceof Expression.ExpressionWithPolynomialRoot) {
                    //debugger;
                    return null; //!?
                }

                if (Expression.isConstant(v) && v !== Expression.E && v !== Expression.PI) {
                    //?
                    //debugger;
                    return null;
                }
                if (v instanceof Expression.Polynomial) {
                    return null; //!?
                }
                //if (v instanceof Expression.Addition) { //TODO: replacement - ?
                //  v = null;
                //}
                if (v instanceof Expression.Symbol) {
                    if (visited[v.symbol]) {
                        v = null;
                    } else {
                        visited[v.symbol] = true;
                    }
                }
                for (var j = 0; j < p.a.size && v != null; j += 1) {
                    if (!Expression._getReplacement(p.a.coefficient(j), v).equals(v)) {
                        v = null;
                    }
                }
                for (var j = 0; j < other.a.size && v != null; j += 1) {
                    if (!Expression._getReplacement(other.a.coefficient(j), v).equals(v)) {
                        v = null;
                    }
                }
                if (v != null) {
                    return v;
                }
            }
        }
        return null;
    };
    Polynomial._getY = getY;

    function gcdOfPrimitivePolynomials(A, B) {
        console.assert(A.getDegree() >= B.getDegree());
        //if (B.getDegree() === 1) {
        //  return A.divideAndRemainder(B).remainder.equals(Polynomial.ZERO) ? B : Polynomial.of(Expression.ONE);
        //}
        //TODO: for rings - ?
        if (A.hasIntegerCoefficients() && B.hasIntegerCoefficients() && B.getDegree() > 2) {
            if (A.isDivisibleBy(B)) {
                return B;
            }
            return gcdByModularAlgorithm(A, B);
        }
        //TODO: 
        //if (A._hasIntegerLikeCoefficients() && B._hasIntegerLikeCoefficients() && B.getDegree() > 2) {
        if (B.getDegree() > 1) {
            if (getY(A, B) != null || getY(B, A) != null) {
                return gcdByMultivariateModularAlgorithm(A, B);
            }
        }
        //}
        if (B.getDegree() > 2) {
            //TODO: why isn't it working or slow for other cases - ?
            return gcdUsingPseudoRemainderSequence(A, B, "subresultant").primitivePart();
        }
        //TODO:
        //if (isUniqueFactorizationDomain()) {
        if (!A._testCoefficients(function(c) {
                return hasQuadraticInteger(c);
            }) && !B._testCoefficients(function(c) {
                return hasQuadraticInteger(c);
            }) && B.getDegree() > 0) {
            //TODO: REMOVE
            return gcdUsingPseudoRemainderSequence(A, B, "primitive");
        }
        //}
        if (B.getDegree() === 0) {
            return Polynomial.of(Expression.ONE);
        }
        return gcdUsingRemainderSequence(A, B).primitivePart();
    }

    function gcdUsingRemainderSequence(A, B) {
        while (!B.equals(Polynomial.ZERO)) {
            var R = A.divideAndRemainder(B).remainder;
            A = B;
            B = R;
        }
        return A;
    }

    function gcdUsingPseudoRemainderSequence(A, B, type) {
        var g = Math.gcd(A.getGCDOfTermDegrees(), B.getGCDOfTermDegrees());
        if (g > 1) {
            console.error('g > 1');
            return gcdUsingPseudoRemainderSequence(A._exponentiateRoots(g), B._exponentiateRoots(g), type)._exponentiateRoots(1 / g);
        }
        for (var iteratortmp = Polynomial._pseudoRemainderSequence(A, B, type)[globalThis.Symbol.iterator](), tmp = iteratortmp.next().value; tmp != null; tmp = iteratortmp.next().value) {
            var newR = tmp.R;
            A = B;
            B = newR;
        }
        var lastNonzeroRemainder = A;
        return lastNonzeroRemainder;
    }
    Polynomial._gcdUsingPseudoRemainderSequence = gcdUsingPseudoRemainderSequence;

    function ChineseRemainderTheorem(m1, m2) {
        // https://en.wikipedia.org/wiki/Chinese_remainder_theorem#Case_of_two_moduli
        // x = r1 (mod m1)
        // x = r2 (mod m2)
        var c = m1.remainder(m2).modInverse(m2);
        return function(r1, r2) {
            return r1.add(r2.subtract(r1.modulo(m2)).multiply(c).modulo(m2).multiply(m1));
        };
    }
    globalThis.ChineseRemainderTheorem = ChineseRemainderTheorem; //TODO: REMOVE

    /*
     var i = Expression.Integer.fromNumber;
     console.assert(ChineseRemainderTheorem(i(36), i(1), i(119), i(23)).equals(i(2416)));
    */

    function ChineseRemainderTheoremForPolynomialCoefficients(p1, p2, m1, m2) {
        var solution = ChineseRemainderTheorem(m1, m2);
        return _join(p1, p2, function(r1, r2) {
            return solution(r1, r2);
        });
    }
    globalThis.ChineseRemainderTheoremForPolynomialCoefficients = ChineseRemainderTheoremForPolynomialCoefficients;
    Polynomial.prototype._exponentiateRoots = function(n) {
        // α = α**n
        if (n === -1) {
            if (this.getCoefficient(0).equals(Expression.ZERO)) {
                throw new RangeError();
            }
            var newData = new PolynomialData(this.a.size);
            for (var j = this.a.size - 1; j >= 0; j -= 1) {
                newData.add(this.getDegree() - this.a.degree(j), this.a.coefficient(j));
            }
            var p = new Polynomial(newData);
            if (p.getLeadingCoefficient() instanceof Expression.Integer && p.getLeadingCoefficient().sign() < 0) {
                //TODO: ?
                p = p.negate(); //!!!
            }

            return p;
        }
        var inv = Math.floor(1 / n + 0.5);
        if (Math.floor(n) === n && n >= 2 || 1 / inv === n && inv >= 2) {
            var newData = new PolynomialData(this.a.size);
            for (var i = 0; i < this.a.size; i += 1) {
                if (Math.floor(n) === n && this.a.degree(i) % n !== 0) {
                    throw new RangeError(); //?
                }

                newData.add(Math.floor(n) === n ? this.a.degree(i) / n : this.a.degree(i) * inv, this.a.coefficient(i));
            }
            return new Polynomial(newData);
        }
        throw new RangeError(n);
    };
    Polynomial.prototype._scaleRoots = function(s) {
        var sn = s.getNumerator();
        var sd = s.getDenominator();
        var d = this.getDegree();
        var lastScale = Expression.ONE;
        var lastScaleDegree = 0;
        var newData = new PolynomialData(this.a.size);
        for (var i = 0; i < this.a.size; i += 1) {
            var degree = this.a.degree(i);
            var coefficient = this.a.coefficient(i);
            lastScale = lastScale.multiply(sn._pow(d - degree - lastScaleDegree));
            lastScaleDegree = d - degree;
            newData.add(degree, lastScale.multiply(sd._pow(degree)).multiply(coefficient));
        }
        return new Polynomial(newData);
    };
    Polynomial.prototype._translateRoots = function(h) {
        // α = α + h
        if (h.equals(Expression.ONE.negate())) {
            //return this.map(function (c) { return Polynomial.of(c); }).calcAt(Polynomial.of(Expression.ONE, Expression.ONE));
            // The Art of Computer Science by Donald Knuth, Volume 2, page 489:
            var u = this;
            var n = u.getDegree();
            var v = new Array(n + 1);
            for (var j = 0; j <= n; j += 1) {
                v[j] = u.getCoefficient(j);
            }
            for (var k = 0; k <= n - 1; k += 1) {
                for (var j = n - 1; j >= k; j -= 1) {
                    v[j] = v[j].add(v[j + 1]);
                }
            }
            return Polynomial.from(v);
        }
        if (h.equals(Expression.ZERO)) {
            return this;
        }
        var v = h.getNumerator()._pow(this.getDegree());
        return this._scaleRoots(h.negate().inverse())._translateRoots(Expression.ONE.negate())._scaleRoots(h.negate()).map(function(c) {
            return c.divide(v);
        });
    };
    Polynomial.prototype.mod = function(m) {
        return this.map(function(c) {
            return c.modulo(m);
        });
    };
    Polynomial.prototype.mod2 = function(m) {
        //return this.map(function (c) { return c.roundMod(m); });
        return this.mod(m).map(function(c) {
            return c.subtract(m).add(c).compareTo(Expression.ZERO) < 0 ? c : c.subtract(m);
        });
    };

    //TODO: ???
    Polynomial.prototype._pow = function(count) {
        var pow = function(x, count, accumulator) {
            if (count < 0) {
                throw new RangeError();
            }
            if (count > Number.MAX_SAFE_INTEGER) {
                throw new RangeError("NotSupportedError");
            }
            return count < 1 ? accumulator : 2 * Math.floor(count / 2) !== count ? pow(x, count - 1, accumulator.multiply(x)) : pow(x.multiply(x), Math.floor(count / 2), accumulator);
        };
        //throw new Error();//TODO: ?
        return pow(this, count, Polynomial.of(Expression.ONE));
    };

    function gcdByModularAlgorithm(a, b) {
        if (true) {
            var g = Math.gcd(a.getGCDOfTermDegrees(), b.getGCDOfTermDegrees());
            if (g > 1) {
                console.debug('g > 1');
                return gcdByModularAlgorithm(a._exponentiateRoots(g), b._exponentiateRoots(g))._exponentiateRoots(1 / g);
            }
        }
        //! https://www3.risc.jku.at/education/courses/ws2011/ca/3-gcd.pdf
        var d = a.getLeadingCoefficient().abs().gcd(b.getLeadingCoefficient().abs());
        if (a.getCoefficient(0).equals(Expression.ZERO) || b.getCoefficient(0).equals(Expression.ZERO)) {
            throw new RangeError();
        }
        if (d.compareTo(a.getCoefficient(0).abs().gcd(b.getCoefficient(0).abs())) > 0) {
            //?
            return gcdByModularAlgorithm(a._exponentiateRoots(-1), b._exponentiateRoots(-1))._exponentiateRoots(-1);
        }
        console.assert(a.hasIntegerCoefficients() && a.getContent().abs().equals(Expression.ONE) && a.getDegree() > 0);
        console.assert(b.hasIntegerCoefficients() && b.getContent().abs().equals(Expression.ONE) && b.getDegree() > 0);
        var maxGCDDegree = Math.min(a.getDegree(), b.getDegree());
        var bound = function() {
            var maxGCDLeadingCoefficient = d;
            //TODO: not necessary to use power of two
            var logarithmOfCoefficientBound = Math.min(a._log2OfBoundForCoefficientsOfFactor(maxGCDDegree, maxGCDLeadingCoefficient), b._log2OfBoundForCoefficientsOfFactor(maxGCDDegree, maxGCDLeadingCoefficient));
            //TODO: multiply by gcd of leading coefficients (?)
            return Expression.TWO._pow(1 + Math.ceil(logarithmOfCoefficientBound));
        };
        var M = bound();
        //if (M === 1 / 0) {
        //  return gcdUsingPrimitivePseudoRemainderSequence(a, b);//TODO: !!!
        //}
        var p = Expression.Integer.fromBigInt(Math.min(Math.max(M.toNumber(), 1024), Math.floor(Math.sqrt((Number.MAX_SAFE_INTEGER + 1) / (1 + Math.min(a.getDegree(), b.getDegree())))))); // TODO: should we divide on n - ?
        //var p = Expression.Integer.fromNumber(3);//TODO: remove
        var counter = 0;
        while (true) {
            var g = null;
            var P = Expression.ZERO;
            while (P.compareTo(M) < 0) {
                counter += 1;
                if (counter > 50 && p._pow(counter - 50).compareTo(M) >= 0) {
                    throw new TypeError("!!!");
                }
                do {
                    p = p.subtract(Expression.ONE);
                } while (!isPrime(p.toBigInt()) || d.remainder(p).equals(Expression.ZERO));
                var cp = factorizeOverTheIntegers._gcdOfPolynomialsOverFiniteField0(a, b, p.toBigInt());
                console.assert(cp.getLeadingCoefficient().equals(Expression.ONE));
                var gp = cp.scale(d.remainder(p)).mod(p); //TODO: should it do .mod(p) ? as the book does not tell this
                if (gp.getDegree() < 1) {
                    return Polynomial.of(Expression.ONE);
                }
                if (gp.getDegree() > 2 / 3 * a.getDegree()) { // see Donald Knuth's book
                    //TODO: ?
                    //return gcdOfPrimitivePolynomials(a, b);
                }
                if (gp.getDegree() > maxGCDDegree) {
                    continue;
                }
                if (g != null && gp.getDegree() < g.getDegree()) {
                    g = null; // g was wrong
                }

                if (g == null) {
                    g = gp.mod2(p);
                    P = p;
                    maxGCDDegree = gp.getDegree();
                    M = bound();
                } else if (gp.getDegree() === g.getDegree()) {
                    //TODO: why ?
                    var oldG = g;
                    g = ChineseRemainderTheoremForPolynomialCoefficients(g, gp, P, p);
                    P = P.multiply(p);
                    g = g.mod2(P);
                    //does not work (?), the number of iteration is small anyway (?)
                    if (P.compareTo(M) < 0 && oldG.equals(g)) {
                        // optimization from the book:
                        // "Whenever g remains unchanged for a series of iterations through the while–loop, we might apply the test in step (5) and exit if the outcome is positive."
                        g = g.primitivePart();
                        // TODO: scale a and b instead (?) for the test
                        if (a.isDivisibleBy(g) && b.isDivisibleBy(g)) {
                            return g;
                        }
                        g = oldG; //TODO: ???
                    } else {
                        //debugger;
                    }
                }
                //console.debug(counter, g.primitivePart().toString(), P.toString());
            }

            g = g.primitivePart();
            // TODO: scale a and b instead (?) for the test
            if (a.isDivisibleBy(g) && b.isDivisibleBy(g)) {
                return g;
            }
        }
    }
    Polynomial._gcdByModularAlgorithm = gcdByModularAlgorithm;

    function gcdByMultivariateModularAlgorithm(a, b) {
        if (true) {
            var g = Math.gcd(a.getGCDOfTermDegrees(), b.getGCDOfTermDegrees());
            if (g > 1) {
                console.debug('g > 1');
                return gcdByMultivariateModularAlgorithm(a._exponentiateRoots(g), b._exponentiateRoots(g))._exponentiateRoots(1 / g);
            }
        }
        if (!a.getContent().equals(Expression.ONE) || !b.getContent().equals(Expression.ONE)) {
            return Polynomial.polynomialGCD(a, b);
        }
        var y = getY(a, b) || getY(b, a);
        if (y == null) {
            return Polynomial.polynomialGCD(a, b);
        }
        //! https://www3.risc.jku.at/education/courses/ws2011/ca/3-gcd.pdf
        //if (a._hasIntegerLikeCoefficients() && b._hasIntegerLikeCoefficients()) {
        //  throw new RangeError();
        //}

        var M = Math.min(a.getDegree(), b.getDegree()); //TODO: +1 like in the book - ?
        //TODO: ?
        a = a.map(function(c) {
            return new Expression.Polynomial(Polynomial.toPolynomial(c, y));
        });
        b = b.map(function(c) {
            return new Expression.Polynomial(Polynomial.toPolynomial(c, y));
        });
        var toPolynomialByAnotherVar = function(p) {
            // x - top level var, y - second level var,
            // convert coefficients of coefficients to polynomials from x: c*x^0
            // make a polynomial (1*x^1+0*x^0)*y^0 and calculate the polynomial for it
            var topLevelVar = new Expression.Polynomial(Polynomial.of(new Expression.Polynomial(Polynomial.of(Expression.ZERO, Expression.ONE))));
            return p.map(function(c) {
                return new Expression.Polynomial(c.polynomial.map(function(c) {
                    return new Expression.Polynomial(Polynomial.of(c));
                }));
            }).calcAt(topLevelVar).polynomial;
        };
        var aByY = toPolynomialByAnotherVar(a);
        var bByY = toPolynomialByAnotherVar(b);
        var cgcd = aByY.getContent().gcd(bByY.getContent()).polynomial.primitivePart();
        if (!cgcd.equals(Polynomial.of(Expression.ONE))) {
            var divide = function(p) {
                return p.map(function(c) {
                    return new Expression.Polynomial(c.polynomial.divideAndRemainder(cgcd, cgcd._hasIntegerLikeCoefficients() ? "throw" : undefined).quotient);
                }).calcAt(new Expression.Polynomial(Polynomial.of(y))).polynomial;
            };
            return gcdByMultivariateModularAlgorithm(divide(aByY), divide(bByY)).multiply(cgcd);
        }
        console.assert(cgcd.equals(Polynomial.of(Expression.ONE)));
        if (aByY.getDegree() === 0 || bByY.getDegree() === 0) {
            return Polynomial.of(Expression.ONE);
        }

        //var M2 = Math.min(aByY.getDegree(), bByY.getDegree());
        //if (M > M2) {
        //return toPolynomialByAnotherVar(gcdByMultivariateModularAlgorithm(aByY, bByY));
        //}

        var d = Polynomial.polynomialGCD(aByY.getLeadingCoefficient().polynomial, bByY.getLeadingCoefficient().polynomial);
        var interpolation = function() {
            NewtonInterpolation.setField(Expression._FIELD);
            var polynomialInterpolation = NewtonInterpolation();
            polynomialInterpolation.next();
            return polynomialInterpolation;
        };
        var integerLikeCoefficientsPolynomials = a._hasIntegerLikeCoefficients() && b._hasIntegerLikeCoefficients();
        var r = Expression.ZERO;
        var m = 0;
        var g = null;
        var gDegreeByY = 1 / 0;
        var polynomialInterpolation = null;
        while (true) {
            do {
                r = Expression.Integer.fromNumber(r.toNumber() + 1);
                if (r.toNumber() - M > 2) {
                    console.error("!", r.toNumber() - M);
                }
            } while (d.calcAt(r).equals(Expression.ZERO));
            var g_r = Polynomial.polynomialGCD(a.calcAt(r).polynomial, b.calcAt(r).polynomial);
            if (g_r.getDegree() === 0) {
                return Polynomial.of(Expression.ONE); // as content by y is 1 (?)
            }

            if (g_r.getDegree() > gDegreeByY) {
                continue;
            }
            var d_xequalr = d.calcAt(r);
            g_r = g_r.scale(d_xequalr).scale(g_r.getLeadingCoefficient().inverse());
            if (integerLikeCoefficientsPolynomials && !g_r._hasIntegerLikeCoefficients()) {
                continue;
            }
            if (m === M + 1 || g_r.getDegree() < gDegreeByY) {
                //?
                m = 0;
                polynomialInterpolation = interpolation();
            }
            var oldG = g;
            g = Polynomial.from(polynomialInterpolation.next([r.toNumber(), new Expression.Polynomial(g_r)]).value);
            m += 1;
            gDegreeByY = g_r.getDegree();
            //console.log(y.symbol, g.toString(), r, g_r.calcAt(y).toString());
            //if (g_r.getDegree() > Math.min(aByY.getDegree(), bByY.getDegree()) - 2) {//?
            //return Polynomial.polynomialGCD(originalA, originalB);
            //}
            if (integerLikeCoefficientsPolynomials) {
                if (g != null && !g._hasIntegerLikeCoefficients()) {
                    debugger;
                }
            }
            if (oldG != null && oldG.equals(g) || m === M + 1) {
                if (!integerLikeCoefficientsPolynomials || g._hasIntegerLikeCoefficients()) {
                    //TODO: multiply by d instead:
                    g = toPolynomialByAnotherVar(toPolynomialByAnotherVar(g).primitivePart());
                    if (!integerLikeCoefficientsPolynomials || g.getContent().equals(Expression.ONE)) {
                        // Polynomial#isDivisibleBy is not checking for integer division (?)
                        if (a.isDivisibleBy(g) && b.isDivisibleBy(g)) {
                            g = g.map(function(c) {
                                return c.polynomial.calcAt(y);
                            });
                            if (g.getLeadingCoefficient().isNegative()) {
                                g = g.negate();
                            }
                            if (!integerLikeCoefficientsPolynomials) {
                                g = g.primitivePart();
                            }
                            return g;
                        }
                    }
                    g = oldG;
                } else {
                    debugger;
                }
            }
        }
    };
    Polynomial._gcdByMultivariateModularAlgorithm = gcdByMultivariateModularAlgorithm;
    Polynomial.prototype.calcAt = function(point) {
        //!!!
        if (point instanceof Expression.Division && point.getNumerator() instanceof Expression.Integer && point.getDenominator() instanceof Expression.Integer && this.hasIntegerCoefficients()) {
            var n = this.getDegree();
            var p = this._scaleRoots(point.getDenominator());
            return p.calcAt(point.getNumerator()).divide(point.getDenominator()._pow(n));
        }
        if ((point instanceof Expression.Symbol || point instanceof Expression.NthRoot) && this.hasIntegerCoefficients()) {
            var s = Expression.ZERO;
            for (var i = 0; i < this.a.size; i += 1) {
                var degree = this.a.degree(i);
                var coefficient = this.a.coefficient(i);
                s = s.add(coefficient.multiply(point._pow(degree)));
            }
            return s;
        }
        var n = Expression.ZERO;
        var lastDegree = -1;
        for (var i = 0; i < this.a.size; i += 1) {
            var degree = this.a.degree(i);
            var coefficient = this.a.coefficient(i);
            if (!n.equals(Expression.ZERO)) {
                n = Expression.pow(point, lastDegree - degree).multiply(n).add(coefficient);
            } else {
                n = coefficient;
            }
            lastDegree = degree;
        }
        if (!n.equals(Expression.ZERO)) {
            n = Expression.pow(point, lastDegree - 0).multiply(n);
        }
        return n;
    };
    Polynomial.prototype.getContent = function() {
        if (this.a.size === 0) {
            return Expression.ONE;
        }
        var denominator = Expression.ONE;
        var numerator = Expression.ZERO;
        for (var i = 0; i < this.a.size; i += 1) {
            var k = i % 2 === 0 ? i / 2 : this.a.size - (i + 1) / 2;
            var y = this.a.coefficient(k);
            denominator = denominator.lcm(y.getDenominator());
            numerator = numerator.gcd(y.getNumerator());
        }
        var c = numerator.divide(denominator);
        var x = this.a.coefficient(0);
        return x.isNegative() && !numerator.isNegative() || numerator.isNegative() && !x.isNegative() ? c.negate() : c;
    };

    // add, multiply, divideAndRemainder

    Polynomial.prototype.negate = function() {
        //TODO: fix
        return this.map(function(coefficient) {
            return coefficient.negate();
        });
    };
    Polynomial.prototype.subtract = function(l) {
        return this.add(l.negate());
    };
    Polynomial.prototype.scale = function(x) {
        if (x.equals(Expression.ONE)) {
            return this;
        }
        if (Expression.has(x, Expression.Matrix) || Expression.has(x, Expression.MatrixSymbol)) {
            throw new TypeError();
        }
        return this.map(function(coefficient) {
            return coefficient.multiply(x);
        });
    };
    Polynomial.fromTerms = function(terms) {
        var newData = new PolynomialData(terms.length);
        for (var i = 0; i < terms.length; i += 1) {
            var term = terms[i];
            newData.add(term.degree, term.coefficient);
        }
        return new Polynomial(newData);
    };
    Polynomial.toPolynomial = function(e, v) {
        if (e instanceof Expression.Division) {
            throw new RangeError();
        }
        var terms = Expression.getCoefficients(e, v);
        return Polynomial.fromTerms(terms);
    };
    Polynomial.prototype.toExpression = function(variableSymbol) {
        var result = undefined;
        for (var i = 0; i < this.a.size; i += 1) {
            var degree = this.a.degree(i);
            var coefficient = this.a.coefficient(i);
            var v = degree === 0 ? undefined : degree === 1 ? variableSymbol : new Expression.Exponentiation(variableSymbol, Expression.Integer.fromNumber(degree));
            var current = v == undefined ? coefficient : coefficient.equals(Expression.ONE) ? v : new Expression.Multiplication(coefficient, v);
            result = result == undefined ? current : new Expression.Addition(result, current);
        }
        return result == undefined ? Expression.ZERO : result;
    };

    // return a first founded root to simplify and as the next call may be called with reduced coefficients
    Polynomial.prototype.doRationalRootTest = function() {
        var np = this;
        if (np.getCoefficient(0).equals(Expression.ZERO)) {
            return Expression.ZERO; //!TODO: test
        }

        var an = np.getLeadingCoefficient();
        var a0 = np.getCoefficient(0);
        a0 = Expression._expandTrigonometry(a0); //!
        if (np.getDegree() === 1) {
            return a0.negate().divide(an);
        }

        //TODO: http://en.wikipedia.org/wiki/Polynomial_remainder_theorem

        // http://scask.ru/g_book_mav.php?id=26
        var hasIntegerCoefficients = np.hasIntegerCoefficients();
        // f(k) = q(k)(k - a)
        var fp1 = null;
        var fm1 = null;
        if (hasIntegerCoefficients) {
            fp1 = np.calcAt(Expression.ONE);
            if (fp1.equals(Expression.ZERO)) {
                return Expression.ONE;
            }
            fm1 = np.calcAt(Expression.ONE.negate());
            if (fm1.equals(Expression.ZERO)) {
                return Expression.ONE.negate();
            }
        }
        var filter = function(n, d) {
            if (fp1 != null) {
                if (d.subtract(n).equals(Expression.ZERO)) {
                    return false;
                }
                if (!fp1.remainder(d.subtract(n)).equals(Expression.ZERO)) {
                    return false;
                }
            }
            if (fm1 != null) {
                if (d.add(n).equals(Expression.ZERO)) {
                    return false;
                }
                if (!fm1.remainder(d.add(n)).equals(Expression.ZERO)) {
                    return false;
                }
            }
            return true;
        };

        //!new 2020-01-13
        if (hasIntegerCoefficients) {
            //var tmp = np.squareFreeFactors();
            //if (tmp.a0.getDegree() > 0) {
            //  return tmp.a0.doRationalRootTest() || tmp.a1.doRationalRootTest();
            //}
            var roundDivision = function(a, b) {
                if (b.compareTo(Expression.ZERO) < 0) {
                    b = b.negate();
                    a = a.negate();
                }
                var e = b.truncatingDivide(Expression.TWO);
                if (a.compareTo(Expression.ONE) < 0) {
                    e = e.negate();
                }
                return a.add(e).truncatingDivide(b);
            };
            var toInteger = function(zero, scale) {
                //TODO: ?
                var interval = zero instanceof Expression.ExpressionPolynomialRoot ? zero.root._root.toDecimal(scale.abs().bitLength()) : zero.toDecimal(scale.abs().bitLength());
                var fraction = interval.a.add(interval.b).divide(Expression.TWO);
                return roundDivision(scale.multiply(fraction.getNumerator()), fraction.getDenominator());
            };
            var zeros = np.getZeros();
            for (var i = 0; i < zeros.length; i += 1) {
                var zero = zeros[i];
                if (i === 0 || zero !== zeros[i - 1]) {
                    var candidate = zero.root != null ? toInteger(zero, an).divide(an) : zero.getNumerator() instanceof Expression.Integer && zero.getDenominator() instanceof Expression.Integer ? zero : Expression.ZERO;
                    if (filter(candidate.getNumerator(), candidate.getDenominator()) && np.calcAt(candidate).equals(Expression.ZERO)) {
                        return candidate;
                    }
                }
            }
            return null;
        }

        /*
        TODO:
        k = k
        f(k) = fk
        t = x + k
        x = t - k
        f(t) = f(x + k) = an * x**n + ... + f(k)
        */

        var result = null;
        // p/q
        //TODO: forEach -> some ?
        Expression.everyDivisor(a0, function(p) {
            return Expression.everyDivisor(an, function(q) {
                var sign = -3;
                while ((sign += 2) < 3) {
                    var sp = sign === -1 ? p.negate() : p;
                    if (
                        //sp.gcd(q).equals(Expression.ONE) &&
                        filter(sp, q)) {
                        //?
                        var x = Polynomial.of(sp.negate(), q);
                        var z = np.divideAndRemainder(x, "undefined");
                        var r = z == undefined ? undefined : z.remainder.map(function(x) {
                            return x.simplifyExpression();
                        });
                        if (r != undefined && r.equals(Polynomial.ZERO)) {
                            result = sp.divide(q);
                            return false;
                        }
                    }
                }
                return true;
            });
        });
        return result;
    };
    Polynomial.prototype._testCoefficients = function(f) {
        for (var i = 0; i < this.a.size; i += 1) {
            if (!f(this.a.coefficient(i))) {
                return false;
            }
        }
        return true;
    };
    Polynomial.prototype.hasIntegerCoefficients = function() {
        return this._testCoefficients(function(c) {
            return c instanceof Expression.Integer;
        });
    };
    Polynomial.prototype.hasComplexCoefficients = function() {
        return this._testCoefficients(function(c) {
            return c instanceof Expression.Complex || c instanceof Expression.Integer;
        });
    };
    var isIntegerLike = function(c) {
        if (c instanceof Expression.Integer) {
            return true;
        }
        if (c instanceof Expression.Symbol) {
            if (c instanceof Expression.ExpressionWithPolynomialRoot) {
                //TODO: ?
                return false;
            }
            if (c instanceof Expression.ExpressionPolynomialRoot) {
                //TODO: ?
                return false;
            }
            if (c instanceof Expression.PolynomialRootSymbol) {
                //TODO: remove
                return true;
            }
            return true;
        }
        if (c instanceof Expression.Addition) {
            return isIntegerLike(c.a) && isIntegerLike(c.b);
        }
        if (c instanceof Expression.Multiplication) {
            return isIntegerLike(c.a) && isIntegerLike(c.b);
        }
        if (c instanceof Expression.Exponentiation) {
            return isIntegerLike(c.a) && c.b instanceof Expression.Integer && c.b.compareTo(Expression.TWO) >= 0;
        }
        if (c instanceof Expression.Polynomial) {
            return c.polynomial._hasIntegerLikeCoefficients();
        }
        return false;
    };
    //Expression._isIntegerLike = isIntegerLike;
    Polynomial._isIntegerLike = isIntegerLike;
    Polynomial.prototype._hasIntegerLikeCoefficients = function() {
        return this._testCoefficients(function(c) {
            return Polynomial._isIntegerLike(c);
        });
    };
    Polynomial.prototype._canBeFactored = function(depth) {
        // https://en.wikipedia.org/wiki/Eisenstein%27s_criterion
        if (!this.hasIntegerCoefficients()) {
            //throw new Error();
            return true;
        }
        if (this.getCoefficient(0).equals(Expression.ZERO)) {
            return true;
        }
        var content = this.getContent();
        if (!content.equals(Expression.ONE) && !content.equals(Expression.ONE.negate())) {
            return this.scale(content.inverse())._canBeFactored();
        }
        // p divides each a_i for 0 ≤ i < n
        var g = this.subtract(Polynomial.of(this.getLeadingCoefficient()).shift(this.getDegree())).getContent();
        // p does not divide a_n
        var x = null;
        do {
            x = g.gcd(this.getLeadingCoefficient());
            g = g.truncatingDivide(x);
        } while (!x.equals(Expression.ONE));
        var x = null;
        g = g.abs(); //?
        while (!g.equals(Expression.ONE)) {
            var p = g.primeFactor();
            // p**2 does not divide a_0
            if (!this.getCoefficient(0).remainder(p._pow(2)).equals(Expression.ZERO)) {
                return false;
            }
            g = g.truncatingDivide(p);
        }
        if (depth == undefined) {
            // see https://en.wikipedia.org/wiki/Eisenstein%27s_criterion#Indirect_(after_transformation)
            //TODO: ?
            if (!this._translateRoots(Expression.Integer.fromNumber(3).negate())._canBeFactored(1)) {
                return false;
            }
            //TODO: (too slow)
            //if (!this._exponentiateRoots(-1)._canBeFactored(1)) {
            //  return false;
            //}
        }

        return true;
    };
    Polynomial.prototype.isEven = function() {
        return this.getGCDOfTermDegrees() % 2 === 0;
    };
    var counter = 0; //TODO: remove

    Polynomial.prototype.getGCDOfTermDegrees = function() {
        if (this.equals(Polynomial.ZERO)) {
            return 0;
        }
        var g = this.getDegree();
        for (var i = 1; i <= this.getDegree() && g >= 2; i += 1) {
            if (!this.getCoefficient(i).equals(Expression.ZERO)) {
                g = Math.gcd(g, i);
            }
        }
        return g;
    };
    Polynomial.prototype.getroots = function(callback) {
        //TODO: merge hit and callback
        callback = callback || undefined;
        var np = this;
        var roots = [];

        //!new 2018-12-24
        //TODO: fix (?Polynomial#getContent()?)
        var ct = Expression.ONE;
        var t = Expression.ZERO;
        while (t != null) {
            var t = Expression.getConjugate(np.getLeadingCoefficient());
            if (t != undefined) {
                np = np.scale(t);
                ct = ct.multiply(t);
            }
        }
        //!

        //!new 2020-07-11
        np = np.map(function(x) {
            return x.simplifyExpression();
        });
        //!

        var content = np.getContent();
        if (!content.equals(Expression.ONE)) {
            np = np.scale(content.getDenominator()).divideAndRemainder(Polynomial.of(content.getNumerator()), "throw").quotient;
            //np = np.divideAndRemainder(Polynomial.of(content), "throw").quotient;
        }

        if (!ct.equals(Expression.ONE)) {
            content = content.divide(ct);
        }

        // x = 0
        while (np.getCoefficient(0).equals(Expression.ZERO)) {
            np = np.divideAndRemainder(Polynomial.of(Expression.ZERO, Expression.ONE), "throw").quotient;
            roots.push(Expression.ZERO);
        }
        if (!content.equals(Expression.ONE) && !content.equals(Expression.ONE.negate()) || roots.length > 0) {
            if (roots.length > 0) {
                if (typeof hit === "function") {
                    hit({
                        getroots: {
                            special: "0"
                        }
                    });
                }
            }
            if (callback != undefined) {
                callback({
                    content: content,
                    roots: roots,
                    newPolynomial: np,
                    type: "factorOutTheGreatestCommonFactor"
                });
            }
        }
        if (np.getDegree() === 1) {
            roots.push(np.getCoefficient(0).negate().divide(np.getCoefficient(1)));
            np = Polynomial.of(np.getLeadingCoefficient());
            if (typeof hit === "function") {
                hit({
                    getroots: {
                        linear: ""
                    }
                });
            }
            if (callback != undefined) {
                callback({
                    content: content,
                    roots: roots,
                    newPolynomial: np,
                    type: "solveLinearEquation"
                });
            }
            return roots;
        }
        var nthRootInternal = function(n, x) {
            if (x instanceof Expression.ExpressionWithPolynomialRoot) {
                //TODO: !?
                return undefined; //?
                //return x._nthRoot(n);
            }

            if (x instanceof Expression.ExpressionPolynomialRoot) {
                //return undefined;//?
                return x._nthRoot(n);
            }
            if (x instanceof Expression.Division) {
                var sa1 = nthRootInternal(n, x.a);
                var sb1 = nthRootInternal(n, x.b);
                return sa1 == undefined || sb1 == undefined ? undefined : sa1.divide(sb1);
            }
            if (x instanceof Expression.Exponentiation) {
                var N = Expression.Integer.fromNumber(n);
                if (x.b instanceof Expression.Integer) {
                    if (x.b.remainder(N).equals(Expression.ZERO)) {
                        return x.a.pow(x.b.divide(N));
                    }
                    //return undefined;
                }

                if (x.a instanceof Expression.Integer || x.a === Expression.E) {
                    //?
                    return x.a.pow(x.b.divide(N));
                }
                if (x.b instanceof Expression.Division && x.b.a instanceof Expression.Integer && x.b.a.remainder(N).equals(Expression.ZERO)) {
                    //TODO:
                    return x.a.pow(x.b.divide(N));
                }
            }
            if (x instanceof Expression.Multiplication) {
                var sa = nthRootInternal(n, x.a);
                var sb = nthRootInternal(n, x.b);
                return sa == undefined || sb == undefined ? undefined : sa.multiply(sb);
            }
            if (x instanceof Expression.Complex || Expression.isConstant(x) && Expression.has(x, Expression.Complex)) {
                //TODO: - ?
                //var real = x.real;
                //var imaginary = x.imaginary;
                var c = Expression.getComplexNumberParts(x);
                var real = c.real;
                var imaginary = c.imaginary;
                if (n === 2) {
                    var m = real.multiply(real).add(imaginary.multiply(imaginary)).squareRoot();
                    var a = nthRootInternal(2, real.add(m).divide(Expression.TWO));
                    if (a != undefined) {
                        var b = imaginary.divide(Expression.TWO.multiply(a));
                        var result = a.add(b.multiply(Expression.I));
                        return result;
                    }
                }
                if (real.equals(Expression.ZERO) && n % 2 === 0) {
                    var c = nthRootInternal(Math.floor(n / 2), x);
                    if (c != undefined) {
                        return nthRootInternal(2, c);
                    }
                }
                if (real.equals(Expression.ZERO) && n % 2 === 1) {
                    //?
                    var c = nthRootInternal(n, imaginary);
                    if (c != undefined) {
                        return c.multiply(n % 4 === 1 ? Expression.I : Expression.I.negate());
                    }
                }
                //!new 2020-07-24
                if (x instanceof Expression.Complex && !imaginary.equals(Expression.ZERO)) {
                    //?TODO: ?
                    // https://en.wikipedia.org/wiki/Complex_number#Modulus_and_argument
                    var rho = real._pow(2).add(imaginary._pow(2)).squareRoot();
                    try {
                        var phi = Expression.TWO.multiply(imaginary.divide(rho.add(real)).arctan());
                        return rho._nthRoot(n).multiply(Expression.I.multiply(phi.divide(Expression.Integer.fromNumber(n))).exp());
                    } catch (error) {
                        //TODO: ?
                        console.debug(error);
                    }
                }
            }
            if (x instanceof Expression.Addition) {
                var lastFactor = undefined;
                var e = 0;
                var result = Expression.ONE;
                var rest = Expression.ONE;
                var t = x;
                while (!t.equals(Expression.ONE) && !t.equals(Expression.ONE.negate())) {
                    var f = Expression.simpleDivisor(t);
                    if (e === 0) {
                        lastFactor = f;
                        e += 1;
                    } else if (f.equals(lastFactor)) {
                        e += 1;
                        if (e === n) {
                            e = 0;
                            result = result.multiply(lastFactor);
                        }
                    } else if (e !== 0) {
                        rest = rest.multiply(Expression.pow(lastFactor, e));
                        lastFactor = f;
                        e = 1;
                    }
                    t = t.divide(f);
                }
                if (result !== Expression.ONE) {
                    if (e !== 0) {
                        rest = rest.multiply(Expression.pow(lastFactor, e));
                    }
                    if (t.equals(Expression.ONE.negate())) {
                        rest = rest.multiply(t);
                    }
                    var rn = nthRootInternal(n, rest);
                    if (rn != undefined) {
                        return result.multiply(rn);
                    }
                }
            }
            if (x instanceof Expression.Exponentiation && x.a instanceof Expression.Symbol) {
                var b = x.b.divide(Expression.Integer.fromNumber(n));
                return b.equals(Expression.ONE) ? x.a : new Expression.Exponentiation(x.a, b);
            }
            if (!Expression.isConstant(x) && x.isNegative() && (n === 2 || n % 2 !== 0)) {
                x = x.negate();
                var c = nthRootInternal(n, x);
                return c == null ? null : Expression.ONE.negate()._nthRoot(n).multiply(c);
            }
            if ((x instanceof Expression.Integer || x instanceof Expression.Complex) && x.isNegative() && n % 2 === 0) {
                //?
                var c = x instanceof Expression.Integer ? x._nthRoot(2) : nthRootInternal(2, x);
                return c == null ? null : nthRootInternal(n / 2, c);
            }
            if (Expression.has(x, Expression.Sin) || Expression.has(x, Expression.Cos)) {
                //?
                var tmp = nthRootInternal(2, Expression._replaceSinCos(x));
                if (tmp != null) {
                    return Expression._replaceBySinCos(tmp).simplifyExpression(); //?
                }
            }

            var y = undefined;
            try {
                y = x._nthRoot(n);
            } catch (error) {
                //TODO:
                console.error(error);
            }
            if (y == undefined) {
                //?
                var a = x;
                //TODO: different cases (1+sqrt(2)+sqrt(3)) - (?)
                var ac = Expression.getConjugateExpression(a.getNumerator());
                if ((n === 3 || n === 2) && ac instanceof Expression.Integer) {
                    //TODO: ?
                    if (n === 2 && Expression._isPositive(x.negate())) {
                        return Expression.I.multiply(nthRootInternal(2, x.negate()));
                    }
                    //TODO: a > 0 - ?
                    var a = x;
                    var tmp = new Expression.Symbol('x')._pow(n).subtract(a).getNumerator();
                    var polynomial = Polynomial.toPolynomial(Expression.getConjugateExpression(tmp), new Expression.Symbol('x'));
                    var tmp2 = polynomial.getZeros(); //TODO: ?
                    for (var iteratorzero = tmp2[globalThis.Symbol.iterator](), zero = iteratorzero.next().value; zero != null; zero = iteratorzero.next().value) {
                        if (zero._pow(n).equals(x)) {
                            return zero;
                        }
                    }
                    //TODO: fix
                    return null;
                }
            }
            return y;
        };
        var nthRoot = function(n, x, np) {
            if (n === 1) {
                return x;
            }
            var y = nthRootInternal(n, x);
            if (y == undefined) {
                if (!(x instanceof Expression.Integer)) {
                    if (typeof hit === "function") {
                        hit({
                            nthRoot: (n === 2 ? "squareRoot" : n + "-root") + ":" + x.toString() + ":" + np.toString()
                        });
                    }
                }
            }
            return y;
        };
        var continueWithNewPolynomial = function(roots, np, newPolynomialVariable) {
            var rs = np.getroots(callback != undefined ? function(info) {
                var xxx = Object.assign({}, info, {
                    content: content.multiply(info.content),
                    roots: roots.concat(info.roots),
                    newPolynomialVariable: newPolynomialVariable
                });
                callback(xxx);
            } : undefined);
            for (var i = 0; i < rs.length; i += 1) {
                roots.push(rs[i]);
            }
        };
        if (np.getDegree() >= 2) {
            var g = np.getGCDOfTermDegrees();
            if (g >= 2) {
                var allZeros = g === np.getDegree();
                if (typeof hit === "function") {
                    if (g === np.getDegree()) {
                        hit({
                            getroots: {
                                allZeros: ""
                            }
                        });
                    } else {
                        hit({
                            getroots: g % 2 === 0 ? np.getDegree() === 4 ? {
                                biquadratic: ""
                            } : {
                                even: ""
                            } : {
                                xyz: np.toString()
                            }
                        });
                    }
                }
                // t = x^g
                var newData = new Array(Math.floor((np.getDegree() + g) / g));
                var k = 0;
                for (var i = 0; i <= np.getDegree(); i += g) {
                    newData[k] = np.getCoefficient(i);
                    k += 1;
                }
                var q = Polynomial.from(newData);
                var qRoots = [];
                if (!allZeros) {
                    if (callback != undefined) {
                        callback({
                            content: content,
                            roots: roots,
                            newPolynomial: q,
                            type: "t = x^g",
                            g: g,
                            newPolynomialVariable: new Expression.Symbol('t')
                        }); //TODO: ?
                    }

                    continueWithNewPolynomial(qRoots, q, new Expression.Symbol('t'));
                } else {
                    qRoots = q.getroots();
                }
                var n = np.getDegree(); //TODO: 2018-02-04
                //var ok = false;//?
                for (var k = 0; k < qRoots.length; k += 1) {
                    var qRoot = qRoots[k];
                    var s = nthRoot(g, qRoot, np);
                    if (s != undefined) {
                        var d = null;
                        if ((!allZeros || g >= 5 || !np.hasIntegerCoefficients()) && (g <= 24 && (17896830 >> g) % 2 === 1 || g === 48)) {
                            d = Polynomial.of(Expression.ONE).shift(g).add(Polynomial.of(qRoot.negate()));
                            // https://en.wikipedia.org/wiki/Root_of_unity
                            var c = Expression.E.pow(Expression.I.multiply(Expression.TWO.multiply(Expression.PI)).divide(Expression.Integer.fromNumber(g)));
                            var cInI = Expression.ONE;
                            for (var i = 0; i < g; i += 1) {
                                var root = cInI.multiply(s);
                                cInI = cInI.multiply(c);
                                roots.push(root);
                            }
                        } else {
                            roots.push(s);
                            d = Polynomial.of(s.negate(), Expression.ONE);
                            if (g % 2 === 0) {
                                roots.push(s.negate());
                                d = Polynomial.of(s.multiply(s).negate(), Expression.ZERO, Expression.ONE);
                            }
                        }
                        var quotient = np.divideAndRemainder(d).quotient;
                        console.assert(np.subtract(quotient.multiply(d)).map(function(c) {
                            return c.simplifyExpression();
                        }).getDegree() < 0);
                        np = quotient;
                    }
                    //ok = ok || Expression.has(qRoot, Expression.Complex);//?
                }

                if (!allZeros) {
                    if (callback != undefined) {
                        callback({
                            content: content,
                            roots: roots,
                            newPolynomial: np,
                            type: "x = t^(1/g)",
                            g: g
                        }); //TODO: ?
                    }
                } else {
                    var type = g === 2 ? "applyDifferenceOfSquaresRule" : g === 3 ? "applyDifferenceOfCubesRule" : "applyDifferenceOfNthPowersRule";
                    if (callback != undefined) {
                        callback({
                            content: content,
                            roots: roots,
                            newPolynomial: np,
                            type: type,
                            g: g
                        }); //TODO: ?
                    }
                }

                var ok = true;
                if (n !== np.getDegree() && ok && np.getDegree() > 0) {
                    continueWithNewPolynomial(roots, np);
                }
                return roots;
            }
        }

        //! new: solution of quadratic equations
        if (np.getDegree() === 2) {
            var a = np.getCoefficient(2);
            var b = np.getCoefficient(1);
            var c = np.getCoefficient(0);
            var D = b.multiply(b).subtract(Expression.TWO.multiply(Expression.TWO).multiply(a).multiply(c));
            D = D.simplifyExpression();
            var sD = nthRoot(2, D, np);
            if (typeof hit === "function") {
                hit({
                    getroots: {
                        quadratic: sD == undefined ? D instanceof Expression.Integer ? D.compareTo(Expression.ZERO) : "?" + D.toString() : "OK"
                    }
                });
            }
            if (sD != undefined) {
                if (sD.equals(Expression.ZERO)) {
                    var x12 = b.negate().divide(Expression.TWO.multiply(a));
                    roots.push(x12);
                    roots.push(x12);
                    //TODO: different details (?)
                } else {
                    var x1 = b.negate().subtract(sD).divide(Expression.TWO.multiply(a));
                    var x2 = b.negate().add(sD).divide(Expression.TWO.multiply(a));
                    roots.push(x1);
                    roots.push(x2);
                }
                np = Polynomial.of(np.getLeadingCoefficient());
                if (callback != undefined) {
                    callback({
                        content: content,
                        roots: roots,
                        newPolynomial: np,
                        type: "solveQuadraticEquation"
                    });
                }
                return roots;
            }
        }

        //TODO: odd degrees ?
        if (np.getDegree() >= 4 && np.getDegree() % 2 === 0) {
            var middle = Math.floor(np.getDegree() / 2);
            var j = 1;
            while (j < middle + 1 && np.getCoefficient(middle + j).equals(Expression.ZERO) && np.getCoefficient(middle - j).equals(Expression.ZERO)) {
                j += 1;
            }
            if (j < middle + 1 && !np.getCoefficient(middle + j).equals(Expression.ZERO) && !np.getCoefficient(middle - j).equals(Expression.ZERO)) {
                var jj = Expression.Integer.fromNumber(j);
                var mj = np.getCoefficient(middle + j).divide(np.getCoefficient(middle - j));
                var isQuasiPalindromic = true;
                for (var i = 2; i < middle + 1 && isQuasiPalindromic; i += 1) {
                    isQuasiPalindromic = isQuasiPalindromic && np.getCoefficient(middle + i).pow(jj).subtract(np.getCoefficient(middle - i).pow(jj).multiply(mj.pow(Expression.Integer.fromNumber(i)))).equals(Expression.ZERO);
                }
                if (isQuasiPalindromic) {
                    //TODO: fix
                    if (typeof hit === "function") {
                        hit({
                            getroots: {
                                quasiPalindromic: np.getDegree()
                            }
                        });
                    }
                }
                if (isQuasiPalindromic && np.getDegree() <= Math.log2(Number.MAX_SAFE_INTEGER + 1)) {
                    var substitute = function(m, np) {
                        // t = mx + 1 / x
                        // https://stackoverflow.com/a/15302448/839199
                        var choose = function(n, k) {
                            return k === 0 ? 1 : Math.floor(n * choose(n - 1, k - 1) / k);
                        };
                        var p = function(n, i, mpi) {
                            return n - 2 * i >= 0 ? p(n - 2 * i, 1, m).scale(Expression.Integer.fromNumber(choose(n, i)).multiply(mpi).negate()).add(p(n, i + 1, mpi.multiply(m))) : Polynomial.of(Expression.ONE).shift(n);
                        };
                        var f = function(n, i) {
                            return i <= n ? p(n - i, 1, m).scale(np.getCoefficient(i)).add(f(n, i + 1)) : Polynomial.ZERO;
                        };
                        return f(Math.floor(np.getDegree() / 2), 0);
                    };
                    var m = j === 1 ? mj : nthRoot(j, mj, np); // TODO: check the result of nthRoot - ?
                    // t = mx + 1 / x
                    var pt = substitute(m, np);
                    //var pt = Polynomial.of(np.getCoefficient(2).subtract(Expression.ONE.add(Expression.ONE).multiply(m).multiply(np.getCoefficient(0))), np.getCoefficient(1), np.getCoefficient(0));
                    var ptRoots = pt.getroots();
                    for (var i = 0; i < ptRoots.length; i += 1) {
                        var ptRoot = ptRoots[i];
                        // mx^2 - tx + 1 = 0
                        var u = Polynomial.of(Expression.ONE, ptRoot.negate(), m);
                        var uRoots = u.getroots();
                        for (var j = 0; j < uRoots.length; j += 1) {
                            var root = uRoots[j];
                            //np = np.divideAndRemainder(Polynomial.of(root.negate(), Expression.ONE)).quotient;//TODO: optimize
                            roots.push(root);
                        }
                        np = np.divideAndRemainder(u.scale(u.getLeadingCoefficient().inverse())).quotient;
                        //TODO: multiply by "newU"
                    }

                    if (callback != undefined) {
                        callback({
                            content: content,
                            roots: roots,
                            newPolynomial: np,
                            type: "solvePalindromicEquaion"
                        });
                    }
                    return roots;
                }
            }
        }
        if (np.getDegree() >= 2) {
            //?
            // (ax+b)**n = a**n*x**n + n*a**(n-1)*x**(n-1)*b + ...
            //?
            // a**n
            // n*a**(n-1)*b
            var n = np.getDegree();
            var hasZeroCoefficient = function(np) {
                for (var i = 0; i <= np.getDegree(); i += 1) {
                    if (np.getCoefficient(i).equals(Expression.ZERO)) {
                        return true;
                    }
                }
                return false;
            };
            if (!hasZeroCoefficient(np)) {
                var g = np.getCoefficient(n - 1).divide(np.getCoefficient(n)).divide(Expression.Integer.fromNumber(n));
                var ok = true;
                for (var k = np.getDegree() - 1; k >= 1 && ok; k -= 1) {
                    ok = g.equals(np.getCoefficient(k - 1).divide(np.getCoefficient(k)).multiply(Expression.Integer.fromNumber(n - k + 1)).divide(Expression.Integer.fromNumber(k)));
                }
                if (ok) {
                    var root = g.negate();
                    for (var k = 0; k < n; k += 1) {
                        roots.push(root);
                    }
                    np = Polynomial.of(np.getLeadingCoefficient());
                    if (callback != undefined) {
                        callback({
                            content: content,
                            roots: roots,
                            newPolynomial: np,
                            type: "(ax+b)**n"
                        }); //TODO:
                    }

                    return roots;
                }
            }
        }
        if (np.getDegree() >= 2) {
            var root = np.doRationalRootTest();
            if (root != null) {
                //np = np.divideAndRemainder(Polynomial.of(root.getNumerator().negate(), root.getDenominator())).quotient;
                np = np.divideAndRemainder(Polynomial.of(root.negate(), Expression.ONE)).quotient;
                roots.push(root);
                if (typeof hit === "function") {
                    hit({
                        getroots: {
                            rational: ""
                        }
                    });
                }
                if (callback != undefined) {
                    callback({
                        content: content,
                        roots: roots,
                        newPolynomial: np,
                        type: "useTheRationalRootTest"
                    });
                }
                if (np.getDegree() > 0) {
                    continueWithNewPolynomial(roots, np);
                }
                return roots;
            }
        }

        //TODO: depressed for all degrees (?) in Polynomial#getZeros() - ?
        if (!np.hasIntegerCoefficients() && np.getDegree() === 3) {
            //?
            // convert to depressed (?)
            // x = t - b / (n * a)
            var h = np._getShiftToDepressed();
            if (!h.equals(Expression.ZERO)) {
                var p = np._translateRoots(h);
                if (p.hasIntegerCoefficients()) {
                    //?
                    var zeros = p.getroots();
                    if (zeros.length === 0) {
                        //?
                        zeros = p.getZeros();
                        debugger;
                    }
                    if (zeros.length === np.getDegree()) {
                        //?
                        for (var iteratorzero = zeros[globalThis.Symbol.iterator](), zero = iteratorzero.next().value; zero != null; zero = iteratorzero.next().value) {
                            roots.push(zero.subtract(h));
                        }
                        np = Polynomial.of(np.getLeadingCoefficient());
                        if (callback != undefined) {
                            callback({
                                content: content,
                                roots: roots,
                                newPolynomial: np,
                                type: "solveCubicEquation"
                            });
                        }
                        return roots;
                    } else {
                        debugger;
                    }
                }
            }
        }
        if (np.hasIntegerCoefficients()) {
            //?
            // convert to depressed (?)
            // x = t - b / (n * a)
            var n = np.getDegree();
            var a = np.getLeadingCoefficient();
            var b = np.getCoefficient(n - 1);
            if (!b.equals(Expression.ZERO)) {
                var h = b.divide(Expression.Integer.fromNumber(n).multiply(a));
                var depressed = np._translateRoots(h);
                var depressedRoots = [];
                if (callback != undefined) {
                    //HACK:
                    var originalCallback = callback;
                    callback = function(info) {
                        // https://en.wikipedia.org/wiki/Algebraic_equation#Elimination_of_the_sub-dominant_term
                        originalCallback({
                            content: content.multiply(depressed.getLeadingCoefficient().divide(np.getLeadingCoefficient()).inverse()),
                            roots: roots,
                            newPolynomial: depressed,
                            type: "eliminationOfTheSubDominantTerm",
                            b: b,
                            n: n,
                            a: a,
                            newPolynomialVariable: new Expression.Symbol('t')
                        });
                        originalCallback(info);
                        callback = originalCallback;
                    };
                }
                continueWithNewPolynomial(depressedRoots, depressed, new Expression.Symbol('t')); //TODO: ?
                if (depressedRoots.length > 0) {
                    for (var iteratordepressedRoot = depressedRoots[globalThis.Symbol.iterator](), depressedRoot = iteratordepressedRoot.next().value; depressedRoot != null; depressedRoot = iteratordepressedRoot.next().value) {
                        roots.push(depressedRoot.subtract(h));
                    }
                    if (depressedRoots.length === depressed.getDegree()) {
                        np = Polynomial.of(np.getLeadingCoefficient());
                    } else {
                        //?
                        console.warn('TODO:');
                        //throw new TypeError();
                        //TODO: !!!
                    }
                    //TODO: back substitution:
                    //if (callback != undefined) {
                    //  callback({content: content, roots: roots, newPolynomial: np, type: "t = x - b/(n*a)", g: "?"});//TODO: ?
                    //}
                }

                return roots;
            }
        }
        if (np.getDegree() === 3) {
            // https://en.wikipedia.org/wiki/Cubic_function#Algebraic_solution
            var a = np.getCoefficient(3);
            var b = np.getCoefficient(2);
            var c = np.getCoefficient(1);
            var d = np.getCoefficient(0);
            var THREE = Expression.Integer.fromNumber(3);
            var h = b.divide(THREE.multiply(a));
            var substitute = function(y) {
                return y.subtract(h);
            };
            var tmp = np._translateRoots(h);
            var depressed = tmp.scale(tmp.getLeadingCoefficient().inverse());
            var p = depressed.getCoefficient(1);
            var q = depressed.getCoefficient(0);
            var discriminant = p.divide(THREE)._pow(3).add(q.divide(Expression.TWO)._pow(2));
            if (typeof hit === "function") {
                hit({
                    getroots: {
                        cubic: (discriminant instanceof Expression.Integer ? discriminant.compareTo(Expression.ZERO) : "?") + "-" + (p instanceof Expression.Integer ? p.compareTo(Expression.ZERO) : "?")
                    }
                });
            }
            var minusOneOverTwo = Expression.ONE.negate().divide(Expression.TWO);
            var iSqrtOfThreeOverTwo = Expression.I.multiply(THREE.squareRoot()).divide(Expression.TWO);
            var cbrtOfMinusOne1 = minusOneOverTwo.subtract(iSqrtOfThreeOverTwo); // (-1-sqrt(3)*i)/2
            var cbrtOfMinusOne2 = minusOneOverTwo.add(iSqrtOfThreeOverTwo); // (-1+sqrt(3)*i)/2
            if (q.equals(Expression.ZERO) && p.equals(Expression.ZERO)) {
                //TODO: link to a^3+3a^2b+3ab^2+b^3=0 - ?
                // -b/(3*a)
                var root = substitute(Expression.ZERO);
                roots.push(root);
                roots.push(root);
                roots.push(root);
                np = Polynomial.of(np.getLeadingCoefficient());
                if (callback != undefined) {
                    callback({
                        content: content,
                        roots: roots,
                        newPolynomial: np,
                        type: "solveCubicEquation"
                    });
                }
                return roots;
            } else if (q.equals(Expression.ZERO)) {
                roots.push(substitute(Expression.ZERO));
                var tmp = nthRoot(2, p.negate(), np);
                roots.push(substitute(tmp));
                roots.push(substitute(tmp.negate()));
                np = Polynomial.of(np.getLeadingCoefficient());
                if (callback != undefined) {
                    callback({
                        content: content,
                        roots: roots,
                        newPolynomial: np,
                        type: "solveCubicEquation"
                    });
                }
                return roots;
            } else if (p.equals(Expression.ZERO)) {
                //TODO: should not reach this point (?) - should be solved by previous methods
                var tmp = nthRoot(3, q.negate(), np);
                roots.push(substitute(tmp));
                roots.push(substitute(tmp.multiply(cbrtOfMinusOne1)));
                roots.push(substitute(tmp.multiply(cbrtOfMinusOne2)));
                np = Polynomial.of(np.getLeadingCoefficient());
                if (callback != undefined) {
                    callback({
                        content: content,
                        roots: roots,
                        newPolynomial: np,
                        type: "solveCubicEquation"
                    });
                }
                return roots;
            } else if (discriminant.equals(Expression.ZERO)) {
                // https://github.com/nicolewhite/algebra.js/blob/master/src/equations.js
                // https://en.wikipedia.org/wiki/Cubic_equation#Multiple_root
                // a double root
                var t23 = THREE.multiply(q).divide(Expression.TWO.multiply(p)).negate();
                var root23 = substitute(t23);
                roots.push(root23);
                roots.push(root23);
                var t1 = t23.multiply(Expression.TWO).negate();
                var root1 = substitute(t1);
                roots.push(root1);
                np = Polynomial.of(np.getLeadingCoefficient());
                if (callback != undefined) {
                    callback({
                        content: content,
                        roots: roots,
                        newPolynomial: np,
                        type: "solveCubicEquation"
                    });
                }
                return roots;
            } else {
                // https://en.wikipedia.org/wiki/Cubic_equation#Cardano's_formula
                // 2*b^3-9*a*b*c+27*a^2*d
                var tmp = nthRoot(2, discriminant, np);
                if (tmp != undefined) {
                    var C = nthRoot(3, q.negate().divide(Expression.TWO).add(tmp), np);
                    if (C != undefined && !(C instanceof Expression.ExpressionPolynomialRoot) && !(C instanceof Expression.ExpressionWithPolynomialRoot)) {
                        //TODO: !?
                        var rootFromC = function(C) {
                            return substitute(C.subtract(p.divide(THREE.multiply(C))));
                        };
                        roots.push(rootFromC(C));
                        roots.push(rootFromC(C.multiply(cbrtOfMinusOne1)));
                        roots.push(rootFromC(C.multiply(cbrtOfMinusOne2)));
                        np = Polynomial.of(np.getLeadingCoefficient());
                        if (callback != undefined) {
                            callback({
                                content: content,
                                roots: roots,
                                newPolynomial: np,
                                type: "solveCubicEquation"
                            });
                        }
                        return roots;
                    }
                }
            }
        }

        //!2018-12-23
        if (np.getDegree() > 2) {
            // https://en.wikipedia.org/wiki/Square-free_polynomial
            var tmp = np.squareFreeFactors();
            var a0 = tmp.a0;
            var a1 = tmp.a1;
            if (a0.getDegree() > 0) {
                //TODO: merge with a code for Kronecker's method
                //TODO: factorization - ?
                var newA0 = a0;
                var a0r = a0.getroots(function(x) {
                    newA0 = x.newPolynomial;
                });
                var previousRoot = null;
                for (var i = 0; i < a0r.length; i += 1) {
                    var root = a0r[i];
                    roots.push(root);
                    if (previousRoot == null || !previousRoot.equals(root)) {
                        roots.push(root);
                    }
                    previousRoot = root;
                }
                // find roots of a1 at first (for better performance):
                var newA1 = a1;
                var a1Roots = a1.getroots(function(x) {
                    newA1 = x.newPolynomial;
                });
                for (var i = 0; i < a1Roots.length; i += 1) {
                    roots.push(a1Roots[i]);
                }
                if (newA0 != null) {
                    //TODO: test
                    np = newA1.multiply(newA0).multiply(Polynomial.polynomialGCD(newA0, np));
                }
                if (a0r.length > 0 || a1Roots.length > 0) {
                    if (typeof hit === "function") {
                        hit({
                            getroots: {
                                squareFreeFactorization: np.toString()
                            }
                        });
                    }
                    if (callback != undefined) {
                        //TODO: better details, t = sqrt(3), show the polynomial, ...
                        callback({
                            content: content,
                            roots: roots,
                            newPolynomial: np,
                            type: "squareFreeFactorization"
                        }); //?
                    }
                    //continueWithNewPolynomial(roots, np);
                    return roots;
                }
            }
        }
        //!

        if (np.getDegree() >= 4) {
            if (true) {
                //TODO: !!! show correct method name in details
                var g = np.factorize();
                if (g != undefined) {
                    var h = np.divideAndRemainder(g).quotient;
                    var gNew = null;
                    var gRoots = g.getroots(function(x) {
                        gNew = x.newPolynomial.scale(x.content);
                    });
                    for (var i = 0; i < gRoots.length; i += 1) {
                        roots.push(gRoots[i]);
                        //np = np.divideAndRemainder(Polynomial.of(gRoots[i].negate(), Expression.ONE)).quotient;//TODO: optimize somehow - ?
                    }

                    if (gRoots.length > 0) {
                        np = np.divideAndRemainder(g.divideAndRemainder(gNew).quotient).quotient;
                    }
                    var hNew = null;
                    var hRoots = h.getroots(function(x) {
                        hNew = x.newPolynomial.scale(x.content);
                    });
                    for (var i = 0; i < hRoots.length; i += 1) {
                        roots.push(hRoots[i]);
                        //np = np.divideAndRemainder(Polynomial.of(hRoots[i].negate(), Expression.ONE)).quotient;//TODO: optimize somehow - ?
                    }

                    if (hRoots.length > 0) {
                        np = np.divideAndRemainder(h.divideAndRemainder(hNew).quotient).quotient;
                    }
                    if (hRoots.length > 0 || gRoots.length > 0) {
                        if (typeof hit === "function") {
                            hit({
                                getroots: {
                                    methodOfKronecker: np.toString()
                                }
                            });
                        }
                        if (callback != undefined) {
                            //TODO: better details
                            callback({
                                content: content,
                                roots: roots,
                                newPolynomial: np,
                                type: "methodOfKronecker"
                            }); //?
                        }
                    }

                    return roots;
                }
            }
        }

        //TODO: ???
        //TODO: move up
        if (np.getDegree() >= 3) {
            for (var i = 0; i <= np.getDegree(); i += 1) {
                if (Expression.has(np.getCoefficient(i), Expression.SquareRoot)) {
                    var c = null;
                    Expression._map(function(x) {
                        if (c == null) {
                            //TODO: fix - ?
                            if (x instanceof Expression.SquareRoot && x.a instanceof Expression.Integer) {
                                c = x;
                            }
                        }
                        return x;
                    }, np.getCoefficient(i));
                    if (c != null) {
                        var tmp = new Expression.Symbol('_t'); //?
                        // substitute
                        var p = np.map(function(coefficient) {
                            var s1 = Expression.ZERO;
                            // Expression._map does not work here as it goes into Expression.Exponentiation: x**2 -> x**(t**2). It throws an exception.
                            for (var iterators = coefficient.summands()[globalThis.Symbol.iterator](), s = iterators.next().value; s != null; s = iterators.next().value) {
                                var t = Expression.ONE;
                                for (var iteratorx = s.factors()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
                                    if (x.equals(c)) {
                                        t = t.multiply(tmp);
                                    } else if (x instanceof Expression.Integer) {
                                        var exp = 0;
                                        while (x.gcd(c.a).equals(c.a)) {
                                            exp += 2;
                                            x = x.divide(c.a);
                                        }
                                        t = t.multiply(x.multiply(tmp._pow(exp)));
                                        //?
                                        //var q = x.truncatingDivide(c.a);
                                        //var r = x.subtract(q.multiply(c.a));
                                        //return q.multiply(tmp.multiply(tmp)).add(r);
                                    } else {
                                        t = t.multiply(x);
                                    }
                                }
                                s1 = s1.add(t);
                            }
                            return s1;
                        });
                        var a = "_x" + ++counter;
                        var newp = Polynomial.toPolynomial(p.calcAt(new Expression.Symbol(a)), tmp);
                        //!2020-12-11
                        var g = newp.getGCDOfTermDegrees();
                        if (g >= 2) {
                            var newData = new Array(Math.floor((newp.getDegree() + g) / g));
                            var k = 0;
                            for (var i1 = 0; i1 <= newp.getDegree(); i1 += g) {
                                newData[k] = newp.getCoefficient(i1).multiply(c._pow(i1 - k));
                                k += 1;
                            }
                            newp = Polynomial.from(newData);
                        }
                        //!
                        if (newp.getDegree() > 1) {
                            var roots1 = [];
                            var rr = null;
                            //TODO: ?
                            while ((rr = newp.doRationalRootTest()) != null) {
                                roots1.push(rr);
                                newp = newp.divideAndRemainder(Polynomial.of(rr.negate(), Expression.ONE), "throw").quotient;
                            }
                            //TODO: details - ?
                            //var roots1 = newp.getroots();
                            var rootsCount = roots.length;
                            for (var j = 0; j < roots1.length; j += 1) {
                                //TODO: check
                                var roots2 = Polynomial.toPolynomial(roots1[j].subtract(c).getNumerator(), new Expression.Symbol(a)).getroots();
                                for (var k = 0; k < roots2.length; k += 1) {
                                    var root = roots2[k];
                                    roots.push(root);
                                    np = np.divideAndRemainder(Polynomial.of(root.negate(), Expression.ONE)).quotient; //TODO: optimize somehow - ?
                                }
                            }

                            if (roots.length > rootsCount) {
                                if (typeof hit === "function") {
                                    hit({
                                        getroots: {
                                            methodOfIntroducingANewVariable: ""
                                        }
                                    });
                                }
                                if (callback != undefined) {
                                    //TODO: better details, t = sqrt(3), show the polynomial, ...
                                    callback({
                                        content: content,
                                        roots: roots,
                                        newPolynomial: np,
                                        type: "methodOfIntroducingANewVariable",
                                        t: c
                                    }); //?
                                }

                                continueWithNewPolynomial(roots, np);
                                return roots; //TODO: when it is not all roots
                            }
                        }
                    }
                }
            }
        }

        if (np.getDegree() === 4) {
            // https://en.wikipedia.org/wiki/Quartic_function
            // 1. coverting to a depressed quartic:
            var a_4 = np.getCoefficient(4);
            var p = np.scale(a_4.inverse());
            var b = p.getCoefficient(3);
            var y = new Expression.Symbol('$y');
            var substitute = function(y) {
                return y.subtract(b.divide(Expression.Integer.fromNumber(4)));
            };
            var e = p.calcAt(substitute(y));
            var sp = Polynomial.toPolynomial(e.getNumerator(), y); //TODO: ?
            var p = sp.getCoefficient(2);
            var q = sp.getCoefficient(1);
            var r = sp.getCoefficient(0);
            //var Q = nthRootInternal(3, );

            //var root = y0.subtract(b.divide(Expression.Integer.fromNumber(4)));

            // https://en.wikipedia.org/wiki/Quartic_function#Descartes'_solution
            var pU = Polynomial.of(q._pow(2).negate(), p._pow(2).subtract(Expression.TWO.add(Expression.TWO).multiply(r)), Expression.TWO.multiply(p), Expression.ONE);
            //TODO: when depressed cubic equation (?)
            //TODO: only one cubic equation root (?)
            var pURoots = pU.getCoefficient(1).equals(Expression.ZERO) && pU.getCoefficient(2).equals(Expression.ZERO) || pU.getCoefficient(0).equals(Expression.ZERO) ? pU.getroots() : [pU.doRationalRootTest() || Expression.ZERO];
            for (var iteratorU = pURoots[globalThis.Symbol.iterator](), U = iteratorU.next().value; U != null; U = iteratorU.next().value) {
                var u = nthRootInternal(2, U);
                if (!U.equals(Expression.ZERO) && u != null) {
                    var s = u.negate();
                    var t = p.add(u._pow(2)).add(q.divide(u)).divide(Expression.TWO);
                    var v = p.add(u._pow(2)).subtract(q.divide(u)).divide(Expression.TWO);
                    //TODO: details (factorization of two quadratic)
                    var p1 = Polynomial.of(t, s, Expression.ONE);
                    var p2 = Polynomial.of(v, u, Expression.ONE);
                    var p12 = Polynomial.of(Expression.ONE);
                    for (var iteratorroot = p1.getroots()[globalThis.Symbol.iterator](), root = iteratorroot.next().value; root != null; root = iteratorroot.next().value) {
                        var s = substitute(root);
                        roots.push(s);
                        p12 = p12.multiply(Polynomial.of(s.negate(), Expression.ONE));
                    }
                    for (var iteratorroot = p2.getroots()[globalThis.Symbol.iterator](), root = iteratorroot.next().value; root != null; root = iteratorroot.next().value) {
                        var s = substitute(root);
                        roots.push(s);
                        p12 = p12.multiply(Polynomial.of(s.negate(), Expression.ONE));
                    }
                    if (p12.getDegree() > 0) {
                        np = np.divideAndRemainder(p12).quotient;
                        if (callback != undefined) {
                            callback({
                                content: content,
                                roots: roots,
                                newPolynomial: np,
                                type: "solveQuarticEcuation"
                            }); //?
                        }

                        continueWithNewPolynomial(roots, np);
                        return roots;
                    }
                }
            }
            //debugger;
            //console.log(pURoots);
        }

        if (!np.hasIntegerCoefficients() && np.getDegree() > 2) {
            //?new
            var variable = new Expression.Symbol('$$');
            var e = np.calcAt(variable);
            var c = Expression.getConjugate(e);
            if (c != null) {
                var result = [];
                var newP = null;
                var ceRoots = Polynomial.toPolynomial(c.multiply(e), variable).getSquareFreePolynomial().getroots(function(x) {
                    newP = x.newPolynomial;
                }); //TODO: details - ?
                for (var i = 0; i < ceRoots.length; i += 1) {
                    var root = ceRoots[i];
                    if (np.calcAt(root).equals(Expression.ZERO)) {
                        roots.push(root);
                        //TODO: this also filters out duplicate roots (?)
                        //TODO: factorization may be not good, so this also needed to calc polynomial to continue the factorization
                        np = np.divideAndRemainder(Polynomial.of(root.negate(), Expression.ONE)).quotient; //TODO: optimize somehow - ?
                    } else {
                        //TODO:?
                        console.debug(root);
                    }
                }
                if (ceRoots.length > 0) {
                    if (callback != undefined) {
                        //TODO: better details, t = sqrt(3), show the polynomial, ...
                        callback({
                            content: content,
                            roots: roots,
                            newPolynomial: np,
                            type: "multiplyByConjugates",
                            t: c
                        }); //?
                    }

                    continueWithNewPolynomial(roots, np);
                }
                return roots;
            }
        }
        if (np.getDegree() >= 0) {
            //TODO: fix
            if (typeof hit === "function") {
                hit({
                    getroots: {
                        other: np.getDegree()
                    }
                });
            }
        }
        return roots;
    };
    Polynomial.prototype.derive = function() {
        var newData = new PolynomialData(this.a.size);
        for (var i = 0; i < this.a.size; i += 1) {
            var n = this.a.degree(i);
            var c = this.a.coefficient(i);
            if (n >= 1) {
                var nc = Expression.Integer.fromNumber(n).multiply(c);
                if (!nc.equals(Expression.ZERO)) {
                    newData.add(n - 1, nc);
                }
            }
        }
        return new Polynomial(newData);
    };
    Polynomial.prototype.getSquareFreePolynomial = function() {
        //TODO: remove (it is not good for performance of the factoring)
        return this.divideAndRemainder(this.squareFreeFactors().a0).quotient;
    };
    Polynomial.prototype.isSquareFreePolynomial = function() {
        return this.squareFreeFactors().a0.equals(Polynomial.of(Expression.ONE));
    };

    // f = a_1 * a_2**2 * a_3**3 * ... * a_n**n
    // a1 = a_1
    // a0 = a_2**1 * a_3**2 * ... * a_n**(n-1)
    // returns factor a1 - square free factor, a0 - a factor where the degree of every coprime factor is less by one
    Polynomial.prototype.squareFreeFactors = function() {
        // https://en.wikipedia.org/wiki/Square-free_polynomial
        var p = this;
        var zero = 0;
        while (p.getCoefficient(zero).equals(Expression.ZERO)) {
            zero += 1;
        }
        p = p.divideAndRemainder(Polynomial.of(Expression.ONE).shift(zero), "throw").quotient;
        if (p.getDegree() !== 0) {
            var f = p;
            var d = f.derive();
            var a0 = Polynomial.polynomialGCD(f, d);
            if (a0.getDegree() !== 0) {
                if (Expression.isConstant(a0.getLeadingCoefficient())) {
                    //TODO: ?
                    a0 = a0.scale(a0.getLeadingCoefficient().inverse()); //TODO: ?
                }

                if (f.hasIntegerCoefficients()) {
                    //?
                    a0 = a0.scale(a0.getContent().inverse()); //?
                }
                //TODO: ?
                var b1 = f.divideAndRemainder(a0, f._hasIntegerLikeCoefficients() ? "throw" : undefined).quotient;
                var g1 = Polynomial.polynomialGCD(b1, a0);
                var a1 = b1.divideAndRemainder(g1, b1._hasIntegerLikeCoefficients() ? "throw" : undefined).quotient;
                return {
                    a1: a1.shift(zero === 1 ? 1 : 0),
                    a0: a0.shift(zero > 1 ? zero - 1 : 0)
                };
            }
        }
        return {
            a1: p.shift(zero === 1 ? 1 : 0),
            a0: Polynomial.of(Expression.ONE).shift(zero > 1 ? zero - 1 : 0)
        };
    };
    self.Polynomial = Polynomial;

    // TODO: tests:
    // stringToPolynomial('x^4-1280*x^2+327680')._findGoodSubstitution().toString() === '16'
    // stringToPolynomial('x^2-1280*x+1280')._findGoodSubstitution().toString() === '16'

    Polynomial.prototype._findGoodSubstitution = function() {
        var f = function(polynomial) {
            var g = polynomial.getCoefficient(0).abs();
            for (var i = 0; i < polynomial.getDegree(); i += 1) {
                g = g.gcd(polynomial.getCoefficient(i).abs());
            }
            g = g.abs();
            var result = Expression.ONE;
            while (!g.equals(Expression.ONE)) {
                var p = g.primeFactor();
                if (!polynomial.getLeadingCoefficient().remainder(p).equals(Expression.ZERO)) {
                    var ok = true;
                    for (var i = 0; i < polynomial.getDegree() && ok; i += 1) {
                        var x = p._pow(polynomial.getDegree() - i);
                        ok = polynomial.getCoefficient(i).gcd(x).abs().equals(x);
                    }
                    if (ok) {
                        result = result.multiply(p);
                        polynomial = polynomial._scaleRoots(p.inverse()).primitivePart();
                    }
                }
                g = g.truncatingDivide(p);
            }
            return result;
        };
        var n = f(this);
        return n.divide(f(this._scaleRoots(n.inverse())._exponentiateRoots(-1)));
    };
    Polynomial.prototype._getShiftToDepressed = function() {
        // for testing (?)
        var n = this.getDegree();
        var a = this.getLeadingCoefficient();
        var b = this.getCoefficient(n - 1);
        var h = b.divide(Expression.Integer.fromNumber(n).multiply(a));
        //var depressed = this._translateRoots(h);
        //console.log(depressed);
        return h;
    };
    Polynomial.prototype._factorizeOverTheIntegers = function() {
        //return factorizeOverTheIntegers(this).next().value;
        return factorizeOverTheIntegers(this);
    };
    Polynomial.prototype._factorizeMultivariateIntegerPolynomial = function() {
        var varY = Polynomial._getY(this, this);
        var start = Date.now();
        var toTwoVariatePolynomial = function(polynomial, v2) {
            return polynomial.map(function(c) {
                return new Expression.Polynomial(Polynomial.toPolynomial(c, new Expression.Symbol(v2)));
            });
        };
        var f = factorizeOverTheIntegers._factorizeMultivariateIntegerPolynomial(toTwoVariatePolynomial(this, varY.symbol));
        var end = Date.now();
        if (end - start > 4) {
            console.log('_factorizeMultivariateIntegerPolynomial', end - start, this.toString());
        }
        if (f == null) {
            return null;
        }
        f = f.map(function(c) {
            return c.polynomial.calcAt(varY);
        });
        if (f.getLeadingCoefficient().isNegative()) {
            //TODO: move - ?
            f = f.negate();
        }
        return f;
    };
    Polynomial.prototype.factorize = function() {
        //if (this.getDegree() !== 3 && !this._canBeFactored()) {//TODO: ?
        //TODO: details - ?
        //  return undefined;
        //}
        if (this.getCoefficient(0).equals(Expression.ZERO)) {
            //?
            return Polynomial.of(Expression.ZERO, Expression.ONE);
        }
        if (this.getDegree() === 3) {
            //console.log(this.toString());
        }
        var content = this.getContent(); //?TODO: ?
        if (!content.equals(Expression.ONE) && !content.equals(Expression.ONE.negate())) {
            throw new RangeError();
        }
        if (this.getDegree() === 1) {
            return null;
        }
        if (this.getDegree() === 2) {
            var discriminant = function(p) {
                console.assert(p.getDegree() === 2);
                var a = p.getCoefficient(2);
                var b = p.getCoefficient(1);
                var c = p.getCoefficient(0);
                return b.multiply(b).subtract(Expression.Integer.fromNumber(4).multiply(a).multiply(c));
            };
            var d = discriminant(this);
            //TODO: not integer discriminants (?)
            if (d instanceof Expression.Integer && !d._isPerfectSquare()) {
                return null;
            }
        }
        var tmp = this.squareFreeFactors();
        if (tmp.a0.getDegree() > 0) {
            //TODO: ?
            if (tmp.a1.getDegree() > 0) {
                return tmp.a1;
            }
            return tmp.a0;
        }
        if (this.getDegree() < 2) {
            return null;
        }
        //!new
        if (this.hasIntegerCoefficients() && false) {
            var k = this._findGoodSubstitution();
            if (!k.equals(Expression.ONE)) {
                var newp = this._scaleRoots(k.inverse());
                newp = newp.scale(newp.getContent().inverse());
                console.log('_findGoodSubstitution', newp._log2hypot() / this._log2hypot());
                var f = newp.factorize();
                if (f != undefined) {
                    return f._scaleRoots(k);
                }
                return null; //!?
            }
        }

        var n = this.getDegree();
        var b = this.getCoefficient(n - 1);
        if (!b.equals(Expression.ZERO) && !this.hasIntegerCoefficients()) {
            // conversion to depressed is slow (!) (large coefficients)
            var a = this.getLeadingCoefficient();
            var shift = b.divide(Expression.Integer.fromNumber(n).multiply(a));
            var depressed = this._translateRoots(shift);
            if (depressed.hasIntegerCoefficients()) {
                depressed = depressed.primitivePart(); //TODO: ?
                var factor = depressed.factorize();
                if (factor != null) {
                    return factor._translateRoots(shift.negate()).primitivePart();
                }
                return null;
            } else {
                console.warn("???");
            }
        }
        //!
        //!new
        if (this.isEven()) {
            if (this.hasIntegerCoefficients() && (!this.getCoefficient(0).abs()._isPerfectSquare() || !this.getCoefficient(this.getDegree()).abs()._isPerfectSquare())) {
                var f = this._exponentiateRoots(2).factorize();
                if (f != undefined) {
                    return f._exponentiateRoots(1 / 2);
                }
                return null;
            }
            //TODO: it should be factored into a product of (ax**(n/2)+...+bx+c) and (ax**(n/2)+...-bx+c)
            //if (this._factorByKroneckersMethod() != undefined) {
            //  debugger;
            //}
        }

        var g = this.getGCDOfTermDegrees();
        if (g > 2) {
            var f = this._exponentiateRoots(g).factorize();
            if (f != undefined) {
                return f._exponentiateRoots(1 / g);
            }
            //?
        }
        //!
        if (this.getDegree() < 4 || !this.hasIntegerCoefficients()) {
            //? avoid Polynomial#getZeros(...)
            var root = this.doRationalRootTest();
            if (root != null) {
                return Polynomial.of(root.getNumerator(), root.getDenominator().negate());
            }
            if (this.getDegree() < 4) {
                // https://math.stackexchange.com/questions/1138416/how-do-i-show-a-cubic-polynomial-does-not-factorise#answer-1138428
                return null;
            }
        }
        //!
        var np = this;
        //console.time('Kronecker\'s method');
        //TODO: ?
        if (!np.hasIntegerCoefficients()) {
            if (np._hasIntegerLikeCoefficients() && Polynomial._getY(np, np) != null) {
                //TODO: ?
                return np._factorizeMultivariateIntegerPolynomial();
            }
            //TODO: ?
            //return np._factorByKroneckersMethod();
            return null;
        }
        return np._factorizeOverTheIntegers();
        //console.timeEnd('Kronecker\'s method');
    };

    Polynomial.prototype.primitivePart = function() {
        //return this.divideAndRemainder(Polynomial.of(this.getContent()), "throw").quotient;
        //TODO: test if this is faster:
        //var content = this.getContent();
        //return this.scale(content.getDenominator()).divideAndRemainder(Polynomial.of(content.getNumerator()), "throw").quotient;
        return this.scale(this.getContent().inverse());
    };

    //TODO: return primitivePart all the time
    Polynomial.prototype.modularInverse = function(mod) {
        if (mod.getDegree() < 9 && this.getDegree() < mod.getDegree() && false || this.getDegree() < mod.getDegree() && mod.getDegree() <= 3) {
            //TODO: remove - ?
            var n = mod.getDegree();
            var e = this;
            var conjugate = Polynomial.of(n % 2 === 1 ? Expression.ONE : Expression.ONE.negate());
            while (e.getDegree() > 0) {
                var pseudoDivision = function(A, B) {
                    var R = A;
                    var Q = Polynomial.ZERO;
                    while (R.getDegree() >= B.getDegree()) {
                        var lc = R.getLeadingCoefficient();
                        Q = Q.scale(B.getLeadingCoefficient());
                        R = R.scale(B.getLeadingCoefficient());
                        var q = Polynomial.of(lc.negate()).shift(R.getDegree() - B.getDegree());
                        Q = Q.add(q);
                        R = R.add(B.multiply(q));
                    }
                    return {
                        Q: Q,
                        R: R
                    };
                };
                var tmp = pseudoDivision(mod.negate(), e);
                e = tmp.R;
                conjugate = conjugate.multiply(tmp.Q);
            }
            conjugate = conjugate.divideAndRemainder(mod).remainder;
            //TODO: 
            if (false) {
                var conjugate2 = polynomial.modularInverse(mod).primitivePart();
                var t = conjugate2.getLeadingCoefficient();
                var a = conjugate2.scale(conjugate.getLeadingCoefficient());
                var b = conjugate.scale(t);
                if (!b.equals(a)) {
                    debugger;
                }
            }
            var C1 = conjugate;
            //return conjugate;
            if (mod.getDegree() <= 3) {
                return conjugate;
            }
        }
        // it is slow for both "integer coefficients" and "integer-like coefficients" somehow:

        var m = mod;
        var g = Math.gcd(this.getGCDOfTermDegrees(), m.getGCDOfTermDegrees());
        if (g > 1) {
            return this._exponentiateRoots(g).modularInverse(m._exponentiateRoots(g)).primitivePart()._exponentiateRoots(1 / g);
        }
        if (this.hasIntegerCoefficients() && m.hasIntegerCoefficients()) {
            //TODO: ???
        }
        //TODO: ?
        // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Polynomial_extended_Euclidean_algorithm
        var a = this;
        var oldR = m;
        var r = a.getDegree() >= m.getDegree() ? Polynomial.pseudoRemainder(a, m).primitivePart() : a; //? faster than swap (?)
        //var r = a;
        /*if (oldR.getDegree() < r.getDegree()) {
          var tmp = oldR;
          oldR = r;
          r = tmp;
        }*/
        var oldT = Polynomial.of(Expression.ZERO);
        var t = Polynomial.of(Expression.ONE);
        var type = a._hasIntegerLikeCoefficients() && m._hasIntegerLikeCoefficients() || true ? "primitive" : "subresultant";
        for (var iteratortmp = Polynomial._pseudoRemainderSequence(oldR, r, type)[globalThis.Symbol.iterator](), tmp = iteratortmp.next().value; tmp != null; tmp = iteratortmp.next().value) {
            var scale = r.getLeadingCoefficient()._pow(oldR.getDegree() - r.getDegree() + 1);
            var quotient = tmp.q;
            var α = tmp.α;
            var newT = oldT.scale(scale).subtract(quotient.multiply(t));
            if (type === "primitive") {
                if (false) {
                    newT = newT.scale(α.inverse());
                } else {
                    var g = newT.getContent().gcd(α);
                    newT = newT.divideAndRemainder(Polynomial.of(g), "throw").quotient;
                    t = t.scale(α.divide(g)); //?
                }
            } else {
                newT = newT.divideAndRemainder(Polynomial.of(α), "throw").quotient;
            }
            var $newoldT = t;
            var $newt = newT;
            oldT = $newoldT;
            t = $newt;
            var newR = tmp.R;
            var $newoldR = r;
            var $newr = newR;
            oldR = $newoldR;
            r = $newr;
        }
        var gcd = oldR;
        if (gcd.getDegree() !== 0) {
            throw new TypeError(); //?
        }

        oldT = oldT.primitivePart().scale(m.getLeadingCoefficient()._pow(Math.max(oldT.getDegree() + a.getDegree() - m.getDegree() + 1, 0)));
        var r = oldT.multiply(a).divideAndRemainder(m, "throw").remainder;
        if (r.getDegree() !== 0) {
            throw new TypeError(); //?
        }
        // do not unscale for performance:
        //oldT = oldT.scale(r.getCoefficient(0).inverse());
        if (C1 != undefined) {
            console.log("!", C1.toString(), oldT.toString());
        }
        return oldT;
    };
})();
(function() {
    "use strict";
    /*jslint plusplus: true, vars: true, indent: 2 */



    //    API same as http://sylvester.jcoglan.com/api/matrix.html
    //    new Matrix([
    //      [1, 2, 3],
    //      [5, 6, 7],
    //      [7, 8,-1]
    //    ]);

    function Matrix(data) {
        this.a = data;
    }

    Matrix.Zero = function(rows, cols) {
        var row = new Array(cols);
        for (var j = 0; j < cols; j += 1) {
            row[j] = Expression.ZERO;
        }
        var a = new Array(rows);
        for (var i = 0; i < rows; i += 1) {
            a[i] = row;
        }
        return new Matrix(a);
    };

    // identity n x n;
    Matrix.I = function(n) {
        return Matrix.Zero(n, n).map(function(element, i, j) {
            return (i === j ? Expression.ONE : Expression.ZERO);
        });
    };

    //Matrix.Diagonal = function (elements) {
    //  var n = elements.length;
    //  return Matrix.Zero(n, n).map(function (element, i, j) {
    //    return i === j ? elements[i] : Expression.ZERO;
    //  });
    //};

    Matrix.prototype.rows = function() {
        return this.a.length;
    };

    Matrix.prototype.cols = function() {
        return this.a.length > 0 ? this.a[0].length : 0;
    };

    Matrix.prototype.e = function(i, j) {
        return this.a[i][j];
    };

    Matrix.prototype.isSquare = function() {
        return this.rows() > 0 && this.rows() === this.cols(); //?
    };

    Matrix.prototype.map = function(callback) {
        var rows = this.rows();
        var cols = this.cols();
        var c = new Array(rows);
        var i = -1;
        while (++i < rows) {
            var x = new Array(cols);
            var j = -1;
            while (++j < cols) {
                var e = callback.call(undefined, this.e(i, j), i, j, this);
                x[j] = e.simplifyExpression(); //?
            }
            c[i] = x;
        }
        return new Matrix(c);
    };

    Matrix.prototype.transpose = function() {
        var that = this;
        return Matrix.Zero(that.cols(), that.rows()).map(function(element, i, j) {
            return that.e(j, i);
        });
    };

    Matrix.prototype.scale = function(k) {
        return this.map(function(element, i, j) {
            return element.multiply(k);
        });
    };

    Matrix.prototype.multiply = function(b) {
        var a = this;
        if (a.cols() !== b.rows()) {
            throw new RangeError("DimensionMismatchException");
        }
        return Matrix.Zero(a.rows(), b.cols()).map(function(element, i, j) {
            var rows = b.rows();
            var k = -1;
            while (++k < rows) {
                //! this code is used to show not simplified expressions
                var current = a.e(i, k).multiply(b.e(k, j));
                element = k === 0 ? current : element.add(current);
            }
            return element;
        });
    };

    Matrix.prototype.add = function(b) {
        var a = this;
        if (a.rows() !== b.rows() || a.cols() !== b.cols()) {
            throw new RangeError("MatrixDimensionMismatchException");
        }
        return a.map(function(element, i, j) {
            return element.add(b.e(i, j));
        });
    };

    Matrix.prototype.augment = function(b) { // ( this | m )  m.rows() ==== this.rows()
        if (this.rows() !== b.rows()) {
            //TODO: fix exception
            throw new RangeError("NonSquareMatrixException");
        }
        var a = this;
        return Matrix.Zero(a.rows(), a.cols() + b.cols()).map(function(element, i, j) {
            return (j < a.cols() ? a.e(i, j) : b.e(i, j - a.cols()));
        });
    };

    Matrix.prototype.rowReduce = function(targetRow, pivotRow, pivotColumn, currentOrPreviousPivot) {
        var rows = this.rows();
        var cols = this.cols();
        var c = new Array(rows);
        var i = -1;
        while (++i < rows) {
            if (targetRow === i) {
                var x = new Array(cols);
                var f = currentOrPreviousPivot == undefined ? this.e(targetRow, pivotColumn).divide(this.e(pivotRow, pivotColumn)) : undefined;
                var j = -1;
                while (++j < cols) {
                    // (e_ij - e_ic * e_rj / e_rc) * (e_rc / cpp)
                    var e = undefined;
                    if (currentOrPreviousPivot == undefined) {
                        e = this.e(targetRow, j).subtract(f.multiply(this.e(pivotRow, j)));
                    } else {
                        e = this.e(pivotRow, pivotColumn).multiply(this.e(targetRow, j)).subtract(this.e(targetRow, pivotColumn).multiply(this.e(pivotRow, j))).divide(currentOrPreviousPivot);
                        //TODO: 
                        //if (e instanceof Expression.Division) {
                        //  debugger;
                        //}
                    }
                    x[j] = e.simplifyExpression();
                }
                c[i] = x;
            } else {
                c[i] = this.a[i];
            }
        }
        return new Matrix(c);
    };

    Matrix.prototype.swapRows = function(pivotRow, targetRow, preserveDeterminant) {
        var m = this;
        return m.map(function(e, i, j) {
            if (i === pivotRow) {
                return m.e(targetRow, j);
            }
            if (i === targetRow) {
                return preserveDeterminant ? m.e(pivotRow, j).negate() : m.e(pivotRow, j);
            }
            return e;
        });
    };

    var notEqualsZero = function(e, condition) { //TODO: - ?
        if (condition != undefined) {
            //!update from 2018-16-07
            return condition.andZero(e).isFalse();
        }
        return !e.equals(Expression.ZERO);
    };

    Matrix.check = function(usage, matrix, from, to, condition) {
        for (var i = from; i < to; i += 1) {
            if (usage !== "solving" || notEqualsZero(matrix.e(i, matrix.cols() - 1), condition)) {
                var endColumnIndex = usage === "solving" ? matrix.cols() - 1 : (usage === "determinant" ? matrix.cols() : (usage === "inverse" ? Math.floor(matrix.cols() / 2) : -1));
                var j = 0;
                while (j < endColumnIndex && matrix.e(i, j).equals(Expression.ZERO)) {
                    j += 1;
                }
                if (j === endColumnIndex) {
                    return i;
                }
            }
        }
        return -1;
    };

    Matrix.toRowEchelonStep = function(m, pivotRow, pivotColumn, pivotOriginRow, previousPivot, options, condition) {
        var oldMatrix = undefined;
        var coefficient = undefined;
        var targetRow = 0;
        if (pivotOriginRow !== pivotRow) {
            oldMatrix = m;
            m = m.swapRows(pivotRow, pivotOriginRow, options.usage === "determinant");
            if (options.callback != undefined) {
                options.callback({
                    previousPivot: undefined,
                    newMatrix: m,
                    oldMatrix: oldMatrix,
                    type: options.usage === "determinant" ? "swap-negate" : "swap",
                    targetRow: pivotRow,
                    pivotRow: pivotOriginRow,
                    pivotColumn: pivotColumn
                });
            }
        }
        // making zeros under the main diagonal
        if (options.method === Matrix.GaussJordan) {
            if (!m.e(pivotRow, pivotColumn).equals(Expression.ONE)) {
                oldMatrix = m;
                coefficient = Expression.ONE.divide(m.e(pivotRow, pivotColumn));
                m = m.map(function(e, i, j) {
                    if (i !== pivotRow) {
                        return e;
                    }
                    return e.multiply(coefficient);
                });
                if (options.callback != undefined) {
                    options.callback({
                        previousPivot: undefined,
                        newMatrix: m,
                        oldMatrix: oldMatrix,
                        type: "divide",
                        targetRow: pivotRow,
                        pivotRow: pivotRow,
                        pivotColumn: pivotColumn
                    });
                }
            }
        }
        if (options.method === Matrix.Gauss || options.method === Matrix.GaussJordan) {
            targetRow = pivotRow;
            while (++targetRow < m.rows()) {
                if (!m.e(targetRow, pivotColumn).equals(Expression.ZERO)) {
                    oldMatrix = m;
                    m = m.rowReduce(targetRow, pivotRow, pivotColumn);
                    if (options.callback != undefined) {
                        options.callback({
                            previousPivot: undefined,
                            newMatrix: m,
                            oldMatrix: oldMatrix,
                            type: "reduce",
                            targetRow: targetRow,
                            pivotRow: pivotRow,
                            pivotColumn: pivotColumn
                        });
                    }
                    var stoppedAtRow = Matrix.check(options.usage, m, targetRow, targetRow + 1, condition);
                    if (stoppedAtRow !== -1) {
                        return {
                            stoppedAtRow: stoppedAtRow,
                            matrix: m
                        };
                    }
                }
            }
        }
        if (options.method === Matrix.GaussMontante) {
            oldMatrix = m;
            targetRow = -1;
            while (++targetRow < m.rows()) {
                if (targetRow !== pivotRow) {
                    m = m.rowReduce(targetRow, pivotRow, pivotColumn, previousPivot);
                }
            }
            if (options.callback != undefined) {
                options.callback({
                    previousPivot: previousPivot,
                    newMatrix: m,
                    oldMatrix: oldMatrix,
                    type: "pivot",
                    targetRow: -1,
                    pivotRow: pivotRow,
                    pivotColumn: pivotColumn
                });
            }
            var stoppedAtRow = Matrix.check(options.usage, m, 0, m.rows(), condition);
            if (stoppedAtRow !== -1) {
                return {
                    stoppedAtRow: stoppedAtRow,
                    matrix: m
                };
            }
        }
        return {
            stoppedAtRow: -1,
            matrix: m
        };
    };

    Matrix.toRowEchelonBackSubstitution = function(m, pivotRow, options) {
        // back-substitution
        if (options.method === Matrix.GaussJordan) {
            while (--pivotRow >= 0) {
                var pivotColumn = 0;
                while (pivotColumn < m.cols() && m.e(pivotRow, pivotColumn).equals(Expression.ZERO)) {
                    pivotColumn += 1;
                }
                if (pivotColumn < m.cols()) {
                    var targetRow = pivotRow;
                    while (--targetRow >= 0) {
                        if (!m.e(targetRow, pivotColumn).equals(Expression.ZERO)) {
                            var oldMatrix = m;
                            m = m.rowReduce(targetRow, pivotRow, pivotColumn);
                            if (options.callback != undefined) {
                                options.callback({
                                    previousPivot: undefined,
                                    newMatrix: m,
                                    oldMatrix: oldMatrix,
                                    type: "reduce",
                                    targetRow: targetRow,
                                    pivotRow: pivotRow,
                                    pivotColumn: pivotColumn
                                });
                            }
                        }
                    }
                }
            }
        }
        return m;
    };

    var isConditionValid = function(condition, matrix) {
        for (var i = 0; i < matrix.rows(); i++) {
            for (var j = 0; j < matrix.cols(); j++) {
                var e = matrix.e(i, j);
                if (!Polynomial._isIntegerLike(e)) {
                    if (Polynomial._isIntegerLike(e.getNumerator())) { //!!! for performance
                        e = e.getDenominator().inverse();
                    }
                    if (condition.andZero(e).isFalse() && condition.andNotZero(e).isFalse()) {
                        return false;
                    }
                }
            }
        }
        return true;
    };

    Matrix.Gauss = "Gauss";
    Matrix.GaussJordan = "Gauss-Jordan";
    Matrix.GaussMontante = "Gauss-Montante";

    function ToRowEchelonOptions(method, usage, callback) {
        if (usage !== "determinant" && usage !== "inverse" && usage !== "solving" && usage !== "LU-decomposition" && usage !== "" && usage !== "row-reduction") {
            throw new RangeError();
        }
        if (method !== Matrix.Gauss && method !== Matrix.GaussJordan && method !== Matrix.GaussMontante) {
            throw new RangeError();
        }
        this.method = method;
        this.usage = usage;
        this.callback = callback;
    }

    Matrix.ToRowEchelonOptions = ToRowEchelonOptions;

    // method === Matrix.GaussJordan - make zeros under diagonal and divide by pivot element, also swap row instead of addition
    // method === Matrix.Montante - https://es.wikipedia.org/wiki/M%C3%A9todo_Montante
    // private
    var COLUMN_LOOP = 0;
    var ZERO = 1;
    var NOT_ZERO = 2;
    Matrix.prototype.toRowEchelon = function(method, usage, callback) {
        var options = new Matrix.ToRowEchelonOptions(method, usage, callback);
        return this.toRowEchelonInternal(options, 0, -1, -1, Expression.ONE, COLUMN_LOOP, undefined);
    };
    Matrix.prototype.toRowEchelonXXX = function(method, usage, callback, condition) {
        var options = new Matrix.ToRowEchelonOptions(method, usage, callback);
        return this.toRowEchelonInternal(options, 0, -1, -1, Expression.ONE, COLUMN_LOOP, condition);
    };
    Matrix.prototype.toRowEchelonInternal = function(options, pivotRow, pivotColumn, pivotOriginRow, previousPivot, state, condition) {
        var matrix = this;

        //2018-09-29
        if (condition != undefined && !condition.isTrue()) {
            matrix = matrix.map(function(e, i, j) {
                // x == 0 && x**2 != 0 is false
                // x == 0 && x**2 == 0 is false
                // x == 0 && y/x != 0 is false
                // x == 0 && y/x == 0 is false
                return condition.updateExpression(e);
            });
            previousPivot = condition.updateExpression(previousPivot);
        }

        var stoppedAtRow = Matrix.check(options.usage, matrix, 0, matrix.rows(), condition);
        if (stoppedAtRow !== -1) {
            return {
                stoppedAtRow: stoppedAtRow,
                matrix: matrix,
                condition: condition
            };
        }
        if (false) {
            //TODO: remove
            //!2018-16-07 (from trash)
            if (options.usage === "solving" && pivotColumn === matrix.cols() - 1) {
                //TODO: test
                //TODO: test if condition == undefined
                var c = condition.andZero(matrix.e(pivotRow, pivotColumn));
                return {
                    stoppedAtRow: -1,
                    matrix: matrix,
                    condition: c
                };
            }
            //!
        }
        while (true) {
            switch (state) {
                case COLUMN_LOOP:
                    pivotColumn += 1;
                    if (pivotColumn >= matrix.cols()) {
                        matrix = Matrix.toRowEchelonBackSubstitution(matrix, pivotRow, options);
                        return {
                            stoppedAtRow: -1,
                            matrix: matrix,
                            condition: condition
                        };
                    }
                    if (pivotColumn > pivotRow && (options.usage === "determinant" || options.usage === "inverse")) {
                        if (pivotColumn >= Math.floor(matrix.cols() / 2) && options.usage === "inverse") { //TODO: fix
                            matrix = Matrix.toRowEchelonBackSubstitution(matrix, pivotRow, options);
                            return {
                                stoppedAtRow: -1,
                                matrix: matrix,
                                condition: condition
                            };
                        }
                        return {
                            stoppedAtRow: pivotRow,
                            matrix: matrix,
                            condition: condition
                        }; //? TODO: details - ?
                    }
                    pivotOriginRow = pivotRow - 1;
                    state = ZERO;
                    break;
                case ZERO:
                    // pivot searching
                    // not zero element in a column (starting from the main diagonal);
                    if (condition == undefined) {
                        pivotOriginRow += 1;
                        if (pivotOriginRow < matrix.rows()) {
                            if (matrix.e(pivotOriginRow, pivotColumn).equals(Expression.ZERO)) {
                                state = ZERO;
                            } else {
                                state = NOT_ZERO;
                            }
                        } else {
                            state = COLUMN_LOOP;
                        }
                    } else {
                        if (pivotOriginRow >= pivotRow) {
                            matrix = pivotRow >= matrix.rows() || matrix.e(pivotRow, pivotColumn).equals(Expression.ZERO) ? matrix : matrix.map(function(e, i, j) { //?
                                //return i === pivotOriginRow && j === pivotColumn ? Expression.ZERO : condition.updateExpression(e);
                                return condition.updateExpression(e);
                            });
                            previousPivot = condition.updateExpression(previousPivot);
                        }
                        var found = false;
                        if (pivotOriginRow === pivotRow - 1) { //!
                            var row = pivotRow;
                            while (row < matrix.rows() && !((condition.andZero(matrix.e(row, pivotColumn)).isFalse() || options.usage === "LU-decomposition") && !matrix.e(row, pivotColumn).equals(Expression.ZERO))) {
                                row += 1;
                            }
                            if (row < matrix.rows()) {
                                pivotOriginRow = row;
                                found = true;
                            }
                        } //!
                        if (!found) {
                            pivotOriginRow += 1;
                            if (pivotOriginRow < matrix.rows()) {
                                var candidate = matrix.e(pivotOriginRow, pivotColumn);
                                var c1 = condition.andNotZero(candidate);
                                var c2 = condition.andZero(candidate);

                                if (!c2.isFalse()) {
                                    //!new 2020-01-03
                                    // condition: r = 0, element = 1/r
                                    if (!isConditionValid(c2, matrix)) {
                                        debugger;
                                        c2 = Condition.FALSE; //!!!
                                        condition = c1; //!
                                    }
                                    //!
                                }

                                if (c2.isFalse()) {
                                    state = NOT_ZERO;
                                } else if (c1.isFalse()) {
                                    state = ZERO;
                                } else {
                                    if (options.usage === "row-reduction") {
                                        var tmp = Matrix.toRowEchelonStep(matrix, pivotRow, pivotColumn, pivotOriginRow, previousPivot, Object.assign({}, options, {
                                            callback: null
                                        }), condition);
                                        var m = tmp.matrix.slice(pivotOriginRow + 1, matrix.rows(), pivotColumn, matrix.cols()).map(function(e, i, j) {
                                            return c2.updateExpression(e);
                                        });
                                        if (m.eql(Matrix.Zero(m.rows(), m.cols()))) {
                                            return matrix.toRowEchelonInternal(options, pivotRow, pivotColumn, pivotOriginRow, previousPivot, NOT_ZERO, condition);
                                        }
                                    }
                                    return {
                                        matrix: matrix,
                                        c1: c1,
                                        a1: function() {
                                            return matrix.toRowEchelonInternal(options, pivotRow, pivotColumn, pivotOriginRow, previousPivot, NOT_ZERO, c1);
                                        },
                                        c2: c2,
                                        a2: function() {
                                            return matrix.toRowEchelonInternal(options, pivotRow, pivotColumn, pivotOriginRow, previousPivot, ZERO, c2);
                                        }
                                    };
                                }
                            } else {
                                state = COLUMN_LOOP;
                            }
                        } else {
                            state = NOT_ZERO;
                        }
                    }
                    break;
                case NOT_ZERO:
                    var tmp = Matrix.toRowEchelonStep(matrix, pivotRow, pivotColumn, pivotOriginRow, previousPivot, options, condition);
                    var stoppedAtRow = tmp.stoppedAtRow;
                    matrix = tmp.matrix;
                    if (stoppedAtRow !== -1) {
                        return {
                            stoppedAtRow: stoppedAtRow,
                            matrix: matrix,
                            condition: condition
                        };
                    }
                    previousPivot = matrix.e(pivotRow, pivotColumn);
                    pivotRow += 1;
                    state = COLUMN_LOOP;
                    break;
            }
        }
    };

    Matrix.prototype.determinant = function() { // m == n  // via row echelon form
        var n = this.rows();
        if (!this.isSquare() || n === 0) {
            throw new RangeError("NonSquareMatrixException");
        }
        if (false && !Expression.has(this.e(0, 0), Expression.Polynomial)) {
            var tmp = this.toRowEchelon(Matrix.Gauss, "determinant", undefined);
            var stoppedAtRow = tmp.stoppedAtRow;
            var rowEchelonMatrix = tmp.matrix;
            if (stoppedAtRow !== -1) {
                return Expression.ZERO;
            }
            var det = rowEchelonMatrix.e(0, 0);
            for (var j = 1; j < rowEchelonMatrix.rows(); j += 1) {
                det = det.multiply(rowEchelonMatrix.e(j, j));
            }
            return det;
        }
        var tmp = this.toRowEchelon(Matrix.GaussMontante, "determinant", undefined);
        var stoppedAtRow = tmp.stoppedAtRow;
        var rowEchelonMatrix = tmp.matrix;
        if (stoppedAtRow !== -1) {
            return Expression.ZERO;
        }
        return rowEchelonMatrix.e(n - 1, n - 1);
    };

    Matrix.prototype.rank = function() {
        // rank === count of non-zero rows after bringing to row echelon form ...
        //var m = this.toRowEchelon(Matrix.Gauss, "", undefined).matrix;
        var m = this.toRowEchelon(Matrix.GaussMontante, "", undefined).matrix;
        var result = 0;
        var pivotRow = 0;
        var pivotColumn = 0;
        while (pivotRow < m.rows()) {
            while (pivotColumn < m.cols() && m.e(pivotRow, pivotColumn).equals(Expression.ZERO)) {
                pivotColumn += 1;
            }
            if (pivotColumn < m.cols()) {
                result += 1;
            }
            pivotRow += 1;
        }
        return result;
    };

    Matrix.prototype.inverse = function() { // m == n by augmention ...
        if (!this.isSquare()) {
            throw new RangeError("NonSquareMatrixException");
        }
        if (this.rows() === 2) {
            var a = this.e(0, 0);
            var b = this.e(0, 1);
            var c = this.e(1, 0);
            var d = this.e(1, 1);
            var det = a.multiply(d).subtract(b.multiply(c));
            if (det.equals(Expression.ZERO)) {
                throw new RangeError("SingularMatrixException");
            }
            return Matrix.Zero(this.rows(), this.rows()).map(function(e, i, j) {
                return (i === 0 ? (j === 0 ? d : b.negate()) : (j === 0 ? c.negate() : a)).divide(det);
            });
        }
        var m = this.augment(Matrix.I(this.rows()));
        //m = m.toRowEchelon(Matrix.GaussJordan, "inverse", undefined).matrix;
        m = m.toRowEchelon(Matrix.GaussMontante, "inverse", undefined).matrix;

        return Matrix.Zero(m.rows(), m.rows()).map(function(element, i, j) { // splitting to get the second half
            var e = m.e(i, i);
            if (e.equals(Expression.ZERO)) {
                throw new RangeError("SingularMatrixException");
            }
            var x = m.e(i, j + m.rows());
            return e.equals(Expression.ONE) ? x : x.divide(e);
        });
    };

    Matrix.prototype.toString = function(options) {
        var result = "";
        var rows = this.rows();
        var cols = this.cols();
        if (rows === 0 && cols === 0) {
            throw new RangeError();
        }
        var j = -1;
        result += "{";
        while (++j < rows) {
            if (j !== 0) {
                result += ",";
            }
            result += "{";
            var i = -1;
            while (++i < cols) {
                if (i !== 0) {
                    result += ",";
                }
                result += this.e(j, i).toString(options);
            }
            result += "}";
        }
        result += "}";
        return result;
    };

    Matrix.prototype.negate = function() {
        return this.map(function(element, i, j) {
            return element.negate();
        });
    };

    Matrix.prototype.subtract = function(b) {
        return this.add(b.negate());
    };

    //?
    // returns an array of arrays of strings
    Matrix.prototype.getElements = function() {
        var rows = this.rows();
        var cols = this.cols();
        var elements = new Array(rows);
        for (var i = 0; i < rows; i += 1) {
            var row = new Array(cols);
            for (var j = 0; j < cols; j += 1) {
                row[j] = this.e(i, j).toString();
            }
            elements[i] = row;
        }
        return elements;
    };

    Matrix.prototype.slice = function(rowsStart, rowsEnd, colsStart, colsEnd) {
        var that = this;
        return Matrix.Zero(rowsEnd - rowsStart, colsEnd - colsStart).map(function(e, i, j) {
            return that.e(i + rowsStart, j + colsStart);
        });
    };

    //TODO:
    Matrix.prototype.isExact = function() {
        var rows = this.rows();
        var cols = this.cols();
        for (var i = 0; i < rows; i += 1) {
            for (var j = 0; j < cols; j += 1) {
                if (!this.e(i, j).isExact()) {
                    return false;
                }
            }
        }
        return true;
    };

    Matrix.prototype.eql = function(b) {
        var a = this;
        if (a.rows() !== b.rows() || a.cols() !== b.cols()) {
            return false;
        }
        for (var i = 0; i < a.rows(); i += 1) {
            for (var j = 0; j < a.cols(); j += 1) {
                if (!a.e(i, j).equals(b.e(i, j))) {
                    return false;
                }
            }
        }
        return true;
    };

    Matrix.prototype.pow = function(n) {
        if (!(n >= 0 && n <= Number.MAX_SAFE_INTEGER)) {
            throw new RangeError();
        }
        var pow = function(x, count, accumulator) {
            return (count < 1 ? accumulator : (2 * Math.floor(count / 2) !== count ? pow(x, count - 1, accumulator.multiply(x)) : pow(x.multiply(x), Math.floor(count / 2), accumulator)));
        };
        return pow(this, n, Matrix.I(this.rows()));
    };

    /*
    // TODO: remove
    Matrix.prototype.stripZeroRows = function () {
      var rows = this.rows();
      var cols = this.cols();
      var i = rows;
      var j = cols;
      while (j === cols && --i >= 0) {
        j = 0;
        while (j < cols && this.e(i, j).equals(Expression.ZERO)) {
          j += 1;
        }
      }
      i += 1;
      var that = this;
      return i === rows ? this : Matrix.Zero(i, cols).map(function (e, i, j) {
        return that.e(i, j);
      });
    };
    */

    // string -> array of array of strings, find `extraPositionOffset`
    Matrix.split = function(input) {
        input = input.replace(/\b(sin|cos)\x20/g, '$1\u200B');
        var result = [];
        var m = input;
        if (/^\s*\[[^\[\]]*\]\s*$/.exec(m) != undefined) { //!
            m = m.replace(/\[/g, " ");
            m = m.replace(/\]/g, " ");
        } //!
        if (m.replace(/^\s+|\s+$/g, "") !== "") {
            m = m.replace(/;/g, "\n"); //? ; -> \n
            m = m.replace(/\r/g, "\n");
            var row = [];
            result.push(row);
            var position = 0;
            var match = undefined;
            while ((match = /^\s*\S+/.exec(m.slice(position))) != undefined) {
                var t = match[0];
                if (t.indexOf("\n") !== -1 && row.length !== 0) {
                    row = [];
                    result.push(row);
                    t = t.replace(/\n/g, " ");
                }
                row.push(t);
                position += t.length;
            }
        }
        return result;
    };

    Matrix.padRows = function(array, convertFunction) {
        var rows = array.length;
        var cols = 0;
        for (var k = 0; k < array.length; k += 1) {
            cols = Math.max(cols, array[k].length);
        }
        var data = new Array(rows);
        for (var i = 0; i < rows; i += 1) {
            var y = array[i];
            var x = new Array(cols);
            for (var j = 0; j < cols; j += 1) {
                x[j] = j < y.length ? (convertFunction != null ? convertFunction(y[j]) : y[j]) : Expression.ZERO;
            }
            data[i] = x;
        }
        return new Matrix(data);
    };

    Matrix.solveByGaussNext = function(m, callback) {
        var pivotRows = new Array(m.cols() - 1);
        for (var k = 0; k < m.cols() - 1; k += 1) {
            pivotRows[k] = -1;
        }
        for (var i = m.rows() - 1; i >= 0; i -= 1) {
            var j = 0;
            while (j < m.cols() - 1 && m.e(i, j).equals(Expression.ZERO)) {
                j += 1;
            }
            // first not zero in a row - main variable
            if (j < m.cols() - 1) {
                pivotRows[j] = i;
                var oldMatrix1 = m;
                // reduce i-th row
                for (var k = j + 1; k < m.cols() - 1; k += 1) {
                    if (!m.e(i, k).equals(Expression.ZERO)) {
                        var pivotRow = pivotRows[k];
                        if (pivotRow !== -1) {
                            m = m.rowReduce(i, pivotRow, k);
                        }
                    }
                }
                var oldMatrix2 = m;
                // divide i-th row by m.e(i, j)
                if (!m.e(i, j).equals(Expression.ONE)) {
                    var c = m.e(i, j);
                    m = m.map(function(e, row, column) {
                        return row === i ? e.divide(c) : e;
                    });
                }
                if (callback != undefined) {
                    callback(m, oldMatrix1, oldMatrix2, i, j);
                }
            }
        }
        return m;
    };

    //TODO: ?
    Matrix.getPivotRow = function(m, k) {
        var i = m.rows() - 1;
        while (i >= 0 && m.e(i, k).equals(Expression.ZERO)) {
            i -= 1;
        }
        if (i >= 0) {
            var j = k - 1;
            while (j >= 0 && m.e(i, j).equals(Expression.ZERO)) {
                j -= 1;
            }
            if (j < 0) {
                return i;
            }
        }
        return -1;
    };

    //TODO: fix
    Matrix.getSolutionSet = function(m) {
        var result = {
            basisVectors: [],
            variables: []
        };
        for (var k = 0; k < m.cols() - 1; k += 1) {
            if (Matrix.getPivotRow(m, k) === -1) {
                // a basis vector for k-th variable
                var bx = new Array(m.cols() - 1);
                for (var j = 0; j < m.cols() - 1; j += 1) {
                    var i = Matrix.getPivotRow(m, j); // a solution row for j-th variable, -1 if it is a free variable
                    bx[j] = i !== -1 ? m.e(i, k).negate() : (j === k ? Expression.ONE : Expression.ZERO);
                }
                var basisVector = new Vector(bx);
                result.basisVectors.push(basisVector);
                result.variables.push(k);
            }
        }
        return result;
    };

    Matrix.prototype.minorMatrix = function(k, l) {
        var that = this;
        return Matrix.Zero(this.rows() - 1, this.cols() - 1).map(function(e, i, j) {
            return that.e(i < k ? i : i + 1, j < l ? j : j + 1);
        });
    };

    Matrix.toRowEchelonWithCallback = function(matrix, method, usage, changeCallback, resultCallback) {
        var result = matrix.toRowEchelonXXX(method, usage, changeCallback, Condition.TRUE);
        var w = function(result) {
            if (result.c1 == undefined && result.c2 == undefined) {
                resultCallback(result);
            } else {
                w(result.a1());
                w(result.a2());
            }
        };
        w(result);
    };

    Matrix.prototype.isDiagonal = function() {
        return this.eql(this.map(function(e, i, j) {
            return i !== j ? Expression.ZERO : e;
        }));
    };
    Matrix.prototype.isScalar = function() {
        var that = this;
        return this.eql(this.map(function(e, i, j) {
            return i !== j ? Expression.ZERO : that.e(0, 0);
        }));
    };
    Matrix.prototype.isNilpotent = function() {
        var x = this.map(function(e, i, j) {
            return j <= i ? Expression.ZERO : e;
        });
        if (this.eql(x)) {
            //! This method only tests if it nilpotent based on a property and so may return false for the positive result
            return true;
        }
        //TODO: test case for non-triangular - ?
        return this.pow(this.cols()).eql(Matrix.Zero(this.cols(), this.cols()));
    };
    //TODO: use in solution steps (?)
    Matrix.prototype.isJordanMatrix = function() { //TODO: fix
        var that = this;
        return this.eql(this.map(function(e, i, j) {
            return i === j ? e : (j === i + 1 && that.e(i, i).equals(that.e(i + 1, i + 1)) && !that.e(i, j).equals(Expression.ZERO) ? Expression.ONE : Expression.ZERO);
        }));
    };
    Matrix.prototype.isZero = function() {
        return this.eql(Matrix.Zero(this.rows(), this.cols()));
    };

    function Vector(elements) {
        this.elements = elements;
    }

    Vector.prototype.e = function(index) {
        return this.elements[index];
    };

    Vector.prototype.dimensions = function() {
        return this.elements.length;
    };

    //TODO: ?
    Vector.prototype.rows = function() {
        return this.dimensions();
    };
    Vector.prototype.cols = function() {
        return 1;
    };
    Vector.prototype.isExact = function() {
        for (var i = 0; i < this.dimensions(); i += 1) {
            if (!this.e(i).isExact()) {
                return false;
            }
        }
        return true;
    };

    Vector.prototype.toString = function(options) {
        return Matrix.prototype.toString.call(this, options);
    };

    Vector.prototype.dot = function(other) {
        var result = Expression.ZERO;
        for (var i = 0; i < Math.max(this.dimensions(), other.dimensions()); i += 1) {
            var s = this.e(i).multiply(other.e(i).complexConjugate());
            result = result === Expression.ZERO ? s : result.add(s);
        }
        return result;
    };
    Vector.prototype.toUnitVector = function() {
        var norm = this.dot(this).squareRoot();
        return this.scale(norm.inverse());
    };

    Vector.prototype.scale = function(s) {
        return new Vector(this.elements.map(function(e) {
            return s.multiply(e);
        }));
    };
    Vector.prototype.subtract = function(other) {
        if (this.dimensions() !== other.dimensions()) {
            throw new RangeError("MatrixDimensionMismatchException");
        }
        var n = this.dimensions();
        var result = new Array(n);
        for (var i = 0; i < n; i += 1) {
            result[i] = this.e(i).subtract(other.e(i));
        }
        return new Vector(result);
    };

    Vector.prototype.eql = function(other) {
        if (this.dimensions() !== other.dimensions()) {
            throw new RangeError("MatrixDimensionMismatchException");
        }
        var n = this.dimensions();
        for (var i = 0; i < n; i += 1) {
            if (!this.e(i).equals(other.e(i))) {
                return false;
            }
        }
        return true;
    };
    Vector.Zero = function(n) {
        return new Vector(new Array(n).fill(Expression.ZERO));
    };

    Matrix.Vector = Vector;

    Matrix.prototype.row = function(i) {
        var elements = new Array(this.cols());
        for (var j = 0; j < this.cols(); j += 1) {
            elements[j] = this.e(i, j);
        }
        return new Vector(elements);
    };
    Matrix.prototype.col = function(j) {
        var elements = new Array(this.rows());
        for (var i = 0; i < this.rows(); i += 1) {
            elements[i] = this.e(i, j);
        }
        return new Vector(elements);
    };

    self.Matrix = Matrix;

})();
(function() {
    "use strict";

    // https://lowrey.me/es6-javascript-combination-generator/
    // https://www.npmjs.com/package/combinations-generator

    function combinations(elements, k) {
        var n = elements.length;
        var indexes = new Array(k + 1).fill(-1);
        var result = new Array(k).fill(undefined);
        var depth = 0;
        var iterator = {
            next: function() {
                while (depth >= 0) {
                    if (depth < k) {
                        var i = indexes[depth];
                        if (i < n - k + depth) {
                            indexes[depth] = i + 1;
                            result[depth] = elements[i + 1];
                            depth += 1;
                            indexes[depth] = i + 1;
                        } else {
                            depth -= 1;
                        }
                    } else {
                        depth -= 1;
                        return {
                            value: result.slice(0),
                            done: false
                        };
                    }
                }
                return {
                    value: undefined,
                    done: true
                };
            }
        };
        iterator[globalThis.Symbol.iterator] = function() {
            return this;
        };
        return iterator;
    }

    self.combinations = combinations;

})();
(function() {
    "use strict";


    function modulo(a, b) {
        var x = a % b;
        if (x < 0) {
            x += b; // assuming b > 0
        }
        return x;
    }

    function check(number) {
        if (typeof number !== "number" || Math.abs(number) > Number.MAX_SAFE_INTEGER) {
            throw new RangeError();
        }
    }

    function schoolbook(a, b) {
        var c = new Array(a.length === 0 || b.length === 0 ? 0 : (a.length - 1 + b.length - 1 + 1));
        for (var i = 0; i < c.length; i++) {
            var from = Math.max(0, i - (b.length - 1));
            var to = Math.min(i, a.length - 1);
            var s = a[from] * b[i - from];
            for (var j = from + 1; j <= to; j++) {
                s += a[j] * b[i - j];
            }
            c[i] = s;
        }
        return c;
    }

    function absMax(array) {
        var max = 0;
        for (var i = 0; i < array.length; i++) {
            max = Math.max(max, Math.abs(array[i]));
        }
        return max;
    }

    function multiply(A, B) {
        check(absMax(A) * absMax(B) * Math.min(A.length, B.length));
        return schoolbook(A, B);
    }

    function IntPolynomial(coefficients) {
        var k = coefficients.length;
        while (k > 0 && coefficients[k - 1] == 0) {
            k -= 1;
        }
        coefficients.length = k;
        check(absMax(coefficients));
        this.coefficients = coefficients;
    }
    IntPolynomial.prototype.add = function(other) {
        var a = this.coefficients;
        var b = other.coefficients;
        var c = new Array(Math.max(a.length, b.length));
        for (var i = 0; i < c.length; i += 1) {
            if (i < a.length && i < b.length) {
                c[i] = a[i] + b[i];
            } else if (i < a.length) {
                c[i] = a[i];
            } else {
                c[i] = b[i];
            }
        }
        return new IntPolynomial(c);
    };;
    IntPolynomial.prototype.subtract = function(other) {
        return this.add(other.negate());
    };
    IntPolynomial.prototype.multiply = function(other) {
        var a = this.coefficients;
        var b = other.coefficients;
        return new IntPolynomial(multiply(a, b));
    };
    IntPolynomial.prototype.divideAndRemainderModP = function(other, m) {
        var a = this.coefficients;
        var b = other.coefficients;
        if (a.length < b.length) {
            return {
                quotient: new IntPolynomial([]),
                remainder: this.mod(m)
            };
        }
        if (b.length === 0) {
            throw new RangeError();
        }
        var lc = b[b.length - 1];
        if (lc != 1) {
            throw new RangeError();
        }
        check(m * m * b.length);
        var remainder = new Array(a.length);
        for (var i = 0; i < a.length; i++) {
            remainder[i] = a[i];
        }
        var remainderDegree = remainder.length - 1;
        var quotient = new Array(a.length - b.length + 1);
        var zero = lc - lc;
        for (var i = 0; i < quotient.length; i++) {
            quotient[i] = zero;
        }
        while (remainderDegree >= b.length - 1) {
            var n = remainderDegree - b.length + 1;
            var q = modulo(remainder[remainderDegree], m);
            quotient[n] = q;
            if (q != 0) {
                if (q == 1) {
                    for (var j = 0; j < b.length; j += 1) {
                        remainder[j + n] -= b[j];
                    }
                } else {
                    for (var j = 0; j < b.length; j += 1) {
                        remainder[j + n] -= q * b[j];
                    }
                }
            }
            while (remainderDegree >= 0 && modulo(remainder[remainderDegree], m) == 0) {
                remainder[remainderDegree] = zero;
                remainderDegree -= 1;
            }
        }
        for (var j = 0; j <= remainderDegree; j += 1) {
            remainder[j] = modulo(remainder[j], m);
        }
        return {
            quotient: new IntPolynomial(quotient),
            remainder: new IntPolynomial(remainder)
        };
    };
    IntPolynomial.prototype.negate = function(s) {
        return new IntPolynomial(this.coefficients.map(function(c) {
            return (c - c) - c;
        }));
    };
    IntPolynomial.prototype.scale = function(s) {
        return new IntPolynomial(this.coefficients.map(function(c) {
            return c * s;
        }));
    };
    IntPolynomial.prototype.getDegree = function() {
        return this.coefficients.length - 1;
    };
    IntPolynomial.prototype.getLeadingCoefficient = function() {
        if (this.coefficients.length === 0) {
            throw new RangeError();
        }
        return this.coefficients[this.coefficients.length - 1];
    };
    IntPolynomial.prototype.getCoefficient = function(degree) {
        if (degree >= this.coefficients.length) {
            throw new RangeError();
        }
        return this.coefficients[degree];
    };
    IntPolynomial.prototype.derive = function(p) {
        var c = new Array(this.coefficients.length - 1);
        for (var i = 0; i < c.length; i += 1) {
            c[i] = (i + 1) * this.coefficients[i + 1];
        }
        return new IntPolynomial(c);
    };
    IntPolynomial.prototype.mod = function(p) {
        return new IntPolynomial(this.coefficients.map(function(c) {
            return modulo(c, p);
        }));
    };
    IntPolynomial.prototype.toString = function() {
        var s = '';
        var c = this.coefficients;
        for (var i = c.length - 1; i >= 0; i--) {
            s += (c[i] >= 0 && i !== c.length ? '+' : '');
            s += c[i].toString();
            if (i === 1) {
                s += 'x';
            } else if (i !== 0) {
                s += 'x^';
                s += i;
            }
        }
        return s;
    };
    IntPolynomial.from = function(coefficients) {
        return new IntPolynomial(coefficients);
    };

    self.IntPolynomial = IntPolynomial;

})();
(function() {
    "use strict";





    //?

    function toInt(c, p) {
        if (p instanceof Expression.Integer) {
            return Expression.Integer.fromBigInt(c);
        }
        return c;
    }

    function fromInt(c) {
        if (c instanceof Expression.Integer) {
            return c;
        }
        return Expression.Integer.fromBigInt(c);
    }

    function toIntPolynomial(f, p) {
        if (p instanceof Expression.Integer) {
            return f.mod(p);
        }
        var ep = Expression.Integer.fromBigInt(p);
        var coefficients = new Array(f.getDegree() + 1);
        for (var i = 0; i < coefficients.length; i += 1) {
            coefficients[i] = f.getCoefficient(i).modulo(ep).toBigInt();
        }
        return IntPolynomial.from(coefficients);
    }

    function fromIntPolynomial(f) {
        var coefficients = new Array(f.getDegree() + 1);
        for (var i = 0; i < coefficients.length; i += 1) {
            coefficients[i] = Expression.Integer.fromBigInt(f.getCoefficient(i));
        }
        return Polynomial.from(coefficients);
    }

    // Books:
    // Henri Cohen "A Course in Computational Algebraic Number Theory"
    // "Computer algebra and symbolic computation Mathematical Methods" Joel S. Cohen
    // "The art of computer programming. Vol.2: Seminumerical algorithms" Donald E. Knuth
    // https://en.wikipedia.org/wiki/Finite_field
    // https://en.wikipedia.org/wiki/Factorization_of_polynomials_over_finite_fields
    // https://en.wikipedia.org/wiki/Factorization_of_polynomials#Factoring_univariate_polynomials_over_the_integers


    var isPrime = primeFactor._isPrime;

    function ExtendedEuclideanAlgorithm(A, B, p) {
        // U * A + V * B = gcd(A, B) (mod p)
        A = A.mod(p);
        B = B.mod(p);
        // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Pseudocode
        var $newold_r = A;
        var $newr = B;
        var old_r = $newold_r;
        var r = $newr;
        var ZERO = Polynomial.of(Expression.ZERO);
        var ONE = Polynomial.of(p.divide(p)); //TODO: ?
        var $newold_s = ONE;
        var $news = ZERO;
        var old_s = $newold_s;
        var s = $news;
        var $newold_t = ZERO;
        var $newt = ONE;
        var old_t = $newold_t;
        var t = $newt;
        while (r.getDegree() >= 0) {
            var multiplier = r.getLeadingCoefficient().modInverse(p);
            var tmp = old_r.scale(multiplier).mod(p).divideAndRemainderModP(r.scale(multiplier).mod(p), p);
            var quotient = tmp.quotient;
            //var $newold_r = r; var $newr =  old_r.subtract(quotient.multiply(r)).mod(p); old_r = $newold_r; r = $newr;
            var $newold_r = r;
            var $newr = tmp.remainder.scale(r.getLeadingCoefficient()).mod(p);
            old_r = $newold_r;
            r = $newr;
            var $newold_s = s;
            var $news = old_s.subtract(quotient.multiply(s)).mod(p);
            old_s = $newold_s;
            s = $news;
            var $newold_t = t;
            var $newt = old_t.subtract(quotient.multiply(t)).mod(p);
            old_t = $newold_t;
            t = $newt;
        }
        var k = old_r.getLeadingCoefficient().modInverse(p);
        var gcd = old_r.scale(k).mod(p);
        var U = old_s.scale(k).mod(p);
        var V = old_t.scale(k).mod(p);
        return {
            U: U,
            V: V,
            gcd: gcd
        };
    }

    // https://en.wikipedia.org/wiki/Factorization_of_polynomials_over_finite_fields#Equal-degree_factorization

    function modPow(polynomial, n, m, q) {
        var p = polynomial;
        var accumulator = null;
        while (!n.equals(Expression.ZERO)) {
            if (!n.remainder(Expression.TWO).equals(Expression.ZERO)) {
                n = n.subtract(Expression.ONE);
                if (accumulator == null) {
                    accumulator = p;
                } else {
                    accumulator = accumulator.multiply(p).mod(q).divideAndRemainderModP(m, q).remainder;
                }
            } else {
                n = n.truncatingDivide(Expression.TWO);
                p = p.multiply(p).mod(q).divideAndRemainderModP(m, q).remainder;
            }
        }
        return accumulator;
    }

    function distinctDegreeFactorization(f, p) {
        f = f.mod(p);
        // copy-paste of pseudo code from Wikipedia - https://en.wikipedia.org/wiki/Factorization_of_polynomials_over_finite_fields#Distinct-degree_factorization
        var i = 1;
        var S = [];
        var fStar = f;
        fStar = toMonic(fStar, p);
        var q = p;
        var x = f.constructor.from([toInt(0, p), toInt(1, p)]); //TODO: ?
        var xInQInI = modPow(x, fromInt(q), fStar, q); // x**(q**i)
        while (fStar.getDegree() >= 2 * i) {
            //TODO: see the Wikipedia page for some optimizations - ?
            var h = xInQInI.subtract(x).divideAndRemainderModP(fStar, q).remainder;
            var g = gcdOfPolynomialsOverFiniteField(fStar, h, q);
            if (g.getDegree() !== 0) {
                S.push({
                    factor: g,
                    degree: i
                });
                fStar = fStar.divideAndRemainderModP(g, q).quotient;
            }
            i = i + 1;
            xInQInI = modPow(xInQInI, fromInt(q), fStar, q);
        }
        if (fStar.getDegree() > 0) {
            S.push({
                factor: fStar,
                degree: fStar.getDegree()
            });
        }
        if (S.length === 0) {
            S.push({
                factor: f,
                degree: 1
            });
        }
        return S;
    }

    function randomBigInt0(size, random) {
        random = random == undefined ? Math.random : random;

        console.assert(Math.floor(size) === size);
        if (size <= 52) {
            return Math.floor(random() * Math.pow(2, size));
        }
        var q = Math.ceil(size / (2 * 52)) * 52;
        return (BigInt(randomBigInt0(size - q, random)) << BigInt(q)) + BigInt(randomBigInt0(q, random));
    }

    // [0; max - 1]
    function randomBigInt(max, random) {
        random = random == undefined ? Math.random : random;

        if (Number(max) <= Math.pow(2, 52)) {
            return Math.floor(random() * Number(max));
        }
        var size = Expression.Integer.fromBigInt(max).bitLength();
        return (BigInt(randomBigInt0(size, random)) * BigInt(max)) >> BigInt(size);
    }

    function CantorZassenhausAlgorithm(f, p, factorsDegree) {
        f = f.mod(p);
        f = toMonic(f, p); //TODO: is it needed here, test - ?
        // copy-paste of pseudo code from Wikipedia - https://en.wikipedia.org/wiki/Factorization_of_polynomials_over_finite_fields#Cantor–Zassenhaus_algorithm
        var n = f.getDegree();
        var d = factorsDegree;
        var r = n / d;
        var q = p;
        var Factors = [];
        Factors.push(f);
        var random = Math.seedrandom != null ? new Math.seedrandom('hello.') : Math.random;
        while (Factors.length < r) {
            var h = f.constructor.from(new Array(n).fill(q).map(function(q) {
                return toInt(randomBigInt(fromInt(q).toBigInt(), random), q);
            }));
            var ONE = f.constructor.from([toInt(1, p)]);
            var qInDminusOneOverTwo = (fromInt(q)._pow(d).subtract(Expression.ONE)).truncatingDivide(Expression.TWO);
            var g = modPow(h, qInDminusOneOverTwo, f, q).subtract(ONE).divideAndRemainderModP(f, q).remainder;
            var updatedFactors = [];
            for (var iteratoru = Factors[globalThis.Symbol.iterator](), u = iteratoru.next().value; u != null; u = iteratoru.next().value) {
                var gcd = gcdOfPolynomialsOverFiniteField(g, u, q);
                if (gcd.getDegree() !== 0 && gcd.getDegree() !== u.getDegree()) {
                    updatedFactors.push(gcd);
                    updatedFactors.push(u.divideAndRemainderModP(gcd, q).quotient);
                } else {
                    updatedFactors.push(u);
                }
            }
            Factors = updatedFactors;
        }
        return Factors;
    }

    function factorizeOverTheFiniteField(f, p) {
        if (!isFactorizationOverZpSquareFree(f, p)) {
            throw new RangeError("implemented only for square-free polynomials");
        }
        var factorization = [];
        var distinctDegreeFactors = distinctDegreeFactorization(f, p);
        for (var iteratorddf = distinctDegreeFactors[globalThis.Symbol.iterator](), ddf = iteratorddf.next().value; ddf != null; ddf = iteratorddf.next().value) {
            var equalDegreeFactors = CantorZassenhausAlgorithm(ddf.factor, p, ddf.degree);
            factorization = factorization.concat(equalDegreeFactors);
        }
        return factorization;
    }

    function toMonic(f, p) {
        if (f.getDegree() < 0) {
            return f;
        }
        var scale = toInt(fromInt(f.getLeadingCoefficient()).modInverse(fromInt(p)).toBigInt(), p);
        return f.scale(scale).mod(p);
    }



    function gcdOfPolynomialsOverFiniteField(a, b, p) {
        a = a.mod(p); //?
        b = b.mod(p); //?
        b = toMonic(b, p);
        while (b.getDegree() >= 0) {
            var r = a.divideAndRemainderModP(b, p).remainder;
            r = toMonic(r, p);
            a = b;
            b = r;
        }
        return a;
    }

    function _gcdOfPolynomialsOverFiniteField0(a, b, p) {
        return fromIntPolynomial(gcdOfPolynomialsOverFiniteField(toIntPolynomial(a, p), toIntPolynomial(b, p), p));
    }

    function isFactorizationOverZpSquareFree(u, prime) {
        var f = u;
        return gcdOfPolynomialsOverFiniteField(f, f.derive().mod(prime), prime).getDegree() === 0;
    }

    // The art of computer programming. Vol.2: Seminumerical algorithms, page 452
    function factorizeOverTheIntegers(u, useHenselLifting) {
        useHenselLifting = useHenselLifting == undefined ? true : useHenselLifting;

        //if (u.toString() === '1471566513477172834305399948590466009*x^36-211905577940712888139977592597027105296*x^34+13129986163287865167531292496146540399224*x^32-462939766422599809806997255332437328597216*x^30+10362430845905260438547837088962342900036976*x^28-155683443407207896942716489327940147108629120*x^26+1618556951246037407274416866201451391464784384*x^24-11830632228190604908249839266002717097001139200*x^22+61153871177545784578882242689870006264757876480*x^20-223152626999418063421149667823603202136231649280*x^18+570260219818484251015463882930738160317054441472*x^16-1007187648191427638267502108195308402754856378368*x^14+1207581236321353649337451225242701250021029548032*x^12-959457354479765675976827753329438931015039090688*x^10+487489052553389695914981886297548193964734087168*x^8-149263610192452471565789533727206449715567656960*x^6+24608195620710414500859286809189277514021732352*x^4-1679911046068335257837067359574057455871590400*x^2+13348232781789541344412108782227014287360000') debugger;
        var polynomial = u;
        if (u.getCoefficient(0).equals(Expression.ZERO)) {
            return Polynomial.of(Expression.ZERO, Expression.ONE);
        }
        if (u.getCoefficient(0).abs().bitLength() - u.getLeadingCoefficient().abs().bitLength() < -50) { //?
            var factor = factorizeOverTheIntegers(u._exponentiateRoots(-1), useHenselLifting);
            return factor == null ? null : factor._exponentiateRoots(-1);
        }
        var checkBothVariants = true;
        var getBound = function(p) {
            if (checkBothVariants) {
                return Math.min(p._log2OfBoundForCoefficientsOfFactor(Math.floor(p.getDegree() / 2), p.getLeadingCoefficient().abs()),
                    p._log2OfBoundForCoefficientsOfFactor(p.getDegree(), p.getLeadingCoefficient().abs()._integerNthRoot(2)));
            }
            return p._log2OfBoundForCoefficientsOfFactor(p.getDegree(), p.getLeadingCoefficient().abs());
        };
        var B = Math.min(getBound(u), getBound(u._exponentiateRoots(-1))); //TODO: REMOVE

        var prime = 0;
        var nextGoodPrime = function(integer) {
            var p = integer;
            var pp = p;
            do {
                do {
                    p = Expression.Integer.fromBigInt(p).add(Expression.TWO).toBigInt();
                } while (!isPrime(p));
                if (!useHenselLifting) {
                    pp = Expression.Integer.fromBigInt(p);
                } else {
                    pp = p;
                }
            } while (u.getLeadingCoefficient().remainder(Expression.Integer.fromBigInt(p)).equals(Expression.ZERO) || !isFactorizationOverZpSquareFree(toIntPolynomial(u, pp), pp));
            return pp;
        };
        var log2 = function(b) {
            //TODO: ?
            var e = b.bitLength();
            return Math.log2(b.truncatingDivide(Expression.TWO._pow(Math.max(0, e - 53))).toNumber()) + Math.max(0, e - 53);
        };
        //var useHenselLifting = true;//TODO: ?
        if (!useHenselLifting) {
            prime = nextGoodPrime(Expression.TWO._pow(Math.ceil(1 + log2(u.getLeadingCoefficient().abs()) + B)).add(Expression.ONE).toBigInt());
        } else {
            prime = nextGoodPrime(1);
        }
        var tryMultiplePrimes = !useHenselLifting ? 0 : 2;
        if (tryMultiplePrimes !== 0) {
            var best = prime;
            var bestFactorsNumber = 1 / 0;
            for (var tries = 0; tries < tryMultiplePrimes; tries += 1) {
                var factorsNumber = 0;
                var ddfs = distinctDegreeFactorization(toIntPolynomial(u, prime), prime);
                for (var iteratorentry = ddfs[globalThis.Symbol.iterator](), entry = iteratorentry.next().value; entry != null; entry = iteratorentry.next().value) {
                    factorsNumber += (entry.factor.getDegree() / entry.degree);
                }
                if (bestFactorsNumber > factorsNumber) {
                    best = prime;
                    bestFactorsNumber = factorsNumber;
                }
                prime = nextGoodPrime(prime);
            }
            prime = best;
        }
        var factors = factorizeOverTheFiniteField(toIntPolynomial(u, prime), prime).map(function(factor) {
            return useHenselLifting ? fromIntPolynomial(factor) : factor;
        });

        if (u.isEven() && factors.length > 3) { // https://math.stackexchange.com/a/2894104
            var f = factorizeOverTheIntegers(u._exponentiateRoots(2));
            if (f != null) {
                return f._exponentiateRoots(1 / 2);
            }
            // see below
        }

        var q = 0;
        if (useHenselLifting) {
            var e = Math.ceil((1 + log2(u.getLeadingCoefficient().abs()) + B) / Math.log2(prime));
            //if (useQuadraticHenselLift) {
            //  e = Math.pow(2, Math.ceil(Math.log2(e)));
            //}
            var p = Expression.Integer.fromNumber(prime);
            factors[factors.length - 1] = factors[factors.length - 1].scale(u.getLeadingCoefficient().modulo(p)).mod(p);
            factors = HenselLifting(u, factors, p, e);
            q = p._pow(e);
            factors = factors.map(function(factor) {
                return factor.scale(factor.getLeadingCoefficient().modulo(q).modInverse(q)).mod(q);
            }); //TODO: ?
        } else {
            q = prime;
        }

        //!new 2022-07-27
        if (u.isEven() && factors.length > 3) { // https://math.stackexchange.com/a/2894104
            // see above
            for (var i = 0; i < factors.length; i += 1) {
                if (factors[i] != null) {
                    var f1 = factors[i].mod(q);
                    var f2 = factors[i]._scaleRoots(Expression.ONE.negate()).mod(q);
                    var found = false;
                    for (var j = i + 1; j < factors.length && !found; j += 1) {
                        if (factors[j] != null && factors[j].mod(q).equals(f2)) {
                            factors[j] = null;
                            found = true;
                        }
                    }
                    if (!found) {
                        //debugger;
                        return null;
                    }
                }
            }
            factors = factors.filter(function(f) {
                return f != null;
            });
            for (var i = 0; i < Math.pow(2, factors.length - 1); i += 1) {
                var candidate = productModQ(factors.map(function(f, index) {
                    return Math.floor(i / Math.pow(2, index)) % 2 === 0 ? f : f._scaleRoots(Expression.ONE.negate());
                }), q).scale(u.getLeadingCoefficient()).mod2(q).primitivePart();
                var tmp = u.divideAndRemainder(candidate, "undefined");
                if (tmp != undefined && tmp.remainder.getDegree() < 0) {
                    return candidate;
                }
            }
            return null;
        }

        //!!! (number of factors depends on the choise of prime numbers)
        //TODO: how to reduce number of iterations (?) (see Donald Knuth's book)
        var c = 0;
        for (var countOfFactors = 1; countOfFactors <= (checkBothVariants ? factors.length - 1 : Math.floor(factors.length / 2)); countOfFactors += 1) {
            var combinationsIterator = combinations(factors, countOfFactors);
            var combination = null;
            while ((combination = combinationsIterator.next().value) != null) {
                c += 1;
                var lc = u.getLeadingCoefficient();
                // an optimization from the Donald Knuth's book, page 452
                var productTrailingCoefficient = lc;
                for (var iteratorf = combination[globalThis.Symbol.iterator](), f = iteratorf.next().value; f != null; f = iteratorf.next().value) {
                    productTrailingCoefficient = productTrailingCoefficient.multiply(f.getCoefficient(0)).modulo(q);
                }
                productTrailingCoefficient = Polynomial.of(productTrailingCoefficient).mod2(q).getCoefficient(0);
                if (u.getCoefficient(0).multiply(lc).remainder(productTrailingCoefficient).equals(Expression.ZERO)) {
                    var v = productModQ(combination, q);
                    console.assert(v.getLeadingCoefficient().equals(Expression.ONE));
                    v = v.scale(lc);
                    v = v.mod2(q);
                    //TODO: test, we need to try w(x) = productModQ(factors.filter(function (factor) { return combination.indexOf(factor) === -1; }), q) as well (see Donald Knuth's book) - ?
                    console.assert(v.getDegree() < u.getDegree());
                    //if (v.getDegree() <= u.getDegree() / 2 || v.getDegree() < u.getDegree()) {
                    //v = v.primitivePart();
                    var tmp = u.scale(lc).divideAndRemainder(v, "undefined");
                    if (tmp != undefined && tmp.remainder.getDegree() < 0) {
                        v = v.primitivePart();
                        factors = factors.filter(function(factor) {
                            return combination.indexOf(factor) === -1;
                        });
                        combinationsIterator = combinations(factors, countOfFactors); //!?
                        u = tmp.quotient;
                        return v;
                    }
                    //}
                }
            }
        }
        if (c > 16) {
            console.debug(c);
        }
        if (polynomial.subtract(u).getDegree() >= 0) {
            u = u.primitivePart(); //?
            return u;
        }
        return null;
    }

    // if q == p, then C = A * B (mod p) -> A1 * B1 (mod p**2), A1 = A (mod p) and B1 = B (mod p)
    function HenselLift(C, A, B, U, V, q, p) { // q -> q * p
        // C = A * B mod p
        /*
        // https://www.csd.uwo.ca/~mmorenom/CS874/Lectures/Newton2Hensel.html/node17.html#eq:FactorizationLiftingProblem
        //C = C.map(function (c) { return new IntegerModuloPrimeNumber(c, Expression.Integer.fromBigInt(p**2)); })
        //TODO: ?
        var e = C.subtract(A.multiply(B));
        var A1 = A.add(U.multiply(e));
        var B1 = B.add(V.multiply(e));
        return {A1: A1, B1: B1};
        */
        // http://tomlr.free.fr/Math%E9matiques/Math%20Complete/Number%20theory/A%20course%20in%20computational%20algebraic%20number%20theory%20-%20Cohen%20H..pdf
        // Algorithm 3.5.5 (Hensel Lift).
        // A,B,C are polynomials over Integers:
        //console.assert(A.hasIntegerCoefficients());
        //console.assert(B.hasIntegerCoefficients());
        //console.assert(C.hasIntegerCoefficients());
        console.assert(q.isDivisibleBy(p));
        //C = C.mod(q.multiply(p));//TODO: ???
        var f = C.subtract(A.multiply(B)).scale(q.inverse()).mod(p);
        var tmp = V.multiply(f).mod(p).divideAndRemainderModP(A.mod(p), p);
        var t = tmp.quotient;
        //var A0 = V.multiply(f).subtract(A.multiply(t)).mod(p);
        var A0 = tmp.remainder;
        var B0 = U.multiply(f).add(B.mod(p).multiply(t)).mod(p);
        var A1 = A.add(A0.scale(q));
        var B1 = B.add(B0.scale(q));
        return [A1.mod(q.multiply(p)), B1.mod(q.multiply(p))];
    }

    function QuadraticHenselLift(A1, B1, U, V, p) {
        // http://tomlr.free.fr/Math%E9matiques/Math%20Complete/Number%20theory/A%20course%20in%20computational%20algebraic%20number%20theory%20-%20Cohen%20H..pdf
        // Algorithm 3.5.6 
        var one = p.divide(p);
        var g = Polynomial.of(one).subtract(U.multiply(A1)).subtract(V.multiply(B1)).scale(p.inverse()).mod(p);
        var tmp = V.multiply(g).mod(p).divideAndRemainderModP(A1.mod(p), p);
        var t = tmp.quotient;
        var U0 = U.multiply(g).add(B1.mod(p).multiply(t)).mod(p);
        //var V0 = V.multiply(g).subtract(A1.multiply(t)).mod(p);
        var V0 = tmp.remainder;
        var U1 = U.add(U0.scale(p));
        var V1 = V.add(V0.scale(p));
        return [U1.mod(p.multiply(p)), V1.mod(p.multiply(p))];
    }

    function HenselLiftingOfTwoFactors(C, A, B, p, k) {
        var useQuadraticHenselLift = true;
        var tmp1 = ExtendedEuclideanAlgorithm(A, B, p);
        console.assert(tmp1.gcd.getDegree() === 0);
        var U = tmp1.U;
        var V = tmp1.V;
        var ok = !(p instanceof Expression.Polynomial); // somehow the quadratic hensel lifting is slower in other case
        if (useQuadraticHenselLift && ok) { // TODO: any degree
            var originalP = p;
            var e = 1;
            while (e < k / 2) {
                var $tmpA_B = HenselLift(C, A, B, U, V, p, p);
                A = $tmpA_B[0];
                B = $tmpA_B[1];
                var $tmpU_V = QuadraticHenselLift(A, B, U, V, p);
                U = $tmpU_V[0];
                V = $tmpU_V[1];
                p = p.multiply(p);
                e *= 2;
                if (true) {
                    var c = 1;
                    while (e * c < k) {
                        c *= 2;
                    }
                    if ((e - 1) * c >= k) {
                        e -= 1;
                        p = p.divide(originalP);
                    }
                }
            }
            var $tmpA_B = HenselLift(C, A, B, U, V, p, p);
            A = $tmpA_B[0];
            B = $tmpA_B[1];
            //p = p.multiply(p);
            e *= 2;
            if (e !== k) {
                var pInK = originalP._pow(k);
                A = A.mod(pInK);
                B = B.mod(pInK);
            }
            return [A, B];
        }
        //TODO: ?
        var q = p;
        for (var i = 1; i < k; i += 1) {
            var $tmpA_B = HenselLift(C, A, B, U, V, q, p);
            A = $tmpA_B[0];
            B = $tmpA_B[1];
            //console.assert(U.multiply(A).add(V.multiply(B)).mod(p).toString() === '1');
            q = q.multiply(p);
        }
        return [A, B];
    }

    function productModQ(factors, q) {
        console.assert(factors.length > 0);
        return factors.length > 1 ? productModQ(factors.slice(0, Math.ceil(factors.length / 2)), q).multiply(productModQ(factors.slice(Math.ceil(factors.length / 2)), q)).mod(q) : factors[0];
    }

    function HenselLifting(C, factors, p, e) {
        // https://scholar.rose-hulman.edu/cgi/viewcontent.cgi?article=1163&context=math_mstr
        // "2.3 Factoring mod p e: Hensel Lifting"
        if (factors.length === 1) {
            return [C];
        }
        // divide and conquer
        var s = Math.ceil(factors.length / 2);
        var A = factors.slice(0, s);
        var B = factors.slice(s);
        var $tmpA1_B1 = HenselLiftingOfTwoFactors(C, productModQ(A, p), productModQ(B, p), p, e);
        var A1 = $tmpA1_B1[0];
        var B1 = $tmpA1_B1[1];
        return HenselLifting(A1, A, p, e).concat(HenselLifting(B1, B, p, e));
    }

    factorizeOverTheIntegers._gcdOfPolynomialsOverFiniteField0 = _gcdOfPolynomialsOverFiniteField0; //TODO: ?

    function factorizeMultivariateIntegerPolynomial(p) {
        // see "Art of Computer Programming, Volume 2: Seminumerical Algorithms"
        function factorizeInternal(p) { //TODO: REMOVE
            var factors = [];
            p = p.primitivePart();
            var f = p.getDegree() > 1 ? (!p.hasIntegerCoefficients() ? p.factorize() : factorizeOverTheIntegers(p)) : null; //TODO: ?
            if (f != null) {
                factors = factors.concat(factorizeInternal(f));
                factors = factors.concat(factorizeInternal(p.divideAndRemainder(f, "throw").quotient));
            } else {
                factors.push(p);
            }
            return factors;
        }
        var degreeByY = 0;
        for (var i = 0; i <= p.getDegree(); i += 1) {
            if (!(p.getCoefficient(i).equals(Expression.ZERO))) {
                degreeByY = Math.max(degreeByY, p.getCoefficient(i).polynomial.getDegree());
            }
        }
        //if (degreeByY > p.getDegree()) {
        //  return toPolynomialByAnotherVar(factorizeMultivariateIntegerPolynomial(toPolynomialByAnotherVar(p)));
        //}
        //degreeByY = Math.pow(2, Math.ceil(Math.log2(degreeByY + 1))) - 1;//!?
        for (var y = 0;; y += 1) {
            var p_r = p.map(function(c) {
                return c.polynomial.calcAt(Expression.Integer.fromNumber(y));
            });
            if (p_r.getDegree() === p.getDegree() && p_r.isSquareFreePolynomial()) {
                var factors = Array.from(factorizeInternal(p_r)).map(function(f) {
                    return f.map(function(c) {
                        return new Expression.Polynomial(Polynomial.of(c));
                    });
                });
                if (factors.length < 2) {
                    return null; // primitive (?)
                }
                var s = new Expression.Polynomial(Polynomial.of(p_r.getContent()));
                factors[factors.length - 1] = factors[factors.length - 1].scale(s);
                var r = new Expression.Polynomial(Polynomial.of(Expression.Integer.fromNumber(0 - y), Expression.ONE));
                var q = r._pow(degreeByY + 1);
                factors = HenselLifting(p, factors, r, degreeByY + 1);
                console.assert(p.subtract(productModQ(factors, q)).mod(q).toString() === '0');
                for (var number = 1; number <= factors.length - 1; number += 1) {
                    for (var iteratorc = combinations(factors, number)[globalThis.Symbol.iterator](), c = iteratorc.next().value; c != null; c = iteratorc.next().value) {
                        var candidate = productModQ(c, q);
                        candidate = candidate.scale(p.getLeadingCoefficient()).mod(q);
                        if (candidate._hasIntegerLikeCoefficients()) {
                            candidate = candidate.primitivePart();
                            if (p.scale(p.getLeadingCoefficient()._pow(p.getDegree() - candidate.getDegree() + 1)).isDivisibleBy(candidate)) {
                                return candidate;
                            }
                        }
                    }
                }
            }
        }
    }

    factorizeOverTheIntegers._factorizeMultivariateIntegerPolynomial = factorizeMultivariateIntegerPolynomial;

    self.factorizeOverTheIntegers = factorizeOverTheIntegers;

    factorizeOverTheIntegers.testables = {
        gcdOfPolynomialsOverFiniteField: gcdOfPolynomialsOverFiniteField,
        distinctDegreeFactorization: distinctDegreeFactorization,
        CantorZassenhausAlgorithm: CantorZassenhausAlgorithm,
        isFactorizationOverZpSquareFree: isFactorizationOverZpSquareFree,
        factorizeOverTheFiniteField: factorizeOverTheFiniteField,
        modPow: modPow,

        randomBigInt: randomBigInt,

        ExtendedEuclideanAlgorithm: ExtendedEuclideanAlgorithm,
        HenselLift: HenselLift,
        QuadraticHenselLift: QuadraticHenselLift,
        HenselLiftingOfTwoFactors: HenselLiftingOfTwoFactors,
        HenselLifting: HenselLifting,
        productModQ: productModQ
    };

})();
(function() {
    "use strict";
    /*
    Copyright 2019 David Bau.

    Permission is hereby granted, free of charge, to any person obtaining
    a copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

    */

    (function(global, pool, math) {
        //
        // The following constants are related to IEEE 754 limits.
        //

        var width = 256, // each RC4 output is 0 <= x < 256
            chunks = 6, // at least six RC4 outputs for each double
            digits = 52, // there are 52 significant digits in a double
            rngname = 'random', // rngname: name for Math.random and Math.seedrandom
            startdenom = math.pow(width, chunks),
            significance = math.pow(2, digits),
            overflow = significance * 2,
            mask = width - 1,
            nodecrypto; // node.js crypto module, initialized at the bottom.

        //
        // seedrandom()
        // This is the seedrandom function described above.
        //
        function seedrandom(seed, options, callback) {
            var key = [];
            options = (options == true) ? {
                entropy: true
            } : (options || {});

            // Flatten the seed string or build one from local entropy if needed.
            var shortseed = mixkey(flatten(
                options.entropy ? [seed, tostring(pool)] :
                (seed == null) ? autoseed() : seed, 3), key);

            // Use the seed to initialize an ARC4 generator.
            var arc4 = new ARC4(key);

            // This function returns a random double in [0, 1) that contains
            // randomness in every bit of the mantissa of the IEEE 754 value.
            var prng = function() {
                var n = arc4.g(chunks), // Start with a numerator n < 2 ^ 48
                    d = startdenom, //   and denominator d = 2 ^ 48.
                    x = 0; //   and no 'extra last byte'.
                while (n < significance) { // Fill up all significant digits by
                    n = (n + x) * width; //   shifting numerator and
                    d *= width; //   denominator and generating a
                    x = arc4.g(1); //   new least-significant-byte.
                }
                while (n >= overflow) { // To avoid rounding up, before adding
                    n /= 2; //   last byte, shift everything
                    d /= 2; //   right using integer math until
                    x >>>= 1; //   we have exactly the desired bits.
                }
                return (n + x) / d; // Form the number within [0, 1).
            };

            prng.int32 = function() {
                return arc4.g(4) | 0;
            }
            prng.quick = function() {
                return arc4.g(4) / 0x100000000;
            }
            prng.double = prng;

            // Mix the randomness into accumulated entropy.
            mixkey(tostring(arc4.S), pool);

            // Calling convention: what to return as a function of prng, seed, is_math.
            return (options.pass || callback ||
                function(prng, seed, is_math_call, state) {
                    if (state) {
                        // Load the arc4 state from the given state if it has an S array.
                        if (state.S) {
                            copy(state, arc4);
                        }
                        // Only provide the .state method if requested via options.state.
                        prng.state = function() {
                            return copy(arc4, {});
                        }
                    }

                    // If called as a method of Math (Math.seedrandom()), mutate
                    // Math.random because that is how seedrandom.js has worked since v1.0.
                    if (is_math_call) {
                        math[rngname] = prng;
                        return seed;
                    }

                    // Otherwise, it is a newer calling convention, so return the
                    // prng directly.
                    else return prng;
                })(
                prng,
                shortseed,
                'global' in options ? options.global : (this == math),
                options.state);
        }

        //
        // ARC4
        //
        // An ARC4 implementation.  The constructor takes a key in the form of
        // an array of at most (width) integers that should be 0 <= x < (width).
        //
        // The g(count) method returns a pseudorandom integer that concatenates
        // the next (count) outputs from ARC4.  Its return value is a number x
        // that is in the range 0 <= x < (width ^ count).
        //
        function ARC4(key) {
            var t, keylen = key.length,
                me = this,
                i = 0,
                j = me.i = me.j = 0,
                s = me.S = [];

            // The empty key [] is treated as [0].
            if (!keylen) {
                key = [keylen++];
            }

            // Set up S using the standard key scheduling algorithm.
            while (i < width) {
                s[i] = i++;
            }
            for (i = 0; i < width; i++) {
                s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
                s[j] = t;
            }

            // The "g" method returns the next (count) outputs as one number.
            (me.g = function(count) {
                // Using instance members instead of closure state nearly doubles speed.
                var t, r = 0,
                    i = me.i,
                    j = me.j,
                    s = me.S;
                while (count--) {
                    t = s[i = mask & (i + 1)];
                    r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
                }
                me.i = i;
                me.j = j;
                return r;
                // For robust unpredictability, the function call below automatically
                // discards an initial batch of values.  This is called RC4-drop[256].
                // See http://google.com/search?q=rsa+fluhrer+response&btnI
            })(width);
        }

        //
        // copy()
        // Copies internal state of ARC4 to or from a plain object.
        //
        function copy(f, t) {
            t.i = f.i;
            t.j = f.j;
            t.S = f.S.slice();
            return t;
        };

        //
        // flatten()
        // Converts an object tree to nested arrays of strings.
        //
        function flatten(obj, depth) {
            var result = [],
                typ = (typeof obj),
                prop;
            if (depth && typ == 'object') {
                for (prop in obj) {
                    try {
                        result.push(flatten(obj[prop], depth - 1));
                    } catch (e) {}
                }
            }
            return (result.length ? result : typ == 'string' ? obj : obj + '\0');
        }

        //
        // mixkey()
        // Mixes a string seed into a key that is an array of integers, and
        // returns a shortened string seed that is equivalent to the result key.
        //
        function mixkey(seed, key) {
            var stringseed = seed + '',
                smear, j = 0;
            while (j < stringseed.length) {
                key[mask & j] =
                    mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
            }
            return tostring(key);
        }

        //
        // autoseed()
        // Returns an object for autoseeding, using window.crypto and Node crypto
        // module if available.
        //
        function autoseed() {
            try {
                var out;
                if (nodecrypto && (out = nodecrypto.randomBytes)) {
                    // The use of 'out' to remember randomBytes makes tight minified code.
                    out = out(width);
                } else {
                    out = new Uint8Array(width);
                    (global.crypto || global.msCrypto).getRandomValues(out);
                }
                return tostring(out);
            } catch (e) {
                var browser = global.navigator,
                    plugins = browser && browser.plugins;
                return [+new Date, global, plugins, global.screen, tostring(pool)];
            }
        }

        //
        // tostring()
        // Converts an array of charcodes to a string
        //
        function tostring(a) {
            return String.fromCharCode.apply(0, a);
        }

        //
        // When seedrandom.js is loaded, we immediately mix a few bits
        // from the built-in RNG into the entropy pool.  Because we do
        // not want to interfere with deterministic PRNG state later,
        // seedrandom will not call math.random on its own again after
        // initialization.
        //
        mixkey(math.random(), pool);

        //
        // Nodejs and AMD support: export the implementation as a module using
        // either convention.
        //
        if ((typeof module) == 'object' && module.exports) {
            module.exports = seedrandom;
            // When in node.js, try using crypto package for autoseeding.
            try {
                nodecrypto = require('crypto');
            } catch (ex) {}
        } else if ((typeof define) == 'function' && define.amd) {
            define(function() {
                return seedrandom;
            });
        } else {
            // When included as a plain script, set up Math.seedrandom global.
            math['seed' + rngname] = seedrandom;
        }


        // End anonymous scope, and pass initial values.
    })(
        // global: `self` in browsers (including strict mode and web workers),
        // otherwise `this` in Node and other environments
        (typeof self !== 'undefined') ? self : this, [], // pool: entropy pool starts empty
        Math // math: package containing random, pow, and seedrandom
    );

})();
(function() {
    "use strict";

    //TODO: ?
    //TODO: !?

    // API:

    // a class for real algebraic numbers
    // Operations are implemented as described at https://en.wikipedia.org/wiki/Resultant#Number_theory

    // "AbstractPolynomialRoot":
    //  #toDecimal(precision)
    //  #scale(k), k is an "algebraic expression constant"
    //  #translate(k), k is an "algebraic expression constant"
    //  #multiply(otherPolynomialRoot)
    //  #add(otherPolynomialRoot)
    //  #negate()
    //  #inverse()
    //  #sign()
    //  #_pow(n), n is an integer
    //  #_nthRoot(n), n is an integer
    //  #equals(otherPolynomialRoot)

    // PolynomialRoot implements AbstractPolynomialRoot - a basic class to represent real algebraic number exactly
    //   .polynomial
    //   .interval
    // LazyPolynomialRoot implements AbstractPolynomialRoot - a class to represent real algebraic number as a rational expression (see https://en.wikipedia.org/wiki/Algebraic_expression )
    //   .e
    //   ._root

    //TODO: remove references to Expression.ExpressionPolynomialRoot (?)

    //Note: SimpleFloat is used only internally
    function SimpleFloat(significand, exponent) {
        this.significand = significand;
        this.exponent = exponent;
    }
    SimpleFloat.create = function(e) {
        if (!isRational(e) || !isPowerOf2(e.getDenominator())) {
            throw new TypeError();
        }
        return new SimpleFloat(e.getNumerator(), 0 - (e.getDenominator().bitLength() - 1));
    };
    SimpleFloat.prototype.toExpression = function() {
        return this.significand.multiply(this.exponent >= 0 ? Expression.TWO._pow(this.exponent) : Expression.TWO._pow(-this.exponent).inverse());
    };
    SimpleFloat.prototype.multiply = function(other) {
        return new SimpleFloat(this.significand.multiply(other.significand), this.exponent + other.exponent);
    };
    SimpleFloat.prototype.add = function(other) {
        var min = Math.min(this.exponent, other.exponent);
        return new SimpleFloat(this.significand.leftShift(this.exponent - min).add(other.significand.leftShift(other.exponent - min)), min);
    };
    SimpleFloat.prototype.negate = function() {
        return new SimpleFloat(this.significand.negate(), this.exponent);
    };
    SimpleFloat.prototype.sign = function() {
        return this.significand.sign();
    };
    var isRational = function(e) {
        return e.getNumerator() instanceof Expression.Integer && e.getDenominator() instanceof Expression.Integer;
    };
    var isPowerOf2 = function(i) {
        return Expression.TWO._pow(i.bitLength() - 1).equals(i);
    };

    //Note: SimpleInterval is used only internally
    function SimpleInterval(a, b) {
        if (!(a instanceof SimpleFloat) || !(b instanceof SimpleFloat) || a.add(b.negate()).sign() > 0) {
            throw new TypeError();
        }
        this.a = a;
        this.b = b;
    }
    SimpleInterval.from = function(interval) {
        return new SimpleInterval(SimpleFloat.create(interval.a), SimpleFloat.create(interval.b));
    };
    SimpleInterval.prototype.toExpressionsInterval = function() {
        return {
            a: this.a.toExpression(),
            b: this.b.toExpression()
        };
    };
    SimpleInterval.prototype.negate = function() {
        return new SimpleInterval(this.b.negate(), this.a.negate());
    };
    SimpleInterval.prototype.add = function(other) {
        return new SimpleInterval(this.a.add(other.a), this.b.add(other.b));
    };
    SimpleInterval.prototype.multiply = function(other) {
        var sign = function(e) {
            return e.sign();
        };
        var f = function(a, b, c, d) {
            return new SimpleInterval(a.multiply(b), c.multiply(d));
        };
        var x1 = this.a;
        var x2 = this.b;
        var y1 = other.a;
        var y2 = other.b;
        var sx1 = sign(x1);
        var sx2 = sign(x2);
        var sy1 = sign(y1);
        var sy2 = sign(y2);
        if (sx1 >= 0) {
            if (sy1 >= 0) {
                return f(x1, y1, x2, y2);
            }
            if (sy2 <= 0) {
                return f(x2, y1, x1, y2);
            }
            // y1 < 0 && y2 > 0
            return f(x2, y1, x2, y2);
        }
        if (sx2 <= 0) {
            if (sy2 <= 0) {
                return f(x2, y2, x1, y1);
            }
            if (sy1 >= 0) {
                return f(x1, y2, x2, y1);
            }
            // y1 < 0 && y2 > 0
            return f(x1, y2, x1, y1);
        }
        if (sy1 >= 0) {
            // x1 < 0 && x2 > 0
            return f(x1, y2, x2, y2);
        }
        if (sy2 <= 0) {
            // x1 < 0 && x2 > 0
            return f(x2, y1, x1, y1);
        }
        //TODO: add a test
        var a = x1.multiply(y1);
        var b = x2.multiply(y1);
        var c = x1.multiply(y2);
        var d = x2.multiply(y2);
        var min = function(a, b) {
            return a.subtract(b).sign() < 0 ? a : b;
        };
        var max = function(a, b) {
            return a.subtract(b).sign() < 0 ? b : a;
        };
        var from = min(min(a, b), min(c, d));
        var to = max(max(a, b), max(c, d));
        return new SimpleInterval(from, to);
    };
    SimpleInterval.prototype.scale = function(s) {
        return this.multiply(SimpleInterval.from({
            a: s,
            b: s
        })); //TODO: ?
    };

    SimpleInterval.prototype.inverse = function(precision) {
        var sign = function(e) {
            return e.sign();
        };
        if (sign(this.a) < 0 && sign(this.b) > 0) {
            throw new TypeError();
        }
        if (precision == undefined) {
            debugger;
            throw new TypeError();
        }
        var that = this.toExpressionsInterval(); //!TODO: REMOVE
        var s = Expression.TWO._pow(precision + Math.max(that.b.getNumerator().abs().bitLength(), that.a.getNumerator().abs().bitLength()));
        var div = function(a, b, roundingMode) {
            if (roundingMode === 'floor') {
                if (b.sign() < 0) {
                    a = a.negate();
                    b = b.negate();
                }
                return a.sign() >= 0 ? a.truncatingDivide(b) : a.add(Expression.ONE).truncatingDivide(b).subtract(Expression.ONE);
            }
            if (roundingMode === 'ceil') {
                return div(a.negate(), b, 'floor').negate();
            }
            throw new TypeError();
        };
        var f = function(s, x, roundingMode) {
            return div(s, x.getNumerator(), roundingMode).divide(s).multiply(x.getDenominator());
        };
        return SimpleInterval.from({
            a: f(s, that.b, 'floor'),
            b: f(s, that.a, 'ceil')
        });
    };
    SimpleInterval.prototype._pow = function(n) {
        if (n % 2 === 0) {
            if (n === 0) {
                return SimpleInterval.from({
                    a: Expression.ONE,
                    b: Expression.ONE
                });
            }
            return this.multiply(this)._pow(n / 2);
        }
        return new SimpleInterval(this.a._pow(n), this.b._pow(n));
    };
    SimpleInterval.prototype.toString = function() {
        return '[' + this.a.toString() + ';' + this.b.toString() + ']';
    };
    var intersection = function(a, b) {
        var cmp = function(x1, x2) {
            return x1.subtract(x2).getNumerator().sign();
        };
        var max = function(x1, x2) {
            return cmp(x1, x2) < 0 ? x2 : x1;
        };
        var min = function(x1, x2) {
            return cmp(x1, x2) < 0 ? x1 : x2;
        };
        // https://scicomp.stackexchange.com/a/26260
        if (cmp(b.a, a.b) > 0 || cmp(a.a, b.b) > 0) {
            return null;
        }
        return {
            a: max(a.a, b.a),
            b: min(a.b, b.b)
        };
    };

    // TODO:
    var toSimpleInterval = function(e, precision) {
        // precision - precision of the computation (?)
        if (e instanceof Expression.Integer) {
            return SimpleInterval.from({
                a: e,
                b: e
            });
        } else if (e instanceof Expression.BinaryOperation) {
            var a = toSimpleInterval(e.a, precision);
            var b = toSimpleInterval(e.b, precision);
            var s = e.getS();
            if (s === "+") {
                return a.add(b);
            } else if (s === "-") {
                return a.add(b.negate());
            } else if (s === "*") {
                return a.multiply(b);
            } else if (s === "/") {
                //- why was it commented out - ?
                return a.multiply(b.inverse(precision));
            } else if (s === "^") {
                if (e.b instanceof Expression.Integer) {
                    var n = e.b.toBigInt();
                    return a._pow(n);
                }
            } else {
                debugger;
            }
        } else if (e instanceof Expression.NthRoot) {
            var n = e.n;
            console.assert(n >= 2 && n % 1 === 0);
            if (e.a instanceof Expression.Integer && e.a.sign() > 0) {
                var a = e.a;
                var scale = Expression.TWO._pow(precision);
                var numerator = a.multiply(scale._pow(n))._integerNthRoot(n);
                //TODO: FIX
                return SimpleInterval.from({
                    a: numerator.divide(scale),
                    b: numerator.add(Expression.ONE).divide(scale)
                });
            }
            var a = toSimpleInterval(e.a, precision);
            if (n % 2 === 0) {
                //TODO: !?!?!
                var i = 2;
                while (a.a.sign() < 0 && a.b.sign() > 0) {
                    a = toSimpleInterval(e.a, precision * i);
                    i *= 2;
                }
            }
            var f = function(x, n, rounding) {
                var scale = Expression.TWO._pow(precision);
                var e = rounding === 'floor' ? x.getNumerator().sign() >= 0 ? Expression.ZERO : Expression.ONE.negate() : x.getNumerator().sign() < 0 ? Expression.ZERO : Expression.ONE;
                return x.getNumerator().multiply(x.getDenominator()._pow(n - 1)).multiply(scale._pow(n))._integerNthRoot(n).add(e).divide(scale.multiply(x.getDenominator()));
            };
            a = a.toExpressionsInterval(); //TODO: !?
            return SimpleInterval.from({
                a: f(a.a, n, 'floor'),
                b: f(a.b, n, 'ceil')
            });
        } else {}
        if (e instanceof PolynomialRoot) {
            return SimpleInterval.from(e.toDecimal(precision));
        }
        //TODO: REMOVE(?)
        if (e instanceof Expression.PolynomialRootSymbol) {
            return SimpleInterval.from(e.toDecimal(precision));
        }
        if (e instanceof Expression.ExpressionPolynomialRoot) {
            return SimpleInterval.from(e.root.toDecimal(precision));
        }
        debugger;
        throw new TypeError("?");
    };

    function Helper(polynomial) {
        this.squareFreeFactors = [];
        var tmp = null;
        var ONE = Polynomial.of(Expression.ONE);
        do {
            tmp = polynomial.squareFreeFactors();
            if (!tmp.a1.equals(ONE)) {
                //TODO: ?
                this.squareFreeFactors.push(tmp.a1);
            }
            if (tmp.a0.getDegree() !== 0) {
                polynomial = tmp.a0;
            } else {
                polynomial = null;
            }
        } while (polynomial != null);
    }
    Helper.prototype.calcAt = function(point) {
        var result = Expression.ONE;
        for (var iteratorfactor = this.squareFreeFactors[globalThis.Symbol.iterator](), factor = iteratorfactor.next().value; factor != null; factor = iteratorfactor.next().value) {
            result = result.multiply(factor.calcAt(point));
        }
        return result;
    };
    Helper.prototype.numberOfRoots = function(interval) {
        var result = 0;
        var newFactors = [];
        for (var iteratorfactor = this.squareFreeFactors[globalThis.Symbol.iterator](), factor = iteratorfactor.next().value; factor != null; factor = iteratorfactor.next().value) {
            var n = factor.numberOfRoots(interval.toExpressionsInterval());
            result += n;
            if (n > 0) {
                newFactors.push(factor);
            }
        }
        this.squareFreeFactors = newFactors;
        return result;
    };
    Helper.get = function(that, interval) {
        //TODO: do not call twice
        //for (var iteratorfactor = that.squareFreeFactors[globalThis.Symbol.iterator](), factor = iteratorfactor.next().value; factor != null; factor = iteratorfactor.next().value) {
        //  if (factor.numberOfRoots(interval) > 0) {
        //    return factor;
        //  }
        //}
        //return null;
        return that.squareFreeFactors.length === 1 ? that.squareFreeFactors[0] : null;
    };
    var calculateNewInterval = function(newPolynomial, zeroFunction) {
        if (!newPolynomial.hasIntegerCoefficients()) {
            throw new RangeError("just a check");
        }
        newPolynomial = new Helper(newPolynomial); //!?!?TODO: REMOVE
        var precision = 1;
        var guess = zeroFunction(precision);
        while (guess.a.sign() !== guess.b.sign() && !newPolynomial.calcAt(Expression.ZERO).equals(Expression.ZERO) || newPolynomial.numberOfRoots(guess) > 1) {
            precision *= 2;
            guess = zeroFunction(precision);
            if (precision > 1024) throw new Error(); //TODO: ?
        }

        var newInterval = guess;
        newPolynomial = Helper.get(newPolynomial, guess);
        return new PolynomialRoot(newPolynomial, newInterval.toExpressionsInterval());
    };

    function PolynomialRoot(polynomial, interval, options) {
        options = options == undefined ? {} : options;

        if (!polynomial.hasIntegerCoefficients()) {
            throw new TypeError();
        }
        if (polynomial.getLeadingCoefficient().sign() < 0) {
            return new PolynomialRoot(polynomial.negate(), interval);
        }
        var content = polynomial.getContent();
        if (!content.equals(Expression.ONE)) {
            return new PolynomialRoot(polynomial.scale(content.inverse()), interval);
        }
        if (!options.skipFactorization) {
            //!
            var factor = polynomial.factorize();
            //TODO: pass the zero to help the factorization to return the correct factor:
            // var factor = polynomial.factorize({zero: new PolynomialRoot(polynomial, interval)});
            if (factor != null && !factor.equals(polynomial)) {
                if (factor.numberOfRoots(interval) !== 0) {
                    return new PolynomialRoot(factor, interval);
                } else {
                    var otherFactor = polynomial.divideAndRemainder(factor, "throw").quotient;
                    return new PolynomialRoot(otherFactor, interval);
                }
            }
        }
        if (interval instanceof SimpleInterval) {
            throw new TypeError();
        }
        if (interval.a.subtract(interval.b).getNumerator().sign() > 0) {
            throw new TypeError();
        }
        // how to represent zero - ?
        //if ((interval.a.getNumerator().sign() || interval.b.getNumerator().sign()) !== (interval.b.getNumerator().sign() || interval.a.getNumerator().sign())) {
        //  throw new TypeError();
        //}
        if (!options.skipFactorization) {
            //!
            if (polynomial.numberOfRoots(interval) !== 1) {
                throw new TypeError();
            }
        }
        if (!polynomial.getContent().equals(Expression.ONE)) {
            throw new TypeError();
        }
        //TODO: factorization
        this.polynomial = polynomial;
        //TODO: https://www.wolframalpha.com/input/?i=x**5%2B7x**3%2Bx**2%2Bx%2B1%3D0
        this.interval = interval;
    }
    PolynomialRoot.prototype.toDecimal = function(precision) {
        return this.polynomial.getZero(this.interval, precision);
    };
    PolynomialRoot.prototype.toString = function() {
        // for debugging (?)
        return "[root of " + this.polynomial + " near " + this.interval.a.add(this.interval.b).divide(Expression.TWO).toString() + "]";
    };

    //TODO: remove (?)
    PolynomialRoot.prototype.scale = function(k) {
        //console.assert(k instanceof Expression.Integer || isRational(k));
        // z = k * x, x = z / k
        var newPolynomial = this.polynomial._scaleRoots(k).primitivePart();
        if (!isRational(k)) {
            // TODO: remove
            var root = this;
            newPolynomial = toPolynomialWithIntegerCoefficients(newPolynomial);
            return calculateNewInterval(newPolynomial, function(precision) {
                return toSimpleInterval(root, precision).multiply(toSimpleInterval(k, precision));
            });
        }
        //TODO: clean up
        if (!isPowerOf2(k.getDenominator())) {
            // to have interval ends of the form n*2**e
            var root = this;
            return calculateNewInterval(newPolynomial, function(precision) {
                return toSimpleInterval(root, precision).multiply(toSimpleInterval(k, precision));
            });
        }
        var newInterval = SimpleInterval.from(this.interval).scale(k).toExpressionsInterval();
        return new PolynomialRoot(newPolynomial, newInterval);
    };

    //TODO: remove (?)
    PolynomialRoot.prototype.translate = function(k) {
        //console.assert(k instanceof Expression.Integer || isRational(k));//TODO: ???
        // z = x + k, x = z - k
        var newPolynomial = this.polynomial._translateRoots(k).primitivePart();
        // to avoid intervals, which include zero
        var root = this;
        var newInterval = null;
        if (!isRational(k)) {
            // TODO: remove
            newPolynomial = toPolynomialWithIntegerCoefficients(newPolynomial);
            return calculateNewInterval(newPolynomial, function(precision) {
                return toSimpleInterval(root, precision).add(toSimpleInterval(k, precision));
            });
        }
        // to avoid intervals, which include zero
        return calculateNewInterval(newPolynomial, function(precision) {
            return toSimpleInterval(root, precision).add(toSimpleInterval(k, precision));
        });
    };
    PolynomialRoot.prototype.multiply = function(other) {
        var that = this;
        //TODO: remove
        if (true) {
            var g = Math.gcd(that.polynomial.getGCDOfTermDegrees(), other.polynomial.getGCDOfTermDegrees());
            if (g > 1) {
                var tmp = that._pow(g).multiply(other._pow(g))._nthRoot(g);
                //TODO: TEST!!!
                if (g % 2 === 0 && that.sign() * other.sign() < 0) {
                    tmp = tmp.negate();
                }
                return tmp;
            }
        }
        // z = x * y, y = z / x
        //TODO: variable names
        var $z = new Expression.Polynomial(Polynomial.of(Expression.ONE).shift(1));
        var toPInZ = function(c) {
            return new Expression.Polynomial(Polynomial.of(c));
        };
        var second = other.polynomial._exponentiateRoots(-1).map(toPInZ)._scaleRoots($z);
        var newPolynomial = Polynomial.resultant(that.polynomial.map(toPInZ), second).polynomial.primitivePart();
        return calculateNewInterval(newPolynomial, function(precision) {
            return toSimpleInterval(that, precision).multiply(toSimpleInterval(other, precision));
        });
    };
    PolynomialRoot.prototype.add = function(other) {
        var that = this;
        if (that.polynomial.isEven() && that.polynomial.equals(other.polynomial) && that.equals(other.negate())) {
            return new PolynomialRoot(Polynomial.of(Expression.ONE).shift(1), {
                a: Expression.ONE.negate(),
                b: Expression.ONE
            });
        }
        // z = x + y, y = z - x
        //TODO: variable names
        var $z = new Expression.Polynomial(Polynomial.of(Expression.ONE).shift(1));
        var toPInZ = function(c) {
            return new Expression.Polynomial(Polynomial.of(c));
        };
        var second = other.polynomial._scaleRoots(Expression.ONE.negate()).map(toPInZ)._translateRoots($z);
        var newPolynomial = Polynomial.resultant(that.polynomial.map(toPInZ), second).polynomial.primitivePart();
        return calculateNewInterval(newPolynomial, function(precision) {
            return toSimpleInterval(that, precision).add(toSimpleInterval(other, precision));
        });
    };

    //TODO: remove (?)
    PolynomialRoot.prototype.negate = function() {
        return new PolynomialRoot(this.polynomial._scaleRoots(Expression.ONE.negate()), {
            b: this.interval.a.negate(),
            a: this.interval.b.negate()
        });
    };

    //TODO: remove (?)
    PolynomialRoot.prototype.inverse = function() {
        // z = 1/y, y = 1/z
        var newPolynomial = this.polynomial._exponentiateRoots(-1);
        console.assert(this.interval.a.getNumerator().sign() === this.interval.b.getNumerator().sign());
        var that = this;
        return calculateNewInterval(newPolynomial, function(precision) {
            return toSimpleInterval(that, precision).inverse(precision);
        });
    };
    PolynomialRoot.prototype.sign = function() {
        if (this.polynomial.getCoefficient(0).equals(Expression.ZERO)) {
            if (this.interval.a.getNumerator().sign() <= 0 && this.interval.b.getNumerator().sign() >= 0) {
                return 0;
            }
        }
        if (this.interval.a.getNumerator().sign() >= 0) {
            return +1;
        }
        if (this.interval.b.getNumerator().sign() <= 0) {
            return -1;
        }
        throw new TypeError("should not happen");
    };
    PolynomialRoot.prototype._pow = function(n) {
        var pow = function(x, count, accumulator) {
            if (!(count >= 0)) {
                throw new RangeError();
            }
            if (count > Number.MAX_SAFE_INTEGER) {
                throw new RangeError("NotSupportedError");
            }
            return count < 1 ? accumulator : 2 * Math.floor(count / 2) !== count ? pow(x, count - 1, accumulator.multiply(x)) : pow(x._pow(2), Math.floor(count / 2), accumulator);
        };
        if (n === 0) {
            return new PolynomialRoot(Polynomial.of(Expression.ONE.negate(), Expression.ONE), SimpleInterval.from({
                a: Expression.ZERO,
                b: Expression.TWO
            })); // x-1=0
        }

        var g = Math.gcd(n, this.polynomial.getGCDOfTermDegrees());
        if (g === 1) {
            //return Expression.prototype._pow.call(this, n);//TODO: ?
            return pow(this, n - 1, this);
        }
        if (g < n) {
            return this._pow(g)._pow(n / g);
        }
        //TODO: faster method
        var newInterval = undefined;
        if (n % 2 === 0 && this.interval.b.getNumerator().sign() <= 0) {
            newInterval = {
                a: this.interval.b._pow(n),
                b: this.interval.a._pow(n)
            };
        } else {
            newInterval = {
                a: this.interval.a._pow(n),
                b: this.interval.b._pow(n)
            };
        }
        //TODO:
        return new PolynomialRoot(this.polynomial._exponentiateRoots(n), newInterval);
    };
    var $α = function() {
        return new Expression.Symbol('α');
        //return new Expression.Polynomial(Polynomial.of(Expression.ONE).shift(1));
    };

    PolynomialRoot.prototype._nthRoot = function(n) {
        var newPolynomial = this.polynomial._exponentiateRoots(1 / n);
        var root = this;
        return calculateNewInterval(newPolynomial, function(precision) {
            //TODO: 
            //return root.toDecimal(precision).nthRoot(n);
            return toSimpleInterval(Expression.NthRoot.makeRoot(new Expression.ExpressionPolynomialRoot(new LazyPolynomialRoot(Polynomial.of(Expression.ZERO, Expression.ONE), Polynomial.of(Expression.ONE), root)), n), precision);
        });
    };
    PolynomialRoot.prototype.equals = function(other) {
        if (this === other) {
            return true;
        }
        if (this.polynomial.getDegree() !== other.polynomial.getDegree()) {
            return false;
        }
        if (this.polynomial.equals(other.polynomial) && this.interval.a.equals(other.interval.a) && this.interval.b.equals(other.interval.b)) {
            return true;
        }
        var i = intersection(this.interval, other.interval);
        if (i == null) {
            return false;
        }
        if (this.polynomial.equals(other.polynomial)) {
            var c = this.polynomial.numberOfRoots(i);
            if (c === 1) {
                return true;
            } else if (c === 0) {
                return false;
            }
            throw new TypeError();
        }
        if (Polynomial.polynomialGCD(this.polynomial, other.polynomial).getDegree() === 0) {
            return false;
        }
        //TODO: ?
        //return this.polynomial.equals(other.polynomial) && intersection(this.interval, other.interval) != null && this.add(other.negate()).equals(Expression.ZERO);
        var interval = this.add(other.negate()).interval;
        return interval.a.getNumerator().sign() <= 0 && interval.b.getNumerator().sign() >= 0;
    };
    PolynomialRoot._calculateNewInterval = calculateNewInterval; //TODO: remove
    LazyPolynomialRoot._calculateNewInterval = calculateNewInterval; //TODO: remove

    PolynomialRoot._toSimpleInterval = toSimpleInterval; //TODO: remove
    LazyPolynomialRoot._toSimpleInterval = toSimpleInterval; //TODO: remove

    var _isSimpleForUpgrade = function(e, root) {
        if (e instanceof Expression.Multiplication) {
            return true; //!?
        }

        if (e instanceof Expression.Addition && !(e.a instanceof Expression.Addition)) {
            return _isSimpleForUpgrade(e.a, root) && _isSimpleForUpgrade(e.b, root);
        }
        //TODO: other variants (?)
        return e.equals(root) || e instanceof Expression.Integer || e instanceof Expression.Complex || e instanceof Expression.NthRoot || e instanceof Expression.Exponentiation && _isSimpleForUpgrade(e.a, root) && e.b instanceof Expression.Integer || e instanceof Expression.Multiplication && _isSimpleForUpgrade(e.a, root) && _isSimpleForUpgrade(e.b, root) || e instanceof Expression.Division && _isSimpleForUpgrade(e.getNumerator(), root) && e.b instanceof Expression.Integer;
    };
    PolynomialRoot._isSimpleForUpgrade = _isSimpleForUpgrade;
    LazyPolynomialRoot._isSimpleForUpgrade = _isSimpleForUpgrade;

    function LazyPolynomialRoot(p1, p2, root) {
        //console.assert(e instanceof Expression && (e.getDenominator() instanceof Expression.Integer));//TODO: Expression.Polynomial (?)
        if (!(p1 instanceof Polynomial)) {
            throw new TypeError();
        }
        if (!(p2 instanceof Polynomial) || !(p2.getDegree() === 0)) {
            throw new TypeError();
        }
        if (!p1._testCoefficients(function(c) {
                return !(c instanceof Expression.Division);
            })) {
            throw new TypeError();
        }
        console.assert(root instanceof PolynomialRoot);
        //TODO:
        //console.assert(Expression.isRealAlgebraicNumber(e));
        //this.e = e; // internal symbolic expression with a "root" as a symbol
        this._p1 = p1;
        this._p2 = p2;
        this._root = root;
        //if (Math.random() < 1/1000) {
        //console.debug('LazyPolynomialRoot', p1.getDegree() < 0 ? 0 : p1._log2hypot());
        //}
    }

    LazyPolynomialRoot.prototype.toDecimal = function(precision) {
        var calcAt = function(polynomial, x, precision) {
            var result = toSimpleInterval(Expression.ZERO, precision);
            for (var i = polynomial.getDegree(); i >= 0; i--) {
                result = result.multiply(x);
                var tmp = toSimpleInterval(polynomial.getCoefficient(i), Math.max(1, precision));
                //TODO: ?
                //if (tmp === "CANNOT_DIVIDE" || tmp == undefined) {
                //  return tmp;
                //}
                result = result.add(tmp);
            }
            return result;
        };
        var alphaValue = toSimpleInterval(this._root, precision);
        var p1 = this._p1;
        var p2 = this._p2;
        var a = calcAt(p1, alphaValue, precision);
        //if (a === "CANNOT_DIVIDE" || a == undefined) {
        //  return a;
        //}
        var b = calcAt(p2, alphaValue, precision);
        //if (b === "CANNOT_DIVIDE" || b == undefined) {
        //  return b;
        //}
        var result = a.multiply(b.inverse(precision));
        //TODO: precision !!!
        return result.toExpressionsInterval();
    };
    LazyPolynomialRoot.prototype.toString = function() {
        return "[" + this.getAlphaExpression() + ", where " + this._root + "]"; // for debugging
    };

    function makeExpressionWithPolynomialRoot(p1, p2, root) {
        var v = root;
        if (true) {
            if (p2.getDegree() !== 0 || !(p2.getCoefficient(0) instanceof Expression.Integer)) {
                var p2Inv = p2.modularInverse(root.polynomial).primitivePart();
                var newDenominator = p2.multiply(p2Inv).divideAndRemainder(root.polynomial).remainder;
                if (p2.getDegree() > 0) {
                    var c = newDenominator.getContent().getDenominator();
                    return makeExpressionWithPolynomialRoot(p1.multiply(p2Inv).scale(c), newDenominator.scale(c), root);
                }
            }
        }
        var reduce = function(p1, p2) {
            if (!(p2.getLeadingCoefficient() instanceof Expression.Integer)) {
                var c = Expression.getConjugate(p2.getLeadingCoefficient());
                return reduce(p1.scale(c), p2.scale(c));
            }
            //var g = p1.shift(p2.getDegree() + 1).add(p2).getContent();
            var g = p1.getContent().gcd(p2.getContent());
            if (!g.equals(Expression.ONE)) {
                p1 = p1.scale(g.inverse());
                p2 = p2.scale(g.inverse());
            }
            return [p1, p2];
        };

        //TODO: use cases - ?
        if (p1.equals(Polynomial.ZERO)) {
            return [Polynomial.ZERO, Polynomial.of(Expression.ONE)];
        }
        if (p1.getDegree() === 0 && p2.getDegree() === 0) {
            return reduce(p1, p2);
        }
        //!

        /*
          var c = function (x) {
            //!new 2020-08-27
            //TODO: remove
            //TODO: optimize
            //!new 2022-07-06 disabled as it is too slow and I do not know how to optimize it
            if (false &&
                !(x instanceof Expression.Integer) &&
                !(x instanceof Expression.Multiplication && x.a === Expression.I && x.b === v) &&
                !(x instanceof Expression.Exponentiation)) {
              var p1 = Polynomial.toPolynomial(x.subtract(new Expression.Symbol('$n')), variable);
              //var test = v.polynomial.divideAndRemainder(p1).remainder;
              if (p1.getDegree() >= v.polynomial.getDegree()) {
                p1 = Polynomial.pseudoRemainder(p1, v.polynomial);
              }
              var test = v.polynomial.getDegree() >= p1.getDegree() ? Polynomial.pseudoRemainder(v.polynomial, p1) : v.polynomial;
              if (test.getDegree() === 0) {
                //(x**2-2)(x**2+x-1) = 0
                var pn0 = Polynomial.toPolynomial(test.calcAt(Expression.ZERO).getNumerator(), new Expression.Symbol('$n'));
                var pn = Polynomial.toPolynomial(Expression.getConjugateExpression(test.calcAt(Expression.ZERO).getNumerator()), new Expression.Symbol('$n'));
                //pn = pn.scale(pn.getLeadingCoefficient().inverse());
                pn = pn.primitivePart();
                var tmp = pn.squareFreeFactors();
                var f = tmp.a0;
                if (tmp.a0.getDegree() === 0) {
                  f = tmp.a1;
                }
                if (f.getDegree() <= 2) {//TODO: ?
                  var roots = f.getroots();
                  var c = [];
                  var fractionDigits = 3;
                  do {
                    c.splice(0, c.length);
                    for (var iteratorroot = roots[globalThis.Symbol.iterator](), root = iteratorroot.next().value; root != null; root = iteratorroot.next().value) {
                      if (Expression.has(root, Expression.Complex) === Expression.has(x, Expression.Complex)) {
                        if (root.getNumerator().toMathML({rounding: {fractionDigits: fractionDigits}}) === new Expression.Multiplication(x, root.getDenominator()).toMathML({rounding: {fractionDigits: fractionDigits}})) {
                          c.push(root);
                        }
                      }
                    }
                    fractionDigits *= 2;
                  } while (c.length > 2);
                  if (c.length === 1) {
                    console.debug('c[0]:', c[0].toString());
                    return c[0];
                  }
                }
                var lc = pn.getLeadingCoefficient();
                //TODO: Expression.isConstant(x) is not working when x contains alpha (ExpressionPolynomialRoot)
                if (lc instanceof Expression.Integer && Expression.isConstant(x)) {//TODO: ? - this is a filter to avoid infinite computation
                  var s = toDecimalStringInternal(x.multiply(lc), {fractionDigits: 0});
                  var n = Number(s);//TODO: complex - ?
                  if (!Number.isNaN(n)) {
                    var q = Expression.Integer.fromString(s).divide(lc);
                    if (pn.calcAt(q).equals(Expression.ZERO) && pn0.calcAt(q).equals(Expression.ZERO)) {
                      var tmp = Expression.ONE.divide(Expression.TWO).divide(lc);
                      var interval = {a: q.subtract(tmp), b: q.add(tmp)};
                      if (pn.numberOfRoots(interval) === 1) {
                        console.debug('q.toString():', q.toString());
                        return q;
                      }
                      //TODO: ?
                      //if (pn0.numberOfRoots(interval) === 1) {
                      //  debugger;
                      //  console.debug('q.toString():', q.toString());
                      //  return q;
                      //}
                    }
                  }
                }
              }
            }
            var px = Polynomial.toPolynomial(x, variable);
            if (false) {
              if (v.polynomial.getDegree() === 6 && v.polynomial.getCoefficient(1).equals(Expression.ZERO) && v.polynomial.getCoefficient(2).equals(Expression.ZERO) && v.polynomial.getCoefficient(4).equals(Expression.ZERO) && v.polynomial.getCoefficient(5).equals(Expression.ZERO)) {
                if (px.getDegree() >= 3) {
                  var alpha = c(v._pow(3));
                  var dv = Polynomial.of(alpha.negate(), Expression.ZERO, Expression.ZERO, Expression.ONE);
                  return px.divideAndRemainder(dv).remainder.calcAt(variable);
                }
              }
            }
            //!
            return px.divideAndRemainder(v.polynomial).remainder.calcAt(variable);
          };
        */

        var c = function(p) {
            return p.divideAndRemainder(v.polynomial).remainder;
        };

        /*e = p1.calcAt(variable).divide(p2.calcAt(variable));
        var oldE = e;
        e = c(e.getNumerator()).divide(c(e.getDenominator()));
        if (!oldE.equals(e)) {
          var tmp = (!(oldE.getDenominator() instanceof Expression.Integer) || !(e.getDenominator() instanceof Expression.Integer));
          if (tmp) {
            e = c(e.getNumerator()).divide(c(e.getDenominator())); // something may change after the previous step
          }
        }*/

        p1 = c(p1);
        p2 = c(p2);

        //TODO: !?
        var s = p1.map(function(c) {
            return c.getDenominator().inverse();
        }).getContent().getDenominator();
        p1 = p1.scale(s);
        p2 = p2.scale(s);
        if (!p1.hasIntegerCoefficients()) {
            // integer polynomial may not be a factor of v.polynomial if the last one is minimal
            //TODO: !?
            var ok = true;
            if (root instanceof PolynomialRoot) {
                var interval = new LazyPolynomialRoot(p1, Polynomial.of(Expression.ONE), root).toDecimal(53); //!new - trying to optimize (!)
                ok = interval.b.sign() >= 0 && interval.a.sign() <= 0;
            }
            if (ok) {
                //TODO: use polynomial from the start - ?
                if (p1.hasRoot(v)) {
                    //Note: slow
                    return [Polynomial.ZERO, Polynomial.of(Expression.ONE)];
                }
            }
        }
        return reduce(p1, p2);
    }
    PolynomialRoot._makeExpressionWithPolynomialRoot = makeExpressionWithPolynomialRoot;
    LazyPolynomialRoot._makeExpressionWithPolynomialRoot = makeExpressionWithPolynomialRoot;

    function simplifyExpressionWithPolynomialRoot(p1, p2, root) {
        var tmp = makeExpressionWithPolynomialRoot(p1, p2, root);
        return new LazyPolynomialRoot(tmp[0], tmp[1], root);
    }
    PolynomialRoot.create = function(polynomial, interval, options) {
        return new PolynomialRoot(polynomial, interval, options);
    };
    LazyPolynomialRoot.create = function(polynomial, interval, options) {
        return fromRoot(new PolynomialRoot(polynomial, interval, options));
    };

    function fromRoot(root) {
        return new LazyPolynomialRoot(Polynomial.of(Expression.ZERO, Expression.ONE), Polynomial.of(Expression.ONE), root);
    }
    LazyPolynomialRoot.prototype.scale = function(k) {
        console.assert(Expression.isRealAlgebraicNumber(k));
        var result1 = this._p1.scale(k.getNumerator());
        var result2 = this._p2.scale(k.getDenominator());
        return k instanceof Expression.Integer ? new LazyPolynomialRoot(result1, result2, this._root) : simplifyExpressionWithPolynomialRoot(result1, result2, this._root);
    };
    LazyPolynomialRoot.prototype.translate = function(k) {
        console.assert(Expression.isRealAlgebraicNumber(k));
        return simplifyExpressionWithPolynomialRoot(this._p1.scale(k.getDenominator()).add(this._p2.scale(k.getNumerator())), this._p2.scale(k.getDenominator()), this._root);
    };
    var toPolynomialWithIntegerCoefficients = function(polynomial) {
        if (!polynomial.hasIntegerCoefficients()) {
            var variable = new Expression.Symbol('$$');
            var e = polynomial.calcAt(variable);
            var c = Expression.getConjugateExpression(e);
            if (c != null && !c.equals(e)) {
                //TODO: what if multiple (?) - ?
                return Polynomial.toPolynomial(c, variable);
            }
        }
        return polynomial;
    };

    function upgrade(root, p1, p2) {
        if (p1.getDegree() === 1 && p1.getCoefficient(0).equals(Expression.ZERO) && p1.getCoefficient(1).equals(Expression.ONE)) {
            // short path
            if (p2.getDegree() === 0) {
                if (p2.getCoefficient(0).equals(Expression.ONE)) {
                    return root;
                }
                return root.scale(p2.getCoefficient(0).inverse()); // short path 2
            }
        }

        if (p1.equals(Polynomial.ZERO)) {
            return PolynomialRoot.create(Polynomial.of(Expression.ZERO, Expression.ONE), {
                a: Expression.ZERO,
                b: Expression.ZERO
            });
        }
        if (p1.getDegree() === 0 && p2.getDegree() === 0 && p2.getCoefficient(0).equals(Expression.ONE)) {
            var x = p1.getCoefficient(0);
            return PolynomialRoot.create(Polynomial.of(x.negate(), Expression.ONE), {
                a: x,
                b: x
            });
        }
        //TODO: !?
        // e = (ax^n + b) / c
        // root._pow(n).scale(a).translate(b).scale(c.inverse())
        if (p2.getDegree() === 0 && p2.getCoefficient(0).equals(Expression.ONE) && p1.getDegree() === p1.getGCDOfTermDegrees() && p1.getLeadingCoefficient().equals(Expression.ONE) && p1.getCoefficient(0).equals(Expression.ZERO) && p1.getDegree() === root.polynomial.getGCDOfTermDegrees()) {
            //TODO: other cases !!!
            return root._pow(p1.getDegree());
        }
        if (p2.getDegree() === 0 && p2.getCoefficient(0).equals(Expression.ONE) && p1.getDegree() === 1 && p1.getCoefficient(1).equals(Expression.ONE)) {
            return root.translate(p1.getCoefficient(0));
        }
        if (p2.getDegree() === 0 && p1.getDegree() === 1 && p1.getCoefficient(0).equals(Expression.ZERO)) {
            return root.scale(p1.getCoefficient(1).divide(p2.getCoefficient(0)));
        }
        var scale = Expression.ONE;
        if (p2.getDegree() === 0 && p2.hasIntegerCoefficients()) {
            scale = p2.getLeadingCoefficient();
            p2 = Polynomial.of(Expression.ONE);
        }
        var polynomial = p1.subtract(Polynomial.of(new Expression.Symbol('β')).multiply(p2));
        polynomial = toPolynomialWithIntegerCoefficients(polynomial); //TODO: ???
        var toPInBeta = function(c) {
            return new Expression.Polynomial(Polynomial.of(c));
        };
        polynomial = polynomial.map(function(c) {
            return new Expression.Polynomial(Polynomial.toPolynomial(c, new Expression.Symbol('β')));
        }); //TODO: ?
        var newPolynomial = Polynomial.resultant(polynomial, root.polynomial.map(toPInBeta)).polynomial.primitivePart();
        if (scale !== Expression.ONE) {
            // "unscale"
            newPolynomial = newPolynomial._scaleRoots(scale.inverse()).primitivePart();
        }
        return PolynomialRoot._calculateNewInterval(newPolynomial, function(precision) {
            return toSimpleInterval(new Expression.ExpressionPolynomialRoot(new LazyPolynomialRoot(p1, p2.scale(scale), root)), precision);
        });
    }
    LazyPolynomialRoot.prototype.multiply = function(other) {
        if (this._root.equals(other._root)) {
            return simplifyExpressionWithPolynomialRoot(this._p1.multiply(other._p1), this._p2.multiply(other._p2), this._root);
        }
        var root = upgrade(this._root, this._p1, this._p2).multiply(upgrade(other._root, other._p1, other._p2));
        return fromRoot(root);
    };
    LazyPolynomialRoot.prototype.add = function(other) {
        if (this._root.equals(other._root)) {
            var g = other._p2.getContent().gcd(this._p2.getContent());
            return simplifyExpressionWithPolynomialRoot(this._p1.multiply(other._p2.scale(g.inverse())).add(other._p1.multiply(this._p2.scale(g.inverse()))), this._p2.scale(g.inverse()).multiply(other._p2.scale(g.inverse())).scale(g), this._root);
        }
        var root = upgrade(this._root, this._p1, this._p2).add(upgrade(other._root, other._p1, other._p2));
        return fromRoot(root);
    };
    LazyPolynomialRoot.prototype.negate = function() {
        return new LazyPolynomialRoot(this._p1.negate(), this._p2, this._root);
    };
    LazyPolynomialRoot.prototype.inverse = function() {
        return simplifyExpressionWithPolynomialRoot(this._p2, this._p1, this._root);
    };
    LazyPolynomialRoot.prototype.sign = function() {
        if (this._p1.equals(Polynomial.ZERO)) {
            return 0;
        }
        //return this.e;
        //?
        //TODO: ???
        //var s = toDecimalStringInternal(new Expression.ExpressionPolynomialRoot(this), {significantDigits: 1});
        //return s.startsWith('-') ? -1 : +1;
        var precision = 1;
        while (true) {
            var interval = this.toDecimal(precision);
            if (interval.a.getNumerator().sign() >= 0) {
                return +1;
            }
            if (interval.b.getNumerator().sign() <= 0) {
                return -1;
            }
            precision *= 2;
            if (precision > 8) {
                console.debug('hm...');
            }
        }
    };
    LazyPolynomialRoot.prototype._pow = function(n) {
        //TODO: modular exponentiation (?)
        return simplifyExpressionWithPolynomialRoot(this._p1._pow(n), this._p2._pow(n), this._root);
    };
    LazyPolynomialRoot.prototype._nthRoot = function(n) {
        //?
        if (this._p2.getDegree() === 0 && this._p2.getCoefficient(0).equals(Expression.ONE) && this._p1.getDegree() === 1 && this._p1.getCoefficient(0).equals(Expression.ZERO) && this._p1.getCoefficient(1).equals(Expression.ONE)) {
            //TODO: ?
            var newRoot = this._root._nthRoot(n);
            return new LazyPolynomialRoot(Polynomial.of(Expression.ZERO, Expression.ONE), Polynomial.of(Expression.ONE), newRoot);
        }
        var getPerfectPower = function(p, n) {
            var root = p.getSquareFreePolynomial();
            return root._pow(n).equals(p) ? root : null;
        };
        var root = getPerfectPower(this._p1, n);
        var c = this._p2.getCoefficient(0);
        if (root != null && this._p2.getDegree() === 0 && c instanceof Expression.Integer && c.sign() > 0) {
            return simplifyExpressionWithPolynomialRoot(root, Polynomial.of(c._nthRoot(n)), this._root);
        }
        return this.upgrade()._nthRoot(n);
    };
    LazyPolynomialRoot.prototype.equals = function(other) {
        if (this._root.equals(other._root)) {
            //TODO:? ?
            return this._p1.equals(other._p1) && this._p2.equals(other._p2) || this.add(other.negate()).sign() === 0;
        }
        //!TODO: remove (hack to avoid error)
        if (toDecimalStringInternal(new Expression.ExpressionPolynomialRoot(this), {
                significantDigits: 3
            }) !== toDecimalStringInternal(new Expression.ExpressionPolynomialRoot(other), {
                significantDigits: 3
            })) {
            return false;
        }
        //!
        var result = upgrade(this._root, this._p1, this._p2).equals(upgrade(other._root, other._p1, other._p2));
        return result;
    };
    PolynomialRoot.prototype.upgrade = function() {
        return this;
    };
    LazyPolynomialRoot.prototype.upgrade = function() {
        return fromRoot(upgrade(this._root, this._p1, this._p2));
    };
    PolynomialRoot.prototype._calc = function(polynomial) {
        return upgrade(this, polynomial.calcAt($α()));
    };
    LazyPolynomialRoot.prototype._calc = function(polynomial) {
        var e = polynomial.calcAt(this.getAlphaExpression());
        return simplifyExpressionWithPolynomialRoot(Polynomial.toPolynomial(e.getNumerator(), $α()), Polynomial.toPolynomial(e.getDenominator(), $α()), this._root);
    };
    PolynomialRoot.prototype.getAlpha = function(polynomial) {
        // simple object is returned to not expose the PolynomialRoot
        return {
            polynomial: this.polynomial,
            interval: this.interval
        };
    };
    LazyPolynomialRoot.prototype.getAlpha = function(polynomial) {
        return this._root.getAlpha();
    };
    //TODO: return polynomials (?)
    PolynomialRoot.prototype.getAlphaExpression = function(polynomial) {
        return $α();
    };
    LazyPolynomialRoot.prototype.getAlphaExpression = function(polynomial) {
        return this._p1.calcAt($α()).divide(this._p2.calcAt($α()));
    };
    PolynomialRoot.prototype.getAlphaPolynomial = function(polynomial) {
        return Polynomial.of(Expression.ZERO, Expression.ONE);
    };
    LazyPolynomialRoot.prototype.getAlphaPolynomial = function(polynomial) {
        return [this._p1, this._p2];
    };

    //LazyPolynomialRoot.PolynomialRoot = PolynomialRoot;//TODO: REMOVE!!!

    globalThis.testables = globalThis.testables || {};
    globalThis.testables.LazyPolynomialRoot = LazyPolynomialRoot;
    globalThis.testables.PolynomialRoot = PolynomialRoot;
    globalThis.testables.toSimpleInterval = toSimpleInterval;
    globalThis.testables.SimpleInterval = SimpleInterval;
    if (true) {
        //TODO: move to tests
        console.assert(Object.keys(PolynomialRoot).join(' ') === Object.keys(LazyPolynomialRoot).join(' '));
        console.assert(Object.keys(PolynomialRoot.prototype).join(' ') === Object.keys(LazyPolynomialRoot.prototype).join(' '));
        console.assert(PolynomialRoot.prototype.__proto__ === LazyPolynomialRoot.prototype.__proto__);
    }

    //self.PolynomialRoot = PolynomialRoot;
    self.LazyPolynomialRoot = LazyPolynomialRoot;
})();
(function() {
    "use strict";




    //TODO: !?


    //var SimpleInterval = LazyPolynomialRoot.SimpleInterval;
    //var PolynomialRoot = LazyPolynomialRoot.PolynomialRoot;


    function PolynomialRootSymbol(polynomial, interval) {
        Expression.Symbol.call(this, "[root of " + polynomial + " near " + interval.a.add(interval.b).divide(Expression.TWO).toString() + "]");
        this.polynomial = polynomial;
        //TODO: https://www.wolframalpha.com/input/?i=x**5%2B7x**3%2Bx**2%2Bx%2B1%3D0
        this.interval = interval;
    }
    PolynomialRootSymbol.prototype = Object.create(Expression.Symbol.prototype);

    PolynomialRootSymbol.prototype.toDecimal = function(precision) {
        return this.polynomial.getZero(this.interval, precision);
    };

    PolynomialRootSymbol.prototype.isExact = function() {
        //TODO: fix - ?
        return false;
    };


    PolynomialRootSymbol.prototype.toMathML = function(options) {
        options = options || {};
        if (options.fractionDigits != null) {
            throw new TypeError('options.fractionDigits is deprecated, please use options.rounding');
        }
        var rounding = options.rounding || {
            fractionDigits: 3
        };
        var tmp = toDecimalStringInternal(this, rounding, Expression._decimalToMathML, Expression._complexToMathML);
        return tmp;
    };

    PolynomialRootSymbol.prototype.isNegative = function() {
        return this.sign() < 0;
    };

    Expression.PolynomialRootSymbol = PolynomialRootSymbol;

    function isSameRoot(x, y) {
        return x instanceof Expression.PolynomialRootSymbol && y instanceof Expression.PolynomialRootSymbol && x.polynomial.equals(y.polynomial) && x.interval.a.equals(y.interval.a) && x.interval.b.equals(y.interval.b);
    }

    function ExpressionWithPolynomialRoot(e, root) {
        this.e = e; // internal symbolic expression with a "root" as a symbol
        this.root = root;
    }




    ExpressionWithPolynomialRoot.prototype = Object.create(Expression.Symbol.prototype);

    /*
    ExpressionWithPolynomialRoot.prototype.compare4Multiplication = function (y) {
      return y.compare4MultiplicationExpressionWithPolynomialRoot(this);
    };
    ExpressionWithPolynomialRoot.prototype.compare4MultiplicationExpressionWithPolynomialRoot = function (x) {
      return 0;//?
    };
    Expression.prototype.compare4MultiplicationExpressionWithPolynomialRoot = function (x) {
      return this.compare4MultiplicationSymbol(x);//?
    };
    Expression.Symbol.prototype.compare4MultiplicationExpressionWithPolynomialRoot = function (x) {
      return -1;
    };
    ExpressionWithPolynomialRoot.prototype.compare4MultiplicationSymbol = function (x) {
      return +1;
    };
    */

    //Expression.prototype.isExact = function () {
    //  return true;
    //};
    ExpressionWithPolynomialRoot.prototype.isExact = function() {
        //TODO: fix - ?
        return false;
    };

    function simplifyExpressionWithPolynomialRoot(e, root) {
        var tmp = LazyPolynomialRoot._makeExpressionWithPolynomialRoot(Polynomial.toPolynomial(e.getNumerator(), root), Polynomial.toPolynomial(e.getDenominator(), root), root);
        var e1 = tmp[0].calcAt(root).divide(tmp[1].calcAt(root));
        if (tmp[0].getDegree() <= 0 &&
            tmp[1].getDegree() <= 0) {
            return e1;
        }
        return new ExpressionWithPolynomialRoot(e1, root);
    }

    ExpressionWithPolynomialRoot.prototype.negate = function() {
        return new ExpressionWithPolynomialRoot(this.e.negate(), this.root); // for performance
    };
    ExpressionWithPolynomialRoot.prototype.equals = function(other) {
        //!TODO: remove (hack to avoid error)
        if (this instanceof ExpressionWithPolynomialRoot && other instanceof ExpressionWithPolynomialRoot) {
            if (!isSameRoot(this.root, other.root)) {
                //var s1 = toDecimalStringInternal(new Expression.Addition(this.e, other.e.negate()), {fractionDigits: 3});
                //if (s1 != undefined && !s1.endsWith('000')) {
                //  return false;
                //}
                if (this.toMathML({
                        rounding: {
                            fractionDigits: 3
                        }
                    }) !== other.toMathML({
                        rounding: {
                            fractionDigits: 3
                        }
                    })) {
                    return false; //?
                }
                if (true) {
                    return this.upgrade().subtract(other.upgrade()).equals(Expression.ZERO);
                }
                var s = toDecimalStringInternal(new Expression.Addition(this.e, other.e.negate()), {
                    significantDigits: 1
                });
                //TODO: will it hang for zero?
                return s === '0';
            }
        }
        //!
        //if (Expression.has(other, Expression.NthRoot)) {
        //  return this.upgrade().equals(Expression.toPolynomialRoot(other));//!?
        //}
        // optimization
        var s = other instanceof Expression.Integer && other.equals(Expression.ZERO) ? this : this.subtract(other);
        return s instanceof ExpressionWithPolynomialRoot ? false : s.equals(Expression.ZERO);
    };
    ExpressionWithPolynomialRoot.prototype.simplifyExpression = function() {
        return this;
    };

    ExpressionWithPolynomialRoot.prototype.toString = function(options) {
        options = options || {};
        if (LazyPolynomialRoot._isSimpleForUpgrade(this.e, this.root)) {
            return this.upgrade().toString(options);
        }
        //TODO: return 'polynomial-root of x**2+2x+1 on [a; b]';
        //TODO:
        if (this.equals(Expression.ZERO)) {
            return Expression.ZERO.toString(options);
        }
        //return this.e.toString(options);
        if (options.fractionDigits != null) {
            throw new TypeError('options.fractionDigits is deprecated, please use options.rounding');
        }
        var rounding = options.rounding || {
            fractionDigits: 3
        };
        //if (true) {
        //  return Expression.toDecimalString(this.e, Object.assign({}, options, {rounding: rounding}));
        //}
        if (!Expression.isConstant(this.e)) {
            return this.upgrade().toString(options);
        }
        var tmp = toDecimalStringInternal(this.e, rounding, undefined, undefined);
        return tmp;
    };

    ExpressionWithPolynomialRoot.prototype.toMathML = function(options) {
        options = options || {};
        if (LazyPolynomialRoot._isSimpleForUpgrade(this.e, this.root)) {
            return this.upgrade().toMathML(options);
        }
        //TODO:
        if (this.equals(Expression.ZERO)) {
            return Expression.ZERO.toMathML(options);
        }
        //return this.e.toMathML(options);
        if (options.fractionDigits != null) {
            throw new TypeError('options.fractionDigits is deprecated, please use options.rounding');
        }
        var rounding = options.rounding || {
            fractionDigits: 3
        };
        if (true) {
            //return Expression.toDecimalString(this.e, );
            return this.e.toMathML(Object.assign({}, options, {
                rounding: rounding
            }));
        }
        var tmp = toDecimalStringInternal(this.e, rounding, Expression._decimalToMathML, Expression._complexToMathML);
        return tmp;
    };

    var calculateNewInterval = LazyPolynomialRoot._calculateNewInterval; //TODO: remove
    var toSimpleInterval = LazyPolynomialRoot._toSimpleInterval; //TODO: remove

    function upgrade(e, root) {
        if (e.equals(Expression.ZERO)) {
            return e;
        }
        if (e instanceof Expression.Integer) {
            return e;
        }
        var variable = root;
        //!new 2021-04-03
        if (true) {
            var p1 = Polynomial.toPolynomial(e.getNumerator(), variable);
            var p2 = Polynomial.toPolynomial(e.getDenominator(), variable);
            if (p1.hasIntegerCoefficients() && p2.hasIntegerCoefficients()) {
                if (e.getDenominator() instanceof Expression.Integer && !e.getDenominator().equals(Expression.ONE)) {
                    //TODO: optimize (?)
                    return upgrade(e.getNumerator(), root).divide(e.getDenominator());
                }
                // Let p1/p2 = beta, so beta is a root of Res_x(p1-beta*p2, p):
                //debugger;
                var resultant = Polynomial.toPolynomial(Polynomial.resultant(p1.subtract(Polynomial.of(new Expression.Symbol('β')).multiply(p2)), root.polynomial), new Expression.Symbol('β')).primitivePart();
                var tmp = calculateNewInterval(resultant, function(precision) {
                    return toSimpleInterval(e, precision);
                });
                var interval = tmp.interval;
                var newPolynomial = tmp.polynomial;
                return Expression.ExpressionPolynomialRoot._create(newPolynomial, interval);
            }
            //!new 2021-05-14 (TODO: CHECK)
            if (p2.hasIntegerCoefficients() && p1.hasComplexCoefficients()) {
                return upgrade(p1.map(function(c) {
                    return c instanceof Expression.Integer ? c : c.real;
                }).calcAt(variable).divide(p2.calcAt(variable)), root).add(upgrade(p1.map(function(c) {
                    return c instanceof Expression.Integer ? Expression.ZERO : c.imaginary;
                }).calcAt(variable).divide(p2.calcAt(variable)), root).multiply(Expression.I));
            }
            //!
            //TODO: using grouping
            //}
            //debugger;
        }
        //!

        var cache = null; //TODO: ?
        var root = null;
        return Expression._map(function(x) {
            return x instanceof Expression.PolynomialRootSymbol && !(x instanceof Expression.ExpressionPolynomialRoot) ? (x === cache ? root : (cache = x, root = Expression.ExpressionPolynomialRoot.create(x.polynomial, x.interval))) : x;
        }, e);
    }

    ExpressionWithPolynomialRoot.prototype.multiply = function(other) {
        if (other instanceof ExpressionWithPolynomialRoot) {
            if (this.root !== other.root && !isSameRoot(this.root, other.root)) {
                return this.upgrade().multiply(other.upgrade());
            }
            return this.multiply(other.e);
        }
        if (Expression.has(other, Expression.ExpressionPolynomialRoot)) { //TODO: ?
            return this.upgrade().multiply(other);
        }
        return simplifyExpressionWithPolynomialRoot(this.e.multiply(other), this.root);
    };
    ExpressionWithPolynomialRoot.prototype.add = function(other) {
        if (other instanceof ExpressionWithPolynomialRoot) {
            if (this.root !== other.root && !isSameRoot(this.root, other.root)) {
                return this.upgrade().add(other.upgrade());
            }
            return this.add(other.e);
        }
        if (Expression.has(other, Expression.ExpressionPolynomialRoot)) { //TODO: ?
            return this.upgrade().add(other);
        }
        return simplifyExpressionWithPolynomialRoot(this.e.add(other), this.root);
    };





    ExpressionWithPolynomialRoot.prototype.divide = function(other) {
        if (other.equals(Expression.ONE)) {
            return this;
        }
        if (other instanceof ExpressionWithPolynomialRoot) {
            if (this.root !== other.root && !isSameRoot(this.root, other.root)) {
                return this.upgrade().divide(other.upgrade());
            }
            return this.divide(other.e);
        }
        if (Expression.has(other, Expression.ExpressionPolynomialRoot)) { //TODO: ?
            return this.upgrade().divide(other);
        }
        return simplifyExpressionWithPolynomialRoot(this.e.divide(other), this.root);
    };

    ExpressionWithPolynomialRoot.prototype.divideExpression = function(other) {
        if (Expression.has(other, Expression.ExpressionPolynomialRoot)) { //TODO: ?
            return other.divide(this.upgrade());
        }
        return simplifyExpressionWithPolynomialRoot(other.divide(this.e), this.root);
    };
    ExpressionWithPolynomialRoot.prototype.multiplyExpression = function(other) {
        if (other.equals(Expression.ONE)) {
            return this;
        }
        if (Expression.has(other, Expression.ExpressionPolynomialRoot)) { //TODO: ?
            return other.multiply(this.upgrade());
        }
        return simplifyExpressionWithPolynomialRoot(other.multiply(this.e), this.root);
    };
    ExpressionWithPolynomialRoot.prototype.addExpression = function(other) {
        if (Expression.has(other, Expression.ExpressionPolynomialRoot)) { //TODO: ?
            return other.add(this.upgrade());
        }
        return simplifyExpressionWithPolynomialRoot(other.add(this.e), this.root);
    };

    ExpressionWithPolynomialRoot.prototype.getPrecedence = function() {
        if (Expression.isReal(this)) {
            return 1000;
        }
        //return this.e.getPrecedence();//? - division
        return 2; // it can be a complex number
    };
    ExpressionWithPolynomialRoot.prototype.isRightToLeftAssociative = function() {
        return true;
    };
    ExpressionWithPolynomialRoot.prototype.isUnaryPlusMinus = function() {
        if (Expression.isReal(this)) {
            return false;
        }
        return true;
    };

    ExpressionWithPolynomialRoot.prototype.isNegative = function() {
        //TODO: ?
        if (Expression.isReal(this)) {
            return !Expression._isPositive(this);
        }
        return this.e.isNegative();
    };


    ExpressionWithPolynomialRoot.prototype._nthRoot = function(n) { //?
        if (this.e === this.root) { //TODO: ?
            // PolynomialRootSymbol#_nthRoot - ?
            if (this.root.interval.a.getNumerator().compareTo(Expression.ZERO) < 0 && n % 2 === 0) {
                if (n !== 2) {
                    throw new RangeError();
                }
                //TODO: check
                var newRoot = new Expression.PolynomialRootSymbol(this.root.polynomial._scaleRoots(Expression.ONE.negate()), {
                    a: this.root.interval.b.negate(),
                    b: this.root.interval.a.negate()
                });
                return Expression.I.multiply(new ExpressionWithPolynomialRoot(newRoot, newRoot)._nthRoot(n));
            }
            var newPolynomial = this.root.polynomial._exponentiateRoots(1 / n);

            var e = Expression.NthRoot.makeRoot(this.e, n);
            var tmp = calculateNewInterval(newPolynomial, function(precision) {
                return toSimpleInterval(e, precision);
            });
            var interval = tmp.interval;
            newPolynomial = tmp.polynomial;

            var newRoot = new Expression.PolynomialRootSymbol(newPolynomial, interval);
            if (newRoot.polynomial.numberOfRoots(newRoot.interval) === 1) {
                return new ExpressionWithPolynomialRoot(newRoot, newRoot);
            } else {
                console.assert(false);
                debugger;
            }
        }
        if (!(this.e instanceof Expression.Exponentiation)) {
            if (true && n === 2) {
                return this.upgrade()._nthRoot(n);
            }
        }
        var getPerfectPower = function(e1, n, v) {
            var p = Polynomial.toPolynomial(e1, v);
            var root = p.getSquareFreePolynomial();
            return root._pow(n).equals(p) ? root.calcAt(v) : null;
        };
        var root = getPerfectPower(this.e.getNumerator(), n, this.root);
        if (root == null || !Expression.isReal(this.e)) {
            return this.upgrade()._nthRoot(n);
        }
        return simplifyExpressionWithPolynomialRoot(this.e._nthRoot(n), this.root);
    };
    ExpressionWithPolynomialRoot.prototype.pow = function(count) {
        if (count instanceof Expression.Division && count.getDenominator() instanceof Expression.Integer) {
            return this._nthRoot(count.getDenominator().toNumber()).pow(count.getNumerator());
        }
        //TODO: upgrade (?)
        return simplifyExpressionWithPolynomialRoot(this.e.pow(count), this.root);
    };
    ExpressionWithPolynomialRoot.prototype._pow = function(count) {
        return simplifyExpressionWithPolynomialRoot(this.e.getNumerator()._pow(count), this.root).divide(simplifyExpressionWithPolynomialRoot(this.e.getDenominator()._pow(count), this.root));
    };

    //TODO: remove
    ExpressionWithPolynomialRoot.prototype.upgrade = function() {
        return upgrade(this.e, this.root);
    };

    ExpressionWithPolynomialRoot.prototype.complexConjugate = function() {
        return simplifyExpressionWithPolynomialRoot(this.e.complexConjugate(), this.root);
    };

    ExpressionWithPolynomialRoot.prototype.toDecimal = function(precision) {
        precision = precision == undefined ? 0 : precision;

        return this.e === this.root ? this.root.toDecimal(precision) : this.upgrade().toDecimal(precision);
    };


    //!new
    ExpressionWithPolynomialRoot.prototype._calc = function(polynomial) {
        return simplifyExpressionWithPolynomialRoot(polynomial.calcAt(this.e), this.root);
    };

    self.ExpressionWithPolynomialRoot = ExpressionWithPolynomialRoot;

})();
(function() {
    "use strict";

    //TODO: !?


    function SomePolynomialRoot(e, polynomial) {
        this.e = e; // internal symbolic expression with a "root" as a symbol
        this.polynomial = polynomial;
    }

    SomePolynomialRoot.prototype = Object.create(Expression.Symbol.prototype);

    function alpha() {
        return new Expression.Symbol('alpha');
    }

    SomePolynomialRoot.create = function(polynomial) {
        return new SomePolynomialRoot(alpha(), polynomial);
    };

    SomePolynomialRoot.prototype.isExact = function() {
        return false;
    };

    function simplifyExpressionWithPolynomialRoot(e, polynomial) {

        var n = Polynomial.toPolynomial(e.getNumerator(), alpha()).divideAndRemainder(polynomial).remainder;
        var d = Polynomial.toPolynomial(e.getDenominator(), alpha()).divideAndRemainder(polynomial).remainder;
        if (d.getDegree() > 0) {
            var scale = d.modularInverse(polynomial).primitivePart();
            d = d.multiply(scale).divideAndRemainder(polynomial).remainder;
            n = n.multiply(scale).divideAndRemainder(polynomial).remainder;
        }
        var e1 = n.calcAt(alpha()).divide(d.calcAt(alpha()));
        if (e1 instanceof Expression.Integer) {
            return e1;
        }
        return new SomePolynomialRoot(e1, polynomial);
    }

    SomePolynomialRoot.prototype.negate = function() {
        return simplifyExpressionWithPolynomialRoot(this.e.negate(), this.polynomial);
    };
    SomePolynomialRoot.prototype.equals = function(other) {
        if (other === Expression.ZERO) {
            return false;
        }
        return this.subtract(other).equals(Expression.ZERO);
    };
    SomePolynomialRoot.prototype.simplifyExpression = function() {
        return this;
    };

    SomePolynomialRoot.prototype.toString = function(options) {
        throw new TypeError();
    };

    SomePolynomialRoot.prototype.toMathML = function(options) {
        throw new TypeError();
    };

    SomePolynomialRoot.prototype.multiply = function(other) {
        if (other instanceof SomePolynomialRoot) {
            if (!this.polynomial.equals(other.polynomial)) {
                throw new TypeError();
            }
            return simplifyExpressionWithPolynomialRoot(this.e.multiply(other.e), this.polynomial);
        }
        return simplifyExpressionWithPolynomialRoot(this.e.multiply(other), this.polynomial);
    };
    SomePolynomialRoot.prototype.add = function(other) {
        if (other instanceof SomePolynomialRoot) {
            if (!this.polynomial.equals(other.polynomial)) {
                throw new TypeError();
            }
            return simplifyExpressionWithPolynomialRoot(this.e.add(other.e), this.polynomial);
        }
        return simplifyExpressionWithPolynomialRoot(this.e.add(other), this.polynomial);
    };
    SomePolynomialRoot.prototype.inverse = function() {
        return simplifyExpressionWithPolynomialRoot(this.e.inverse(), this.polynomial);
    };

    SomePolynomialRoot.prototype.divide = function(other) {
        return this.multiply(other.inverse());
    };

    SomePolynomialRoot.prototype.divideExpression = function(other) {
        return other.multiply(this.inverse());
    };
    SomePolynomialRoot.prototype.multiplyExpression = function(other) {
        return simplifyExpressionWithPolynomialRoot(other.multiply(this.e), this.polynomial);
    };
    SomePolynomialRoot.prototype.addExpression = function(other) {
        return simplifyExpressionWithPolynomialRoot(other.add(this.e), this.polynomial);
    };

    SomePolynomialRoot.prototype.getPrecedence = function() {
        throw new TypeError();
    };
    SomePolynomialRoot.prototype.isRightToLeftAssociative = function() {
        throw new TypeError();
    };
    SomePolynomialRoot.prototype.isUnaryPlusMinus = function() {
        throw new TypeError();
    };
    SomePolynomialRoot.prototype.isNegative = function() {
        throw new TypeError();
    };


    SomePolynomialRoot.prototype._nthRoot = function(n) { //?
        throw new TypeError();
    };
    SomePolynomialRoot.prototype.pow = function(count) {
        throw new TypeError();
    };
    SomePolynomialRoot.prototype._pow = function(count) {
        throw new TypeError();
    };


    SomePolynomialRoot.prototype.calcAt = function(x, xPows) {
        var c = function(e) {
            var p = Polynomial.toPolynomial(e, alpha());
            //return p.calcAt(root);
            var s = Expression.ZERO;
            var start = Date.now();
            while (xPows.length <= p.getDegree()) {
                xPows.push(xPows[xPows.length - 1].multiply(x));
            }
            var end = Date.now();
            if (end - start > 10) {
                console.log('xPows', end - start);
            }
            for (var i = 0; i <= p.getDegree(); i += 1) {
                s = s.add(p.getCoefficient(i).multiply(xPows[i]));
            }
            return s;
        };
        var e = this.e;
        var e1 = c(e.getNumerator()).divide(c(e.getDenominator()));
        return e1;
    };

    self.SomePolynomialRoot = SomePolynomialRoot;

})();
(function() {
    "use strict";











    /*
    Expression.PolynomialRootSymbol = function () {
      throw new TypeError();
    };
    function ExpressionWithPolynomialRoot() {
      throw new TypeError();
    }
    */

    Expression.ExpressionWithPolynomialRoot = ExpressionWithPolynomialRoot;


    // wrapper around PolynomialRoot
    function ExpressionPolynomialRoot(root) {
        var alpha = root.getAlpha();
        var $tmpp1_p2 = root.getAlphaPolynomial();
        var p1 = $tmpp1_p2[0];
        var p2 = $tmpp1_p2[1];
        var polynomial = alpha.polynomial;
        var interval = alpha.interval;
        if (p1.getDegree() <= 0 && p2.getDegree() <= 0) {
            return p1.getCoefficient(0).divide(p2.getCoefficient(0));
        }
        if (polynomial.getDegree() === 1 || polynomial.getDegree() === 2 || (polynomial.getDegree() === 4 && false) || polynomial.getDegree() === polynomial.getGCDOfTermDegrees()) { //TODO: other - ? like biqudratic - ?
            var roots = polynomial.getDegree() === polynomial.getGCDOfTermDegrees() && polynomial.getDegree() % 2 === 1 ? [polynomial.getCoefficient(0).negate().divide(polynomial.getLeadingCoefficient())._nthRoot(polynomial.getDegree())] : polynomial.getroots();
            for (var iteratorrr = roots[globalThis.Symbol.iterator](), rr = iteratorrr.next().value; rr != null; rr = iteratorrr.next().value) {
                if (!Expression.has(rr, ExpressionPolynomialRoot)) { //?
                    if (Expression._isPositive(rr.subtract(interval.a)) && Expression._isPositive(rr.subtract(interval.b).negate()) || rr.equals(interval.b) || rr.equals(interval.a)) {
                        if (p1.getDegree() === 1 && p1.getCoefficient(0).equals(Expression.ZERO) && p1.getCoefficient(1).equals(Expression.ONE) && p2.getDegree() === 0 && p2.getCoefficient(0).equals(Expression.ONE)) { //TODO: ???
                            return rr; //TODO: MOVE!
                        } else {
                            var n = p1.calcAt(rr);
                            var d = p2.calcAt(rr);
                            return n.divide(d);
                        }
                    }
                }
            }
        }
        if (polynomial.getDegree() < 3) {
            throw new TypeError();
        }
        if (polynomial.getDegree() / polynomial.getGCDOfTermDegrees() > 64 * 2 * 32) {
            throw new Error(); //TODO: too long
        }
        Expression.Symbol.call(this, null); // root.toString() - slow
        this.root = root;
        Object.freeze(this);
    }
    ExpressionPolynomialRoot.prototype = Object.create(Expression.Symbol.prototype);

    ExpressionPolynomialRoot.create = function(polynomial, interval, options) {
        return new ExpressionPolynomialRoot(LazyPolynomialRoot.create(polynomial, interval, options));
    };

    ExpressionPolynomialRoot.prototype.multiplyInteger = function(x) {
        return x.multiplyPolynomialRoot(this);
    };
    ExpressionPolynomialRoot.prototype.multiply = function(e) {
        return e.multiplyPolynomialRoot(this);
    };
    ExpressionPolynomialRoot.prototype.multiplyExpression = function(e) {
        if (e.equals(Expression.ONE)) {
            return this;
        }
        //?
        //TODO: fix
        if (Expression.isConstant(e) && !Expression.has(e, Expression.Complex)) {
            return this.multiply(e);
        }
        return Expression.Symbol.prototype.multiplyExpression.call(this, e);
    };
    ExpressionPolynomialRoot.prototype.multiplyAddition = function(e) { // for performance (?) when `e` is a constant
        if (Expression.isConstant(e) && !Expression.has(e, Expression.Complex)) {
            return this.multiplyExpression(e);
        }
        return Expression.Symbol.prototype.multiplyAddition.call(this, e);
    };
    ExpressionPolynomialRoot.prototype.multiplyComplex = function(x) {
        return this.multiply(x);
    };
    Expression.prototype.multiplyPolynomialRoot = function(root) {
        if (Expression.isRealAlgebraicNumber(this) &&
            !Expression.has(this, Expression.ExpressionWithPolynomialRoot)) {
            var k = this;
            if (k.equals(Expression.ZERO)) {
                return k;
            }
            if (k.equals(Expression.ONE)) {
                return root;
            }
            return new ExpressionPolynomialRoot(root.root.scale(k));
        }
        if (this instanceof Expression.Complex && !this.imaginary.equals(Expression.ONE)) {
            return this.imaginary.multiply(root).multiply(Expression.I).add(this.real.multiply(root));
        }
        //TODO: ?
        //throw new Error();
        return this.multiplyExpression(root);
    };
    ExpressionPolynomialRoot.prototype._pow = function(n) {
        return new ExpressionPolynomialRoot(this.root._pow(n));
    };
    ExpressionPolynomialRoot.prototype.pow = function(e) {
        if (e instanceof Expression.Integer) {
            return this._pow(e.toNumber());
        }
        //TODO: upgrade (?)
        //TODO: ?
        if (e instanceof Expression.Division && e.getDenominator() instanceof Expression.Integer) {
            //TODO: verify
            return this._nthRoot(e.getDenominator().toNumber()).pow(e.getNumerator());
        }
        return Expression.Symbol.prototype.pow.call(this, e);
    };
    ExpressionPolynomialRoot.prototype.multiplyPolynomialRoot = function(x) {
        var y = this;
        return new ExpressionPolynomialRoot(x.root.multiply(y.root));
    };
    ExpressionPolynomialRoot.prototype.add = function(e) {
        return e.addPolynomialRoot(this);
    };
    ExpressionPolynomialRoot.prototype.addPolynomialRoot = function(x) {
        var y = this;
        return new ExpressionPolynomialRoot(x.root.add(y.root));
    };
    Expression.prototype.addPolynomialRoot = function(root) {
        if (Expression.isRealAlgebraicNumber(this) &&
            !Expression.has(this, Expression.ExpressionWithPolynomialRoot)) {
            var k = this;
            if (k.equals(Expression.ZERO)) { // for performance
                return root;
            }
            return new ExpressionPolynomialRoot(root.root.translate(k));
        }
        //throw new Error();
        return this.addExpression(root);
    };
    ExpressionPolynomialRoot.prototype.addExpression = function(e) {
        return this.add(e); //!?
    };
    ExpressionPolynomialRoot.prototype.divide = function(e) {
        //if (e.equals(Expression.ONE)) {
        //  return this;
        //}
        //if (!(e instanceof ExpressionPolynomialRoot) && !Expression.isConstant(e) || Expression.has(e, Expression.Matrix) || Expression.has(e, Expression.MatrixSymbol)) {
        //TODO: why - ?
        //  throw new Error();
        //}
        if (e instanceof Expression.Exponentiation) {
            return e.divideExpression(this); //?TODO: HACKs
        }
        if (e instanceof Expression.Multiplication && e.a instanceof Expression.Integer && e.b instanceof Expression.Exponentiation) { //TODO: ?
            return this.multiply(e.a.inverse()).divide(e.b);
        }
        return this.multiply(e.inverse());
    };
    ExpressionPolynomialRoot.prototype.divideExpression = function(x) {
        return x.multiply(this.inverse());
    };
    ExpressionPolynomialRoot.prototype.inverse = function() {
        return new ExpressionPolynomialRoot(this.root.inverse());
    };
    ExpressionPolynomialRoot.prototype.sign = function() {
        return this.root.sign();
    };
    var toRadicalExpression = function(root) {
        root = root.upgrade();
        var polynomialRoot = root.getAlpha();
        //TODO: root.getAlphaExpression()
        if (polynomialRoot.polynomial.getDegree() === 1) {
            //TODO: ???
            return polynomialRoot.polynomial.getroots()[0];
        }
        //TODO: ?
        var g = polynomialRoot.polynomial.getGCDOfTermDegrees();
        if (g > 1) {
            var v = toRadicalExpression(root._pow(g));
            if (v != null) {
                var vg = Expression.NthRoot.makeRoot(v, g);
                return g % 2 === 1 || root.sign() > 0 ? vg : new Expression.Negation(vg);
            }
        }
        // convert to depressed:
        var h = polynomialRoot.polynomial._getShiftToDepressed();
        if (!h.equals(Expression.ZERO)) {
            var tmp = toRadicalExpression(root.translate(h));
            if (tmp != null) {
                return new Expression.Addition(tmp, h.negate());
            }
        }
        return null;
    };

    ExpressionPolynomialRoot.prototype.toString = function(options) {
        //return new ExpressionWithPolynomialRoot(this, this).toString(options);
        options = options || {};
        if (options.rounding == null) {
            var p = this.root.getAlpha().polynomial;
            if (p.getDegree() / p.getGCDOfTermDegrees() < 10 && LazyPolynomialRoot._isSimpleForUpgrade(this.root.getAlphaExpression(), new Expression.Symbol('α'))) { //TODO: REMOVE !!!
                var re = toRadicalExpression(this.root);
                if (re != null) {
                    return re.toString(options);
                }
            }
        }
        return toDecimalStringInternal(this, options.rounding || {
            fractionDigits: 3
        });
    };
    ExpressionPolynomialRoot.prototype.equals = function(other) {
        if (other instanceof ExpressionPolynomialRoot) {
            return this.root.equals(other.root);
        }
        // optimization
        if (other instanceof Expression.Integer) {
            if (other.equals(Expression.ZERO)) {
                return false;
            }
        }
        if (!Expression.isRealAlgebraicNumber(other)) { //to avoid bugs with i**n
            return false;
        }
        /*if (Expression.isConstant(other)) {
          if (!this.root.polynomial.calcAt(other).equals(Expression.ZERO)) {
            return false;
          }
          var withinInterval = function (x, interval) {
            return Expression._isPositive(x.subtract(interval.a)) && Expression._isPositive(x.subtract(interval.b).negate());
          };
          return withinInterval(other, this.interval);
        }*/
        //TODO: optimize
        return this.subtract(other).equals(Expression.ZERO);
    };
    ExpressionPolynomialRoot.prototype.compare4MultiplicationComplex = function(x) {
        return -1;
        //return +1;
    };
    ExpressionPolynomialRoot.prototype.compare4MultiplicationNthRoot = function(x) {
        return 0;
    };
    ExpressionPolynomialRoot.prototype.compare4Multiplication = function(y) {
        if (y instanceof Expression.Complex) {
            return +1;
            //return -1;
        }
        if (y instanceof Expression.Integer) {
            return +1;
        }
        if (y instanceof ExpressionPolynomialRoot) {
            return 0;
        }
        if (y instanceof Expression.NthRoot) {
            return 0; //?
        }
        if (y instanceof Expression.Symbol) {
            return -1;
        }
        return Expression.Symbol.prototype.compare4Multiplication.call(this, y);
    };
    ExpressionPolynomialRoot.prototype.compare4MultiplicationSymbol = function(x) {
        return +1;
    };
    ExpressionPolynomialRoot.prototype.compare4Addition = function(y) {
        if (y instanceof ExpressionPolynomialRoot) {
            return 0; //?
        }
        if (y instanceof Expression.Symbol) {
            return +1;
        }
        if (y instanceof Expression.NthRoot) {
            return 0; //?
        }
        if (Expression.isRealAlgebraicNumber(y)) {
            return 0; //?
        }
        return Expression.Symbol.prototype.compare4Addition.call(this, y);
    };
    ExpressionPolynomialRoot.prototype.compare4AdditionSymbol = function(x) {
        return -1;
    };
    ExpressionPolynomialRoot.prototype.compare4AdditionNthRoot = function(x) {
        return 0;
    };

    ExpressionPolynomialRoot.prototype._nthRoot = function(n) { //?
        if (this.root.sign() < 0 && n % 2 === 0) {
            if (n !== 2) {
                throw new RangeError("NotSupportedError");
            }
            //TODO: check
            return Expression.I.multiply(this.negate()._nthRoot(n));
        }
        return new ExpressionPolynomialRoot(this.root._nthRoot(n));
    };

    ExpressionPolynomialRoot.prototype.upgrade = function() {
        return new ExpressionPolynomialRoot(this.root.upgrade()); //TODO: ?
    };

    ExpressionPolynomialRoot.prototype.isNegative = function() {
        return this.root.sign() < 0;
    };

    Expression.prototype.upgrade = function() { //TODO: remove !!!
        return this;
    };

    ExpressionPolynomialRoot.prototype.isExact = function() {
        //TODO: fix - ?
        return false;
    };

    ExpressionPolynomialRoot.prototype.negate = function() {
        return new ExpressionPolynomialRoot(this.root.negate()); // for performance
    };

    ExpressionPolynomialRoot.prototype.simplifyExpression = function() { //TODO: remove - ?
        return this;
    };

    ExpressionPolynomialRoot.prototype.toMathML = function(options) {
        options = options || {};
        if (options.rounding == null) {
            var p = this.root.getAlpha().polynomial;
            if (p.getDegree() / p.getGCDOfTermDegrees() < 10 && LazyPolynomialRoot._isSimpleForUpgrade(this.root.getAlphaExpression(), new Expression.Symbol('α'))) { //TODO: REMOVE !!!
                var re = toRadicalExpression(this.root);
                if (re != null) {
                    return re.toMathML(options);
                }
            }
        }
        return toDecimalStringInternal(this, options.rounding || {
            fractionDigits: 3
        }, Expression._decimalToMathML, Expression._complexToMathML);
    };

    //TODO: ?????
    ExpressionPolynomialRoot.prototype.getPrecedence = function() {
        //TODO: avoid (?)
        if (true) {
            var p = this.root.getAlpha().polynomial;
            if (p.getDegree() / p.getGCDOfTermDegrees() < 10 && LazyPolynomialRoot._isSimpleForUpgrade(this.root.getAlphaExpression(), new Expression.Symbol('α'))) { //TODO: REMOVE !!!
                var re = toRadicalExpression(this.root);
                if (re != null) {
                    return re.getPrecedence();
                }
            }
        }
        return 1000;
    };
    ExpressionPolynomialRoot.prototype.isRightToLeftAssociative = function() {
        return true;
    };
    ExpressionPolynomialRoot.prototype.isUnaryPlusMinus = function() {
        return true; //TODO: !?
    };

    //ExpressionPolynomialRoot.prototype.complexConjugate = function () {//TODO: test
    //  return this;
    //};

    ExpressionPolynomialRoot.prototype._calc = function(polynomial) {
        return new ExpressionPolynomialRoot(this.root._calc(polynomial));
    };

    Expression.ExpressionPolynomialRoot = ExpressionPolynomialRoot;

    Expression.toPolynomialRoot = function(e) {
        var x = e instanceof Expression.NthRoot ? e.a : e; //TODO: remove
        var n = e instanceof Expression.NthRoot ? e.n : 1; //TODO: remove
        var symbol = new Expression.Symbol('x');
        if (!(x.getDenominator() instanceof Expression.Integer)) {
            throw new TypeError();
        }
        var p = Polynomial.toPolynomial(Expression.getConjugateExpression(symbol._pow(n).subtract(x).getNumerator()), symbol);
        //TODO: remove:
        if (p.getDegree() <= 8 && (true || isSmall(p))) { //TODO: ?
            var factor = p.factorize();
            if (factor != null && factor.getDegree() < p.getDegree() && factor.getDegree() === 4) { //?
                var roots = Polynomial.polynomialGCD(factor, Polynomial.toPolynomial(symbol._pow(n).subtract(x), symbol)).getroots();
                for (var iteratorroot = roots[globalThis.Symbol.iterator](), root = iteratorroot.next().value; root != null; root = iteratorroot.next().value) {
                    if (root._pow(n).equals(x)) {
                        //debugger;
                        return Expression._isPositive(root) || n % 2 !== 0 ? root : root.negate();
                    }
                }
            }
        }
        while (p.getDegree() > 0) {
            //var root = Expression.toPolynomialRoot(x)._nthRoot(n);

            //TODO: Expression#toPolynomialRoot() - ?
            //TODO: move up (!?)
            //p = p.squareFreeFactors().a1;//TODO: which one (?)
            var factor = p.factorize() || p;
            var isComplex = n === 2 && Expression.has(e.radicand, Expression.Complex);
            var zeros = factor.getZeros(isComplex);
            if (n % 2 === 0 && zeros.length === 2) {
                //TODO: remove
                if (Expression._isPositive(zeros[1]) && Expression._isPositive(x)) {
                    return zeros[1];
                }
            }
            //TODO: find zero only on interval
            for (var iteratorzero = zeros[globalThis.Symbol.iterator](), zero = iteratorzero.next().value; zero != null; zero = iteratorzero.next().value) {
                if (zero.root != null && Expression._isPositive(zero) || isComplex && Expression._isPositive(Expression.getComplexNumberParts(zero).real)) {
                    if (zero._pow(n).equals(x)) {
                        return zero;
                    }
                }
            }
            //TODO: ?
            p = p.divideAndRemainder(factor, "throw");
        }
        console.error(e.toString());
        return undefined;
    };



    Polynomial.prototype.signVariations = function() {
        var result = 0;
        var sign = 0;
        for (var i = this.a.size - 1; i >= 0; i -= 1) {
            var s = this.a.coefficient(i).sign();
            if (s !== 0) {
                if (sign === 0) {
                    sign = s;
                } else {
                    if (sign !== s) {
                        sign = s;
                        result += 1;
                    }
                }
            }
        }
        return result;
    };

    Polynomial.prototype._getNonNegativeRealRootIntervals = function() {
        // The polynomial should be square free, the check is commented out for performance
        //if (!this.isSquareFreePolynomial()) {
        //  throw new RangeError();
        //}
        // https://en.wikipedia.org/wiki/Real-root_isolation#Pseudocode
        var B = this.getPositiveRealRootsBound();
        if (B.equals(Expression.ZERO)) {
            return [];
        }
        // https://en.wikipedia.org/wiki/Real-root_isolation#Bisection_method
        var p = this._scaleRoots(B.inverse()); // map [0; B] to [0; 1]
        var maxPositiveRealRoots = (this.getCoefficient(0).equals(Expression.ZERO) ? 1 : 0) + this.signVariations();
        var L = function(a, b, q) { // get root intervals of q on [0; 1]
            var zero = q.getCoefficient(0).equals(Expression.ZERO);
            var newQ = zero ? q.divideAndRemainder(Polynomial.of(Expression.ZERO, Expression.ONE), "throw").quotient : q;
            var qq = newQ._exponentiateRoots(-1)._translateRoots(Expression.ONE.negate());
            //TODO: what is wrong with Wikipedia - ?
            var v = qq.signVariations();
            if (v === 1 && zero) {
                v = 0 / 0; //!?
            }
            if (v === 0 && zero) {
                return [{
                    a: a,
                    b: a
                }];
            }
            if (v === 1 && qq.getCoefficient(0).equals(Expression.ZERO)) {
                v = 0 / 0; //!?
            }
            if (v === 1) {
                return [{
                    a: a,
                    b: b
                }];
            } else if (v !== 0) {
                var firstQ = q._scaleRoots(Expression.TWO);
                var middle = a.add(b).divide(Expression.TWO);
                var first = L(a, middle, firstQ);
                if (first.length >= maxPositiveRealRoots) {
                    return first; //!
                }
                var secondQ = firstQ._translateRoots(Expression.ONE.negate());
                var second = L(middle, b, secondQ);
                return first.concat(second);
            }
            return [];
        };
        return L(Expression.ZERO, Expression.ONE, p).map(function(entry) {
            return ({
                a: entry.a.multiply(B),
                b: entry.b.multiply(B)
            });
        });
    };

    Polynomial.prototype.getRootIntervals = function() {
        return this._scaleRoots(Expression.ONE.negate())._getNonNegativeRealRootIntervals().map(function(entry) {
            return ({
                a: entry.b.negate(),
                b: entry.a.negate()
            });
        }).reverse().concat(this._getNonNegativeRealRootIntervals());
    };

    Polynomial.prototype.getPositiveRealRootsBound = function() {
        //TODO: only integer coefficients (?)
        // https://en.wikipedia.org/wiki/Sturm%27s_theorem#Number_of_real_roots
        // https://en.wikipedia.org/wiki/Geometrical_properties_of_polynomial_roots#Bounds_of_positive_real_roots
        var M = null;
        //TODO: fix the iteration
        var n = this.getDegree();
        var an = this.getLeadingCoefficient();
        for (var i = 0; i <= this.getDegree() - 1; i += 1) {
            var v = this.getCoefficient(i).negate().truncatingDivide(an);
            if (v.sign() >= 0) {
                var c = Expression.TWO.multiply(v._integerNthRoot(n - i).add(Expression.ONE));
                if (M == null || M.compareTo(c) < 0) {
                    M = c;
                }
            }
        }
        if (M == null) {
            return Expression.ZERO;
        }
        //!2020-12-19
        // round to a power of two:
        M = Expression.TWO._pow(M.getNumerator().bitLength() - M.getDenominator().bitLength() + 1);
        //!
        return M;
    };

    //TODO: BigDecimal - ?, rounding - ?
    Polynomial.prototype.getZero = function(interval, precision) {
        var floorDiv = function(a, b) {
            if (b.compareTo(Expression.ZERO) < 0) {
                a = a.negate();
                b = b.negate();
            }
            return a.compareTo(Expression.ZERO) >= 0 ? a.truncatingDivide(b) : a.add(Expression.ONE).truncatingDivide(b).subtract(Expression.ONE);
        };
        var roundFloor = function(point, e) {
            var n = point.getNumerator().multiply(e);
            var d = point.getDenominator();
            return floorDiv(n, d);
        };
        var sign = function(v) {
            return Math.sign(v.getNumerator().compareTo(Expression.ZERO));
        };
        //var BASE = Expression.TEN;
        var BASE = Expression.TWO;
        var e = Expression.pow(BASE, precision); // epsilon^-1
        if (!(e instanceof Expression.Integer)) {
            throw new RangeError("epsilon^-1 is not an integer");
        }
        var a = interval.a;
        var b = interval.b;
        // (b - a) * Math.pow(10, precision) > min(abs(a), abs(b))
        // (b - a) * Math.pow(10, fractionDigits) > 1
        //TODO: fix to use precision, not fractionDigits
        // e * (b - a) > 0:
        if (e.multiply(a.getDenominator().multiply(b.getNumerator()).subtract(b.getDenominator().multiply(a.getNumerator()))).compareTo(b.getDenominator().multiply(a.getDenominator())) > 0) {
            //TODO:
            var tmp = true && precision >= 16 / Math.log10(BASE.toNumber()) ? this.getZero(interval, Math.floor(precision / 4)) : interval;
            a = tmp.a;
            b = tmp.b;

            var n = this.getDegree();
            var p = this._scaleRoots(e);
            p = p.primitivePart(); //?
            var sa = roundFloor(a, e).add(Expression.ONE); // a.getNumerator().multiply(e).truncatingDivide(a.getDenominator()).add(Expression.ONE);//?
            var sb = roundFloor(b, e); // b.getNumerator().multiply(e).truncatingDivide(b.getDenominator());//?
            console.assert(sa.multiply(a.getDenominator()).subtract(a.getNumerator().multiply(e)).compareTo(Expression.ZERO) >= 0); // sa/e >= a
            console.assert(sb.multiply(b.getDenominator()).subtract(b.getNumerator().multiply(e)).compareTo(Expression.ZERO) <= 0); // sb/e <= b
            //TODO: bigdecimal - ?
            // remember values at boundaries to reuse in the loop:
            var pa = p.calcAt(sa);
            var pb = p.calcAt(sb);
            var spb = sign(pb);
            var spa = sign(pa);
            if (spa === 0) {
                return {
                    a: sa.divide(e),
                    b: sa.divide(e)
                };
            }
            if (spb === 0) {
                return {
                    a: sb.divide(e),
                    b: sb.divide(e)
                };
            }
            if (spa === spb) {
                if (spa !== (sign(this.calcAt(a)) || sign(this.calcAt(b).negate()) || spa)) {
                    return {
                        a: a,
                        b: sa.divide(e)
                    };
                }
                if (spb !== sign(this.calcAt(b))) {
                    return {
                        a: sb.divide(e),
                        b: b
                    };
                }
                throw new RangeError(); //?
            }
            a = sa;
            b = sb;
            // bisection method
            var cc = 0;
            var d = p.derive();
            var width = b.subtract(a);
            while (width.compareTo(Expression.ONE) > 0) { // b - a > 1
                var middle = a.add(width.truncatingDivide(Expression.TWO));
                //console.log(eval(a.divide(e).toString()) + ' - ' + eval(b.divide(e).toString()));
                //?
                if (cc % 3 !== 2 && width.compareTo(a.abs()) < 0) { // TODO: test for the case when a < 0
                    // TODO: better guesses
                    // Newton's method
                    var x = cc % 3 === 1 ? a : b;
                    var px = x === a ? pa : (x === b ? pb : undefined);
                    var c = d.calcAt(x);
                    if (!c.equals(Expression.ZERO)) {
                        x = x.subtract(px.truncatingDivide(c));
                        if (x.compareTo(a) <= 0) {
                            x = a.add(Expression.ONE);
                        }
                        if (x.compareTo(b) >= 0) {
                            x = b.subtract(Expression.ONE);
                        }
                        //console.log("N: " + a + "  - " + x);
                        middle = x;
                    }
                }
                cc += 1;
                //?
                var v = p.calcAt(middle);
                var sv = sign(v);
                if (sv === spb) {
                    b = middle;
                    pb = v;
                } else if (sv === spa) {
                    a = middle;
                    pa = v;
                } else {
                    a = middle;
                    b = middle;
                    pa = v;
                    pb = v;
                }
                width = b.subtract(a);
            }
            //console.debug(cc);
            a = a.divide(e);
            b = b.divide(e);
        }
        return {
            a: a,
            b: b
        };
    };

    Polynomial.prototype.hasRoot = function(polynomialRoot) {
        var f = this;
        if (f.equals(Polynomial.ZERO)) {
            return true;
        }
        //!new 2021-02-20 (TODO: CHECK)
        if (!f.hasIntegerCoefficients() && f.hasComplexCoefficients()) {
            return f.map(function(c) {
                return c instanceof Expression.Integer ? c : c.real;
            }).hasRoot(polynomialRoot) && f.map(function(c) {
                return c instanceof Expression.Integer ? Expression.ZERO : c.imaginary;
            }).hasRoot(polynomialRoot);
        }
        //!

        if (!f.hasIntegerCoefficients() &&
            !f.hasComplexCoefficients() &&
            !f._testCoefficients(function(c) {
                return !Expression.has(c, Expression.Complex);
            }) &&
            f._testCoefficients(function(c) {
                return Expression.isConstant(c);
            })) { // x-i^n
            return f.map(function(c) {
                    return Expression.getComplexNumberParts(c).real;
                }).hasRoot(polynomialRoot) &&
                f.map(function(c) {
                    return Expression.getComplexNumberParts(c).imaginary;
                }).hasRoot(polynomialRoot);
        }

        var p = polynomialRoot.polynomial;
        var g = null;
        //!
        if (!f.hasIntegerCoefficients()) {
            var variable = new Expression.Symbol('~');
            var ff = f.calcAt(variable);
            var tmp = Expression.getMultivariatePolynomial(ff);
            if (tmp != null && !tmp.v.equals(variable) && tmp.v instanceof Expression.Symbol) {
                g = Polynomial.polynomialGCD(Polynomial.toPolynomial(tmp.p.getContent(), variable), p);
            }
        }
        if (g == null) {
            g = Polynomial.polynomialGCD(f, p);
        }
        //!
        if (g.getDegree() < 1) {
            return false;
        }
        var i = polynomialRoot.interval;

        if (!g.hasIntegerCoefficients()) {
            //TODO: BUG?
            //?new
            var variable = new Expression.Symbol('$$');
            var e = g.calcAt(variable);
            var c = Expression.getComplexNumberParts(e);
            if (c != null && !c.imaginary.equals(Expression.ZERO)) {
                g = Polynomial.toPolynomial(c.real.subtract(c.imaginary.multiply(Expression.I)).multiply(e), variable).getSquareFreePolynomial();
            }
            //?
        }

        // https://en.wikipedia.org/wiki/Budan%27s_theorem#Budan's_statement
        // as we used gcd the number of roots should be <= 0 on this interval for g and so:
        var n = g._translateRoots(i.a.negate()).signVariations() - g._translateRoots(i.b.negate()).signVariations();
        return n % 2 === 1;
        //return g.numberOfRoots(i) === 1;
    };

    // get number of distinct roots on the closed interval [a, b]
    Polynomial.prototype.numberOfRoots = function(interval) {
        interval = interval == undefined ? null : interval;

        if (!this.hasIntegerCoefficients()) {
            //debugger;
            //return this.numberOfRoots3(interval);
            throw new RangeError();
        }
        if (interval == null) {
            interval = {
                a: this._scaleRoots(Expression.ONE.negate()).getPositiveRealRootsBound().negate(),
                b: this.getPositiveRealRootsBound()
            };
        }
        var p = this;
        if (!interval.a.equals(Expression.ZERO)) {
            p = p._scaleRoots(interval.a.inverse())
                ._translateRoots(Expression.ONE.negate());
            interval = {
                a: Expression.ZERO,
                b: interval.b.divide(interval.a).subtract(Expression.ONE)
            };
            if (interval.b.getNumerator().sign() < 0) {
                interval = {
                    a: interval.a,
                    b: interval.b.negate()
                };
                p = p._scaleRoots(Expression.ONE.negate());
            }
        }
        console.assert(interval.a.equals(Expression.ZERO));
        var zeros = 0;
        while (p.getCoefficient(zeros).equals(Expression.ZERO)) {
            zeros += 1;
        }
        if (zeros > 1) {
            throw new RangeError();
        }
        if (zeros > 0) {
            p = p.divideAndRemainder(Polynomial.of(Expression.ONE).shift(zeros), "throw").quotient;
        }
        return (zeros > 0 ? 1 : 0) +
            p._exponentiateRoots(-1)
            ._scaleRoots(interval.b)
            ._translateRoots(Expression.ONE.negate())
            ._getNonNegativeRealRootIntervals().length;
    };

    // Polynomial.toPolynomial(ExpressionParser.parse("x^3-8x^2+21x-18"), ExpressionParser.parse("x")).getZeros().toString()
    Polynomial.prototype.getZeros = function(complex) {
        complex = complex == undefined ? false : complex;

        if (this.getCoefficient(0).equals(Expression.ZERO)) {
            if (this.getLeadingCoefficient().equals(Expression.ZERO)) {
                throw new TypeError();
            }
            var i = 0;
            while (this.getCoefficient(i).equals(Expression.ZERO)) {
                i += 1;
            }
            var tmp = this.divideAndRemainder(Polynomial.of(Expression.ONE).shift(i)).quotient.getZeros(complex);
            return tmp.concat(new Array(i).fill(Expression.ZERO));
        }
        //TODO: test
        var content = this.getContent();
        var f = this.scale(content.getDenominator()).divideAndRemainder(Polynomial.of(content.getNumerator()), "throw").quotient;

        // https://en.wikipedia.org/wiki/Square-free_polynomial
        var tmp = f.squareFreeFactors();
        var a0 = tmp.a0;
        var a1 = tmp.a1;

        if (a0.getDegree() !== 0) {
            var tmp1 = a1.getZeros(complex); // roots with multiplicity = 1 (?)
            var tmp2 = a0.getZeros(complex);
            var result = [];
            var previous = undefined;
            for (var i = 0; i < tmp2.length; i += 1) {
                var zero = tmp2[i];
                if (zero !== previous) {
                    result.push(zero);
                    previous = zero;
                }
                result.push(zero);
            }
            return tmp1.concat(result);
        }

        var p = f;
        if (p.getDegree() === 0) {
            return [];
        }

        //!
        p = p.scale(p.getContent().inverse());
        //!

        if (!f.hasIntegerCoefficients()) {

            var toPolynomialWithIntegerCoefficients = function(polynomial) {
                if (!polynomial.hasIntegerCoefficients()) {
                    var variable = new Expression.Symbol('$$');
                    var e = polynomial.calcAt(variable);
                    var c = Expression.getConjugateExpression(e);
                    if (c != null && !c.equals(e)) {
                        //TODO: what if multiple (?) - ?
                        return Polynomial.toPolynomial(c, variable);
                    }

                    //!new 2022-08-28
                    // p_1(x, alpha) = 0
                    // p_2(alpha) = 0
                    // Res_alpha(p_1, p_2) = 0
                    var root = null;
                    for (var i = 0; i < polynomial.getDegree(); i += 1) {
                        var c = polynomial.getCoefficient(i);
                        if (c instanceof Expression.ExpressionPolynomialRoot) {
                            debugger;
                            var alpha = c.root.upgrade().getAlpha();
                            var v = new Expression.Symbol("$a");
                            var p_1 = Polynomial.toPolynomial(polynomial.map(function(cc) {
                                return cc === c ? v : cc;
                            }).calcAt(new Expression.Symbol('$$')), v);
                            var p_2 = alpha.polynomial;
                            var res = Polynomial.toPolynomial(Polynomial.resultant(p_1, p_2), new Expression.Symbol("$$")).primitivePart();
                            return toPolynomialWithIntegerCoefficients(res);
                        }
                    }
                }
                return polynomial;
            };

            //?new
            var f1 = toPolynomialWithIntegerCoefficients(f);
            if (!f1.equals(f)) {
                var result = [];
                var tmp = f1.getZeros(complex);
                console.time('checking roots');
                //TODO: do not check conjugate pairs (?) when polynomial has no integer factor
                for (var i = 0; i < tmp.length; i += 1) {
                    var zero = tmp[i];
                    if (zero instanceof ExpressionPolynomialRoot && zero.root.getAlphaExpression().equals(new Expression.Symbol('α')) ? f.hasRoot(zero.root.getAlpha()) :
                        zero instanceof ExpressionWithPolynomialRoot && zero.e === zero.root ? f.hasRoot(zero.root) :
                        (zero instanceof ExpressionWithPolynomialRoot ? zero._calc(f) : f.calcAt(zero)).equals(Expression.ZERO)) {
                        result.push(zero);
                    } else {
                        //TODO:?
                        console.debug(zero.root);
                    }
                }
                console.timeEnd('checking roots');
                return result;
            }
            //!new
            // u * x + v = t
            // u**n*x**n = a_n*x**n, u = a_n**(1/n)
            // u**(n-1)*x**(n-1)*v*n+u**(n-1)*x**(n-1) = a_(n-1)*x**(n-1)
            var u = Polynomial.of(Expression.ONE).shift(f.getDegree()).subtract(Polynomial.of(f.getLeadingCoefficient())).getroots();
            if (u.length !== 0) {
                u = u[0];
                var v = f.getCoefficient(f.getDegree() - 1).divide(u._pow(f.getDegree() - 1)).subtract(Expression.ZERO).divide(Expression.Integer.fromNumber(f.getDegree()));
                var x = new Expression.Symbol('$$'); //?
                var pt = Polynomial.toPolynomial(p.calcAt(x.subtract(v).divide(u)).getNumerator(), x);
                if (pt.hasIntegerCoefficients()) { //TODO: ?
                    return pt.getZeros(complex).map(function(zero) {
                        return zero.subtract(v).divide(u);
                    });
                }
            }
            //!
            //?
            console.debug('not all roots were found!!!');
            return [];
        }

        //!new
        if (p.getDegree() === 3) {
            //?
        }
        //!

        // https://en.wikipedia.org/wiki/Sturm%27s_theorem
        var intervals = p.getRootIntervals();

        // https://math.stackexchange.com/questions/309178/polynomial-root-finding
        // "it is guaranteed that there is a sign change inside every interval (because there are no repeated zeroes)"
        var result = new Array(intervals.length);
        var enableNewClass = true; //TODO: ?
        for (var i = 0; i < intervals.length; i += 1) {
            var zero = p.getZero(intervals[i], 0); //TODO: !?
            if (zero.a.equals(zero.b)) {
                result[i] = zero.a; //TODO: fix
            } else {
                //! p, not f, as f may have roots with multiplicity > 1
                if (!enableNewClass) {
                    var root = new Expression.PolynomialRootSymbol(p, zero);
                    result[i] = new ExpressionWithPolynomialRoot(root, root);
                } else {
                    //TODO: why skipFactorization if getZeros does not check for primitive polynomial
                    var root = ExpressionPolynomialRoot.create(p, zero, {
                        skipFactorization: true
                    });
                    //result[i] = new ExpressionWithPolynomialRoot(new Expression.Symbol('$α'), root);
                    result[i] = root;
                }
            }
        }
        //return result;

        //!new
        //var p = np;
        if (intervals.length !== p.getDegree() && true && complex) {
            //!new
            if (p.getDegree() >= 4) { //?
                var factor = p.factorize();
                if (factor != null) {
                    //TODO: remove double work
                    return factor.getZeros(complex).concat(p.divideAndRemainder(factor, "throw").quotient.getZeros(complex));
                }
            }
            //!
            if (p.isEven()) {
                //debugger;
                var zeros = p._exponentiateRoots(2).getZeros(complex);
                for (var iteratorzero = zeros[globalThis.Symbol.iterator](), zero = iteratorzero.next().value; zero != null; zero = iteratorzero.next().value) {
                    //var z = zero.squareRoot();
                    // https://en.wikipedia.org/wiki/Complex_number#Square_root
                    var squareRoot = function(z) {
                        var tmp = Expression.getComplexNumberParts(z);
                        var a = tmp.real;
                        var b = tmp.imaginary;
                        var aapbb = a._pow(2).add(b._pow(2)).squareRoot();
                        var γ = a.add(aapbb).divide(Expression.TWO).squareRoot();
                        var sign = (b.compareTo(Expression.ZERO) > 0 ? Expression.ONE : Expression.ONE.negate());
                        var tmp = a.negate().add(aapbb).divide(Expression.TWO);
                        //debugger;
                        var δ = sign.multiply(tmp.squareRoot());
                        return γ.add(δ.multiply(Expression.I));
                    };
                    //zero = zero instanceof ExpressionWithPolynomialRoot ? zero.upgrade() : zero;
                    if (!Expression._isPositive(zero)) {
                        var z = squareRoot(zero.e != null ? zero.upgrade() : zero);
                        result.push(z);
                        result.push(z.negate());
                    }
                }
                return result;
            }
            //var p = stringToPolynomial("x^5+2*x^2+2*x+3");

            var e = p.calcAt(new Expression.Symbol("a").add(new Expression.Symbol("b").multiply(Expression.I)));
            var ce = Expression.getComplexNumberParts(e);
            var cpa = ce.real; //TODO: ?
            var cpb = ce.imaginary.divide(new Expression.Symbol('b'));
            var getZeros1 = function(p) { //TODO: !? use everywhere (?)
                var tmp = p.squareFreeFactors();
                if (tmp.a0.getDegree() !== 0) {
                    return getZeros1(tmp.a0).concat(getZeros1(tmp.a1));
                }
                var factor = p.factorize();
                if (factor != null) {
                    //TODO: remove double work
                    //return factor.getZeros(false).concat(p.divideAndRemainder(factor, "throw").quotient.getZeros(false));
                    var tmp = getZeros1(factor);
                    var t = p.divideAndRemainder(factor, "throw").quotient;
                    if (0 === t._getNonNegativeRealRootIntervals().length) {
                        return tmp // do not call factorize as it is slow for large polynomials
                    }
                    return tmp.concat(getZeros1(t));
                }
                return p.getZeros(false);
            };

            //!TODO: 
            //!new 2021-01-03
            if (result.length < p.getDegree()) {
                //console.count('yyy');
                var resultant = function(v1, v2) {
                    var A = Polynomial.toPolynomial(cpa, new Expression.Symbol(v1));
                    var B = Polynomial.toPolynomial(cpb, new Expression.Symbol(v1));
                    return Polynomial.toPolynomial(Polynomial.resultant(A, B), new Expression.Symbol(v2)).primitivePart();
                };
                var bCandidates = getZeros1(resultant('a', 'b'));
                bCandidates = bCandidates.filter(function(c) {
                    return Expression._isPositive(c);
                }); //!?
                bCandidates = bCandidates.map(function(c) {
                    return c instanceof ExpressionWithPolynomialRoot && c.root.polynomial.getDegree() / c.root.polynomial.getGCDOfTermDegrees() <= 2 ? c.upgrade() : c;
                }); //TODO: !?
                //!new
                if (true) {
                    var A = Polynomial.toPolynomial(cpa, new Expression.Symbol('a')).map(function(c) {
                        return Polynomial.toPolynomial(c, new Expression.Symbol('b'));
                    });
                    var B = Polynomial.toPolynomial(cpb, new Expression.Symbol('a')).map(function(c) {
                        return Polynomial.toPolynomial(c, new Expression.Symbol('b'));
                    });
                    //var g0 = Polynomial.polynomialGCD(A, B);
                    //console.log(g0.toString());
                    var gp = undefined;
                    var previousPolynomial = Polynomial.ZERO; //TODO: !?
                    for (var iteratorb = bCandidates[globalThis.Symbol.iterator](), b = iteratorb.next().value; b != null; b = iteratorb.next().value) {
                        var g = null;
                        //TODO: fix access to private properties (!!!)
                        if ((!(b instanceof ExpressionWithPolynomialRoot) || !b.e.equals(b.root)) &&
                            (!(b instanceof ExpressionPolynomialRoot) || !b.root.getAlphaExpression().equals(new Expression.Symbol('α')))) { //TODO: ?
                            var A1 = A.map(function(c) {
                                return c.calcAt(b);
                            });
                            var B1 = B.map(function(c) {
                                return c.calcAt(b);
                            });
                            g = Polynomial.polynomialGCD(A1, B1);
                        } else {
                            var bRootPolynomial = (b instanceof ExpressionPolynomialRoot ? b.root.upgrade().getAlpha() : b.root).polynomial;
                            if (!previousPolynomial.equals(bRootPolynomial)) {
                                gp = polynomialGCDModuloPolynomial(A, B, bRootPolynomial);
                                gp = gp.map(function(c) {
                                    return c.polynomial;
                                });
                                previousPolynomial = bRootPolynomial;
                            }
                            //g = gp.map(function (c) { return c.calcAt(b); });
                            g = gp.map(function(c) {
                                return b._calc(c);
                            });

                            //debugger;
                            //var res = Polynomial.toPolynomial(Polynomial.resultant(gp.map(function (c) { return new Expression.Polynomial(c); }).calcAt(new Expression.Polynomial(Polynomial.of(RPN('a')))).polynomial.primitivePart(), bRootPolynomial), new Expression.Symbol("a")).primitivePart();
                            //res.getZeros();
                            //console.log(res.getDegree(), A.getDegree(), B.getDegree());
                        }
                        //TODO: g.getDegree() > 1 is possible (!!!)
                        if (g.getDegree() >= 3) {
                            console.log('g!!!', g.toString());
                            var polynomial0 = this;
                            window.setTimeout(function() {
                                throw new TypeError("good test: " + polynomial0.toString());
                            }, 0);
                        }
                        var getroots0 = function(np) { //TODO: REMOVE (g.getroots()) can be too slow
                            var p = np.getCoefficient(1).divide(np.getCoefficient(2));
                            var q = np.getCoefficient(0).divide(np.getCoefficient(2));
                            var pOver2Negate = p.divide(Expression.TWO).negate();
                            var sD = pOver2Negate._pow(2).subtract(q).squareRoot();
                            var x1 = pOver2Negate.subtract(sD);
                            var x2 = pOver2Negate.add(sD);
                            return [x1, x2];
                        };
                        if (g.getDegree() <= 2) {
                            //var roots = g.getroots();
                            var roots = g.getDegree() === 2 ? getroots0(g) : g.getroots();
                            for (var iteratora = roots[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
                                if (!Expression.has(a, Expression.Complex)) {
                                    var candidate = a.add(b.multiply(Expression.I));
                                    result.push(candidate);
                                    result.push(candidate.complexConjugate());
                                }
                            }
                        } else {
                            //debugger;
                            //TODO: ?
                        }
                    }
                }

                if (result.length < p.getDegree()) {
                    //debugger;
                    result = result.filter(function(root) {
                        return Expression.isReal(root);
                    });
                    var aCandidates = getZeros1(resultant('b', 'a'));

                    //!
                    //console.log(bCandidates.map(function (x) { return typeof x.upgrade === 'function' ?  x.upgrade() : x; }).toString());
                    //console.log(aCandidates.map(function (x) { return typeof x.upgrade === 'function' ?  x.upgrade() : x; }).toString());
                    // https://en.wikipedia.org/wiki/Resultant#Application_to_polynomial_systems
                    //debugger;
                    for (var iteratora = aCandidates[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
                        for (var iteratorb = bCandidates[globalThis.Symbol.iterator](), b = iteratorb.next().value; b != null; b = iteratorb.next().value) {
                            var candidate = a.add(b.multiply(Expression.I));
                            if (p.calcAt(candidate).equals(Expression.ZERO)) {
                                result.push(candidate);
                                result.push(candidate.complexConjugate());
                            }
                        }
                    }

                }
            }
        }
        //!

        return result;
    };

    function pseudoRemainderSequence(A, B, type, produceSturmSequence) {
        type = type == undefined ? "primitive" : type;
        produceSturmSequence = produceSturmSequence == undefined ? false : produceSturmSequence;

        var g = Math.gcd(A.getGCDOfTermDegrees(), B.getGCDOfTermDegrees());
        if (g > 1) {
            console.error('g > 1');
        }
        var first = true;
        var phi = Expression.ONE;
        var iterator = {
            next: function() {
                console.assert(A.getDegree() >= B.getDegree());
                if (!B.equals(Polynomial.ZERO)) {
                    var d = A.getDegree() - B.getDegree();
                    var scale = B.getLeadingCoefficient()._pow(d + 1);
                    var tmp = A.scale(produceSturmSequence ? scale.abs() : scale).divideAndRemainder(B, B._hasIntegerLikeCoefficients() ? "throw" : undefined);
                    var q = tmp.quotient;
                    var r = tmp.remainder;
                    var α = Expression.ONE;
                    if (type === "trivial") {
                        // https://en.wikipedia.org/wiki/Polynomial_greatest_common_divisor#Trivial_pseudo-remainder_sequence
                        α = Expression.ONE;
                    } else if (type === "primitive") {
                        // https://en.wikipedia.org/wiki/Polynomial_greatest_common_divisor#Primitive_pseudo-remainder_sequence
                        α = r.getContent();
                    } else if (type === "subresultant") {
                        // For the explanation and proof see Donald E. Knuth The Art of computer programming Third Edition, Volume 2 (Seminumerical algorithms), page 428.
                        // https://en.wikipedia.org/wiki/Polynomial_greatest_common_divisor#Subresultant_pseudo-remainder_sequence
                        α = first ? Expression.ONE : A.getLeadingCoefficient().multiply(phi._pow(d));
                        first = false;
                        phi = d === 0 ? phi : B.getLeadingCoefficient()._pow(d).divide(phi._pow(d).divide(phi));
                    } else {
                        throw new RangeError(type);
                    }
                    //var R = r.divideAndRemainder(Polynomial.of(produceSturmSequence ? α.abs().negate() : α), "throw").quotient;
                    var R = r.map(function(c) {
                        return c.divide(produceSturmSequence ? α.abs().negate() : α);
                    });
                    var value = {
                        R: R,
                        q: q,
                        α: α
                    };
                    A = B;
                    B = R;
                    return {
                        value: value,
                        done: false
                    };
                }
                return {
                    value: undefined,
                    done: true
                };
            }
        };
        iterator[globalThis.Symbol.iterator] = function() {
            return this;
        };
        return iterator;
    }

    Polynomial._pseudoRemainderSequence = pseudoRemainderSequence;

    Polynomial._resultantUsingSubresultantPseudoRemainderSequence = function(A, B) {
        function toMultivariatePolynomial(p1, p2) {
            if (p1.getLeadingCoefficient() instanceof Expression.Polynomial ||
                p2.getLeadingCoefficient() instanceof Expression.Polynomial) {
                return {
                    variables: [],
                    A: p1,
                    B: p2
                }; //TODO: fix !!!
            }
            var set = {};
            var variables = [];
            var v = function(e) {
                for (var iterators = e.summands()[globalThis.Symbol.iterator](), s = iterators.next().value; s != null; s = iterators.next().value) {
                    for (var iteratorf = s.factors()[globalThis.Symbol.iterator](), f = iteratorf.next().value; f != null; f = iteratorf.next().value) {
                        if (f instanceof Expression.Exponentiation) {
                            f = f.a; //TODO: !
                        }
                        if (f instanceof Expression.Symbol && Object.getPrototypeOf(f) === Expression.Symbol.prototype) { //TODO: !?
                            if (set[f.symbol] == undefined) {
                                variables.push(f);
                                set[f.symbol] = true;
                            }
                        }
                    }
                }
            };
            for (var i = 0; i < p1.a.size; i += 1) {
                v(p1.a.coefficient(i));
            }
            for (var i = 0; i < p2.a.size; i += 1) {
                v(p2.a.coefficient(i));
            }
            //debugger;
            var f = function(p, index) {
                if (index === variables.length) {
                    console.assert(p.hasIntegerCoefficients());
                    return p;
                }
                var v = variables[index];
                return p.map(function(c) {
                    return new Expression.Polynomial(f(Polynomial.toPolynomial(c, v), index + 1));
                });
            };
            return {
                variables: variables,
                A: f(p1, 0),
                B: f(p2, 0)
            };
        }

        function toExpression(variables, p) {
            if (p.equals(Expression.ZERO)) {
                return p; //!?
            }
            if (variables.length === 0) {
                return p;
            }
            return p.polynomial.map(function(c) {
                return toExpression(variables.slice(1), c);
            }).calcAt(variables[0]);
        }
        if (A.getDegree() === Polynomial.ZERO.getDegree() || B.getDegree() === Polynomial.ZERO.getDegree()) {
            return Expression.ZERO;
        }
        var g = Math.gcd(A.getGCDOfTermDegrees(), B.getGCDOfTermDegrees());
        if (g > 1) {
            // why is this true?
            var tmp = Polynomial._resultantUsingSubresultantPseudoRemainderSequence(A._exponentiateRoots(g), B._exponentiateRoots(g));
            //TODO: ?
            return tmp._pow(g);
        }
        var tmp1 = toMultivariatePolynomial(A, B);
        A = tmp1.A;
        B = tmp1.B;
        var AA = A;
        var BB = B;
        var start = Date.now();
        var resultantSign = 1;
        if (A.getDegree() < B.getDegree()) {
            var tmp = A;
            A = B;
            B = tmp;
            resultantSign *= Math.pow(Math.pow(-1, A.getDegree()), B.getDegree()); // https://en.wikipedia.org/wiki/Resultant#Characterizing_properties
        }
        var resultant2 = [];
        var isPseudoRemainderSequence = true;
        // https://en.wikipedia.org/wiki/Resultant#Invariance_under_change_of_polynomials
        for (var iteratortmp = Polynomial._pseudoRemainderSequence(A, B, "subresultant")[globalThis.Symbol.iterator](), tmp = iteratortmp.next().value; tmp != null; tmp = iteratortmp.next().value) {
            var R = tmp.R;
            var α = tmp.α;
            // Seems, all the properties can be seen when looking what happens with the determinant:
            if (B.getDegree() > 0) {
                if (R.getDegree() < 0) {
                    while (resultant2.length > 0) {
                        resultant2.pop();
                    }
                    resultant2.push({
                        base: Expression.ZERO,
                        exponent: 1
                    });
                } else {
                    if (!α.equals(Expression.ONE)) {
                        if (resultant2.length > 0) {
                            var previous = resultant2.pop();
                            resultant2.push({
                                base: previous.base,
                                exponent: previous.exponent + 2 * B.getDegree()
                            });
                            resultant2.push({
                                base: α.divide(previous.base._pow(2)),
                                exponent: B.getDegree()
                            });
                        } else {
                            resultant2.push({
                                base: α,
                                exponent: B.getDegree()
                            });
                        }
                    }
                    resultant2.push({
                        base: B.getLeadingCoefficient(),
                        exponent: (A.getDegree() - R.getDegree()) - (isPseudoRemainderSequence ? B.getDegree() * (A.getDegree() - B.getDegree() + 1) : 0)
                    });
                    resultantSign *= Math.pow(Math.pow(-1, A.getDegree()), B.getDegree()); // https://en.wikipedia.org/wiki/Resultant#Characterizing_properties
                }
            } else {
                console.assert(B.getDegree() === 0 && R.getDegree() < 0);
                resultant2.push({
                    base: B.getLeadingCoefficient(),
                    exponent: A.getDegree()
                });
            }
            A = B;
            B = R;
        }
        var resultant = resultantSign === -1 ? Expression.ONE.negate() : Expression.ONE;
        for (var iteratorx = resultant2[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
            if (x.exponent < 0) {
                resultant = resultant.divide(x.base._pow(-x.exponent));
            } else if (x.exponent > 0) {
                resultant = resultant.multiply(x.base._pow(x.exponent));
            }
        }
        var end = Date.now();
        if (end - start > 250) {
            console.log(end - start, AA.toString(), BB.toString());
        }
        resultant = toExpression(tmp1.variables, resultant);
        return resultant;
    };

    Expression._FIELD = {
        ONE: Expression.ONE,
        sub: function(a, b) {
            return a.subtract(b);
        },
        mul: function(a, b) {
            return a.multiply(b);
        },
        div: function(a, b) {
            return a.divide(b);
        },
        scale: function(a, s) {
            return a.multiply(Expression.Integer.fromBigInt(s));
        }
    };

    Polynomial.resultant = function(p, q) {
        //TODO: do not multiply
        //return Polynomial._resultantByModularAlgorithm(p, q);
        return Polynomial._resultantUsingSubresultantPseudoRemainderSequence(p, q);
    };



    //TODO: remove (use Polynomial#_scaleRoots, Polynomial#_exponentiateRoots, Polynomial#_translateRoots instead)
    //Polynomial.prototype.subs = function (variableMapFunction) {
    //  var variable = new Expression.Symbol('$x');//TODO:
    //  return Polynomial.toPolynomial(this.calcAt(variableMapFunction(variable)).getNumerator(), variable);
    //};

    function GramSchmidtOrthogonalization(vectors) {
        if (false) {
            //TODO: remove (?)
            var V = vectors;
            var n = V[0].dimensions();
            var k = V.length;
            var U = new Array(k).fill(null).map(function(x) {
                return new Matrix.Vector(new Array(n).fill(Expression.ZERO));
            });;
            U[0] = V[0];
            for (var i = 1; i < k; i += 1) {
                U[i] = V[i];
                for (var j = 0; j < i; j += 1) {
                    U[i] = U[i].subtract(U[j].scale(U[i].dot(U[j]).divide(U[j].dot(U[j]))));
                }
            }
            return U;
        }
        // https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process#Via_Gaussian_elimination
        var rowVectorsMatrix = Matrix.fromVectors(vectors).transpose();
        var A = rowVectorsMatrix;
        var matrix = A.multiply(A.conjugateTranspose()).augment(A).toRowEchelon(Matrix.Gauss, "row-reduction").matrix;
        var tmp = matrix.slice(0, matrix.rows(), A.rows(), matrix.cols());
        var result = new Array(tmp.rows());
        for (var i = 0; i < tmp.rows(); i += 1) {
            result[i] = tmp.row(i);
        }
        return result;
    }

    globalThis.GramSchmidtOrthogonalization = GramSchmidtOrthogonalization;

    Expression.Complex.prototype.abs = function() {
        // https://en.wikipedia.org/wiki/Absolute_value#Complex_numbers
        return this.multiply(this.conjugate()).squareRoot();
    };
    Expression.Division.prototype.abs = function() {
        return this.getNumerator().abs().divide(this.getDenominator().abs());
    };
    Expression.prototype.abs = function() { //TODO: remove - ?
        var isSimple = function(e) {
            if (e instanceof Expression.Addition) {
                for (var iterators = e.summands()[globalThis.Symbol.iterator](), s = iterators.next().value; s != null; s = iterators.next().value) {
                    for (var iteratorf = s.factors()[globalThis.Symbol.iterator](), f = iteratorf.next().value; f != null; f = iteratorf.next().value) {
                        if (!(f instanceof Expression.Symbol && !(f instanceof Expression.MatrixSymbol) || f instanceof Expression.Integer)) { //TODO: other?
                            return false;
                        }
                    }
                }
                return true;
            }
            return false;
        };
        if (this instanceof Expression.Symbol) {
            return new Expression.Abs(this); //TODO: !?
        }
        if (this instanceof Expression.ComplexConjugate) {
            return this.a.abs();
        }
        if (this instanceof Expression.Multiplication) {
            return this.a.abs().multiply(this.b.abs());
        }
        if (this instanceof Expression.Abs) {
            return this;
        }
        if (this.isNegative()) {
            return this.negate().abs();
        }
        if (this instanceof Expression.Exponentiation && (this.a instanceof Expression.Symbol || isSimple(this.a))) { //TODO: !?
            if (this.b instanceof Expression.Integer) {
                return this.a.multiply(this.a.complexConjugate()).multiply(this.a.pow(this.b.subtract(Expression.TWO)).abs());
            }
        }
        var d = Expression.simpleDivisor(this);
        if (d != null && !d.equals(Expression.ONE) && !d.equals(this)) {
            if (!(this.divide(d).divide(d) instanceof Expression.Division)) {
                return new Expression.Exponentiation(d, Expression.TWO).abs().multiply(this.divide(d).divide(d).abs());
            }
            return d.abs().multiply(this.divide(d).abs()); // property
        }
        if (isSimple(this)) {
            return new Expression.Abs(this); //TODO: !?
        }
        if (isSimple(this.complexConjugate())) {
            return this.complexConjugate().abs();
        }
        if (this.compareTo(Expression.ZERO) < 0) {
            return this.negate();
        }
        return this;
    };
    Expression.prototype.compareTo = function(other) { //TODO: remove - ?
        if (other.equals(Expression.ZERO)) {
            if (Expression._isPositive(this)) {
                return +1;
            }
            if (Expression._isPositive(this.negate())) {
                return -1;
            }
            throw new TypeError(this.toString());
        }
        return this.subtract(other).getNumerator().compareTo(Expression.ZERO);
    };
    Expression.prototype.sign = function() {
        return this.compareTo(Expression.ZERO);
    };
    Expression.prototype.round = function() { //TODO: remove - ?
        //TODO: half away from zero - ?
        //console.log(this.getNumerator(), this.getDenominator());
        //return this.getNumerator().add(this.getDenominator().truncatingDivide(Expression.TWO)).truncatingDivide(this.getDenominator());
        return ExpressionParser.parse(toDecimalStringInternal(this, {
            fractionDigits: 0
        }));
    };

    //console.assert(GramSchmidtOrthogonalization(new Matrix([[Expression.Integer.fromNumber(3), Expression.Integer.fromNumber(1)], [Expression.Integer.fromNumber(2), Expression.Integer.fromNumber(2)]])).toString() === '{{3,1},{-2/5,6/5}}');
    //console.assert(GramSchmidtOrthogonalization(new Matrix([[Expression.Integer.fromNumber(3), Expression.Integer.fromNumber(1)], [Expression.Integer.fromNumber(2), Expression.Integer.fromNumber(2)], [new Expression.Integer(0), new Expression.Integer(0)]])).toString() === '{{3,1},{-2/5,6/5},{0,0}}');
    //throw new Error();


    // Math.log2(Math.hypot.apply(null, coefficients))
    Polynomial.prototype._log2hypot = function() {
        var max = Expression.ZERO;
        for (var i = 0; i < this.a.size; i += 1) {
            var c = this.a.coefficient(i).abs();
            if (c.compareTo(max) > 0) {
                max = c;
            }
        }
        var shift = Math.max(max.bitLength() - ((1024 - 53 - 1) / 2), 0);
        var unscale = Expression.TWO._pow(shift);
        var s = 0;
        for (var i = 0; i < this.a.size; i += 1) {
            s += Math.pow(this.a.coefficient(i).truncatingDivide(unscale).toNumber(), 2);
        }
        return shift + Math.log2(Math.sqrt(s));
    };

    Polynomial.prototype._log2OfBoundForCoefficientsOfFactor = function(factorDegreeBound, factorLeadingCoefficientBound) {
        // https://en.wikipedia.org/wiki/Geometrical_properties_of_polynomial_roots#:~:text=This%20bound%20is%20also%20useful%20to%20bound%20the%20coefficients%20of%20a%20divisor%20of%20a%20polynomial%20with%20integer%20coefficients:
        // see also
        // The art of computer programming. Vol.2: Seminumerical algorithms
        // exersize 20, page 458
        // which gives better result (~2 times smaller)
        if (factorDegreeBound == undefined) {
            factorDegreeBound = this.getDegree();
        }
        if (factorDegreeBound === 0) {
            return 0;
        }
        if (factorLeadingCoefficientBound == undefined) {
            factorLeadingCoefficientBound = this.getLeadingCoefficient().abs();
        }
        var log2 = function(integer) {
            var e = integer.bitLength();
            if (e <= 53) {
                return Math.log2(integer.toNumber());
            }
            return (e - 53) + Math.log2(integer.truncatingDivide(Expression.TWO._pow(e - 53)).toNumber());
        };
        var centralBinomialCoefficientBound = function(n) {
            return (n - Math.log2(Math.sqrt(Math.PI * Math.ceil(n / 2))));
        };
        var m = factorDegreeBound;
        var e = centralBinomialCoefficientBound(m) + (log2(factorLeadingCoefficientBound.abs()) - log2(this.getLeadingCoefficient().abs())) + this._log2hypot();
        return e;
    };


    Polynomial.prototype.isDivisibleBy = function(guess) {
        var w = undefined;
        var s = Expression.ONE;
        if (this._hasIntegerLikeCoefficients() &&
            guess._hasIntegerLikeCoefficients()) {
            // for performance
            // https://en.wikipedia.org/wiki/Gauss%27s_lemma_(polynomials) - ?
            w = "undefined";
            s = guess.getContent();
        }
        var tmp = this.scale(s).divideAndRemainder(guess, w);
        return tmp != null && tmp.remainder.equals(Polynomial.ZERO);
    };


    // returns a GCD of polynomials where coefficients are polynomials modulo polynomial M, leading coefficient is set to 1
    function polynomialGCDModuloPolynomial(A, B, M) {
        function modulo(B, M) { // Note: this may increase the coefficient because of the scaling and so make the execution slower
            var BmodM = B.map(function(c) {
                return new Expression.Polynomial(c.polynomial.divideAndRemainder(M).remainder);
            });
            var d = BmodM.map(function(c) {
                return c.polynomial.getContent();
            }).getContent().inverse(); //TODO: ?
            return BmodM.scale(new Expression.Polynomial(Polynomial.of(d)));
        }

        function toMonic(A, M) {
            //Note: it is faster for some polynomials to make A modulo M at first
            if (A.getDegree() < 0) {
                return A;
            }
            return modulo(A.scale(new Expression.Polynomial(A.getLeadingCoefficient().polynomial.primitivePart().modularInverse(M).primitivePart())), M);
        }
        A = A.map(function(c) {
            return new Expression.Polynomial(c);
        });
        B = B.map(function(c) {
            return new Expression.Polynomial(c);
        });
        if (A.getDegree() < B.getDegree()) {
            var tmp = A;
            A = B;
            B = tmp;
        }
        if (B.getDegree() >= 0 && modulo(Polynomial.of(B.getLeadingCoefficient()), M).equals(Polynomial.ZERO)) {
            return polynomialGCDModuloPolynomial(modulo(A, M).map(function(c) {
                return c.polynomial;
            }), modulo(B, M).map(function(c) {
                return c.polynomial;
            }), M);
        }
        for (var iteratortmp = Polynomial._pseudoRemainderSequence(A, B, "subresultant")[globalThis.Symbol.iterator](), tmp = iteratortmp.next().value; tmp != null; tmp = iteratortmp.next().value) {
            var newR = tmp.R;
            A = B;
            B = newR;
            if (B.getDegree() >= 0 && modulo(Polynomial.of(B.getLeadingCoefficient()), M).equals(Polynomial.ZERO)) {
                return polynomialGCDModuloPolynomial(modulo(A, M).map(function(c) {
                    return c.polynomial;
                }), modulo(B, M).map(function(c) {
                    return c.polynomial;
                }), M);
            }
        }
        return toMonic(modulo(A, M), M);
    }

    globalThis.testables = globalThis.testables || {};
    globalThis.testables.polynomialGCDModuloPolynomial = polynomialGCDModuloPolynomial;


})();
(function() {
    "use strict";



    // https://ca.wikipedia.org/wiki/Forma_canònica_de_Jordan

    // https://es.wikipedia.org/wiki/Forma_canónica_de_Jordan

    Expression.getSolutionSet = function getSolutionSet(matrix) {
        var fullMatrix = matrix.augment(Matrix.Zero(matrix.cols(), 1));
        //TODO: Matrix.GaussMontante
        var result = fullMatrix.toRowEchelon(Matrix.GaussJordan, "solving", undefined);
        var tmp = Matrix.solveByGaussNext(result.matrix);
        var basisVectors = Matrix.getSolutionSet(tmp).basisVectors;
        return basisVectors; //?
    };

    Expression.getFormaDeJordan = function(matrix, eigenvalues, hack) {
        function matrixFromBlocks(blocks) {
            var start = 0;
            var J = Matrix.Zero(n, n);
            for (var i = 0; i < blocks.length; i += 1) {
                var b = blocks[i];
                J = J.map(function(e, i, j) {
                    if (i >= start && i < start + b.size) {
                        return i === j ? b.eigenvalue : (i !== start + b.size - 1 && j === i + 1 ? Expression.ONE : Expression.ZERO);
                    }
                    return e;
                });
                start += b.size;
            }
            return J;
        }

        function isSolution(coefficientMatrix, vector) {
            var f = coefficientMatrix.multiply(vector);
            return f.eql(Matrix.Zero(f.rows(), 1));
        }

        function isLinearlyIndependentSet(basis, vectors) {
            // https://math.stackexchange.com/questions/412563/determine-if-vectors-are-linearly-independent
            return Matrix.fromVectors(basis.concat(vectors)).rank() === basis.length + vectors.length;
        }

        if (arguments.length > 3 || (arguments[2] !== true && arguments[2] !== undefined)) {
            throw new TypeError();
        }

        var uniqueEigenvalues = Expression.unique(eigenvalues);

        //!TODO: remove
        if (uniqueEigenvalues.length === matrix.rows()) {
            var eigenvectors = Expression.getEigenvectors(matrix, eigenvalues);
            var tmp = Expression.diagonalize(matrix, eigenvalues, eigenvectors);
            var P = tmp.T;
            var J = tmp.L;
            var P_INVERSED = tmp.T_INVERSED;
            //console.log("P=" + P.toString() + ", J=" + J.toString());
            return {
                P: P,
                J: J,
                P_INVERSED: P_INVERSED
            };
        }
        //!

        var A = matrix;
        var n = A.rows();

        var basis = [];
        var blocks = [];
        for (var i = 0; i < uniqueEigenvalues.length; i += 1) {
            // https://en.wikipedia.org/wiki/Generalized_eigenvector#Computation_of_generalized_eigenvectors
            var basisCorrespondingToTheEigenvalue = []; // TODO: optimize (n**3 -> n**2)
            var eigenvalue = uniqueEigenvalues[i];
            var algebraicMultiplicity = eigenvalues.reduce(function(count, e) {
                return count + (e === eigenvalue ? 1 : 0);
            }, 0);
            var B = A.subtract(Matrix.I(n).scale(eigenvalue));
            var m = 1;
            while (B.pow(m).rank() > n - algebraicMultiplicity) {
                m += 1;
            }
            m += 1;
            while (--m >= 1) {
                //var z = 0;
                //var pm = B.pow(m - 1).rank() - 2 * B.pow(m).rank() + B.pow(m + 1).rank();
                var solutionSet = Expression.getSolutionSet(B.pow(m)); // "kernel of A"
                for (var j = 0; j < solutionSet.length; j += 1) {
                    var solution = solutionSet[j];
                    //if (z < pm) {
                    //console.log(B.pow(m).augment(solution).rank(), m, n);
                    if (!isSolution(B.pow(m - 1), solution)) {
                        var chain = [];
                        var s = solution;
                        for (var k = 0; k < m; k += 1) {
                            chain.push(s);
                            s = B.multiply(s).col(0);
                        }
                        chain.reverse();
                        if (isLinearlyIndependentSet(basisCorrespondingToTheEigenvalue, chain)) {
                            //z += 1;
                            basis = basis.concat(chain);
                            basisCorrespondingToTheEigenvalue = basisCorrespondingToTheEigenvalue.concat(chain);
                            blocks.push({
                                size: m,
                                eigenvalue: eigenvalue
                            });
                        }
                    }
                    //}
                }
            }
        }
        var J = matrixFromBlocks(blocks);
        if (basis.length !== n) {
            throw new TypeError("assertion failed");
        }
        var P = Matrix.fromVectors(basis);
        //console.log("P=" + P.toString() + ", J=" + J.toString());
        //var P_INVERSED = P.inverse();
        var P_INVERSED = P.isExact() ? P.inverse() : (hack ? null : getInverse(A, eigenvalues, P));
        if (!hack && P.isExact()) {
            if (A.toString() !== P.multiply(J).multiply(P_INVERSED).toString()) {
                throw new TypeError("assertion failed");
            }
        }
        return {
            P: P,
            J: J,
            P_INVERSED: P_INVERSED
        };
    };

    // A = P*J*P^-1
    // A^T = (P^-1)^T*J^T*P^T
    // Note:
    // (0 0 0 1)         (0 0 0 1)
    // (0 0 1 0)         (0 0 1 0)
    // (0 1 0 0) * J^T * (0 1 0 0) = J
    // (1 0 0 0)         (1 0 0 0)
    // where on the left we are doing row spaws, then doing column swaps.
    // Note: the inverse of the anti-diagonal unitary matrix is the matrix itself.
    // A^T = X*Y*X^-1
    // (P^-1)^T*J^T*P^T = X*Y*X^-1
    // (P^-1)^T*B^-1*J*B*P^T = X*Y*X^-1
    // Then P^-1 = (X*B)^T .

    var getInverse = function(A, eigenvalues, P) {
        // https://en.wikipedia.org/wiki/Diagonalizable_matrix : The row vectors of P^−1 are the left eigenvectors of A
        // https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors#Left_and_right_eigenvectors :  a left eigenvector of A is the same as the transpose of a right eigenvector of A^T, with the same eigenvalue
        var AT = A.transpose();
        var tmp2 = Expression.getFormaDeJordan(AT, eigenvalues, true);
        var J = tmp2.J;
        var X = tmp2.P;

        var n = A.cols();
        var B = Matrix.Zero(n, n).map(function(e, i, j) {
            function getCurrentBlock() {
                var s = i;
                while (s - 1 >= 0 && s < n && J.e(s - 1, s).equals(Expression.ONE)) {
                    s -= 1;
                }
                var e = i;
                while (e + 1 < n && J.e(e, e + 1).equals(Expression.ONE)) {
                    e += 1;
                }
                return {
                    s: s,
                    e: e
                };
            }
            var tmp = getCurrentBlock();
            return tmp.s + tmp.e === i + j ? Expression.ONE : Expression.ZERO;
        });

        var P_INVESRED = X.multiply(B).transpose();
        return Expression._unscaleInverseMatrix(P_INVESRED, P);
    };
    Expression._getInverse = getInverse;

})();
(function() {
    "use strict";





    globalThis.factorsMap = new Map();

    Expression.getPolynomialRootsWithSteps = function(polynomial, callback) {
        var roots = polynomial.getroots(callback);

        //TODO: tests
        //!2018-05-28
        //!2018-07-11
        // experimental code
        var zeros = [];
        if (typeof polynomial.getZeros === "function" && roots.length !== polynomial.getDegree()) {
            var p = Polynomial.of(Expression.ONE);
            for (var i = 0; i < roots.length; i += 1) {
                p = p.multiply(Polynomial.of(roots[i].negate(), Expression.ONE));
            }
            var r = polynomial.divideAndRemainder(p).quotient;
            globalThis.factorsMap = new Map();
            var getZerosTricky = function(f) {
                var pp = f.primitivePart();
                if (!pp.hasIntegerCoefficients()) { //TODO: !?
                    return f.getZeros(true);
                }
                f = pp;

                // https://en.wikipedia.org/wiki/Square-free_polynomial
                var tmp = f.squareFreeFactors();
                var a0 = tmp.a0;
                var a1 = tmp.a1;

                if (a0.getDegree() !== 0) {
                    var tmp1 = getZerosTricky(a1); // roots with multiplicity = 1 (?)
                    var tmp2 = getZerosTricky(a0);
                    var result = [];
                    var previous = undefined;
                    for (var i = 0; i < tmp2.length; i += 1) {
                        var zero = tmp2[i];
                        if (zero !== previous) {
                            result.push(zero);
                            previous = zero;
                        }
                        result.push(zero);
                    }
                    return tmp1.concat(result);
                }

                var factor = f.factorize();
                if (factor == null) {
                    factor = f;
                }
                if (!factor.equals(f)) {
                    return getZerosTricky(factor).concat(getZerosTricky(f.divideAndRemainder(factor, "throw").quotient));
                }
                var zeros = factor.getZeros(true);
                for (var iteratorzero = zeros[globalThis.Symbol.iterator](), zero = iteratorzero.next().value; zero != null; zero = iteratorzero.next().value) {
                    globalThis.factorsMap.set(zero, factor);
                }
                return zeros;
            };
            //zeros = r.getZeros(true);
            zeros = getZerosTricky(r);
            if (callback != undefined) {
                if (zeros.length === r.getDegree()) { //TODO: !!!
                    callback({
                        content: Expression.ONE,
                        roots: roots.concat(zeros),
                        newPolynomial: Polynomial.of(polynomial.getLeadingCoefficient()),
                        type: "realRootIsolationAndNewton'sMethod"
                    });
                }
            }
        }
        //!

        // removing of duplicates
        for (var i = 0; i < roots.length; i += 1) {
            var root = roots[i];
            for (var j = 0; j < roots.length; j += 1) {
                if (roots[j].equals(root)) {
                    roots[j] = root;
                }
            }
        }

        return roots.concat(zeros);
    };

    Expression.getEigenvalues = function(matrix, callback) {

        if (!matrix.isSquare()) {
            throw new RangeError("NonSquareMatrixException");
        }
        // TODO: remove Polynomial

        var determinant = matrix.map(function(e, i, j) {
            var p = i === j ? Polynomial.of(e, Expression.ONE.negate()) : (e.equals(Expression.ZERO) ? Polynomial.ZERO : Polynomial.of(e));
            return new Expression.Polynomial(p);
        }).determinant();
        determinant = determinant.polynomial;

        //!new (sin/cos)
        //TODO: fix
        determinant = determinant.map(function(e) {
            return e.simplifyExpression();
        });

        var characteristicPolynomial = determinant; //!TODO: fix
        if (callback != null) {
            callback(characteristicPolynomial); //TODO: !?
        }

        //TODO:
        var eigenvalues = Expression.getPolynomialRootsWithSteps(characteristicPolynomial, callback);

        return eigenvalues;
    };

    // a/b, where a and b are integers
    Expression.isRational = function(e) {
        return e instanceof Expression.Integer || e instanceof Expression.BinaryOperation && Expression.isRational(e.a) && Expression.isRational(e.b);
    };
    Expression.isRationalMatrix = function(A) {
        for (var i = 0; i < A.rows(); i += 1) {
            for (var j = 0; j < A.cols(); j += 1) {
                if (!Expression.isRational(A.e(i, j))) {
                    return false;
                }
            }
        }
        return true;
    };

    Expression.getEigenvectors = function(matrix, eigenvalues, internal) {
        internal = internal == undefined ? false : internal;

        if (eigenvalues == undefined) {
            throw new TypeError(); //TODO: remove
            eigenvalues = Expression.getEigenvalues(matrix);
        }

        var eigenvectors = new Array(eigenvalues.length).fill(null);
        var uniqueEigenvalues = Expression.unique(eigenvalues);

        var setResults = function(eigenvalue, currentEigenvectors) {
            var j = 0;
            for (var k = 0; k < eigenvalues.length && j < currentEigenvectors.length; k += 1) {
                if (eigenvalues[k] === eigenvalue) {
                    eigenvectors[k] = currentEigenvectors[j];
                    j += 1;
                }
            }
            if (j < currentEigenvectors.length) {
                throw new TypeError("wrong eigenvalues argument: the eigenvalue should appear multiple times");
            }
        };

        if (!internal && matrix.isSquare() && Expression.isRationalMatrix(matrix)) { //todo: complex (?)
            var map = new Map();
            for (var iteratoreigenvalue = uniqueEigenvalues[globalThis.Symbol.iterator](), eigenvalue = iteratoreigenvalue.next().value; eigenvalue != null; eigenvalue = iteratoreigenvalue.next().value) {
                var factor = globalThis.factorsMap.get(eigenvalue);
                if (factor == null || factor.getDegree() <= 1) {
                    var currentEigenvectors = Expression.getEigenvectors(matrix, eigenvalues.filter(function(e) {
                        return e === eigenvalue;
                    }), true);
                    setResults(eigenvalue, currentEigenvectors);
                } else {
                    var currentEigenvectors = map.get(factor);
                    if (currentEigenvectors == null) {
                        var root = SomePolynomialRoot.create(factor);
                        currentEigenvectors = Expression.getEigenvectors(matrix, eigenvalues.filter(function(e) {
                            return e === eigenvalue;
                        }).map(function(e) {
                            return root;
                        }), true);
                        map.set(factor, currentEigenvectors);
                    }
                    var zeroPows = [];
                    zeroPows.push(Expression.ONE);
                    var subs = function(x) {
                        return x instanceof SomePolynomialRoot ? x.calcAt(eigenvalue, zeroPows) : x;
                    };
                    setResults(eigenvalue, currentEigenvectors.map(function(v) {
                        return new Matrix.Vector(v.elements.map(function(e) {
                            return subs(e);
                        }));
                    }));
                }
            }

            return eigenvectors;
        }

        for (var i = 0; i < uniqueEigenvalues.length; i += 1) {
            var eigenvalue = uniqueEigenvalues[i];
            var n = matrix.cols();
            // matrix - I * eigenvalue
            var currentEigenvectors = Expression.getSolutionSet(matrix.subtract(Matrix.I(n).scale(eigenvalue)));
            setResults(eigenvalue, currentEigenvectors);

            var cc = null;
            if (i + 1 < uniqueEigenvalues.length) {
                try {
                    cc = eigenvalue.complexConjugate();
                } catch (error) {
                    //TODO: remove
                    console.error(error);
                }
            }
            //TODO: REMOVE (use the code above)
            if (i + 1 < uniqueEigenvalues.length && cc != null && cc.equals(uniqueEigenvalues[i + 1]) && matrix.eql(matrix.map(function(e) {
                    return e.complexConjugate();
                }))) {
                //TODO:!
                var complexConjugate = function(vector) {
                    return new Matrix.Vector(vector.elements.map(function(e) {
                        return e.complexConjugate();
                    }));
                };
                setResults(uniqueEigenvalues[i + 1], currentEigenvectors.map(function(vector) {
                    return complexConjugate(vector);
                }));
                i += 1; //TODO: !?
            }
        }
        return eigenvectors;
    };

    var getInverse = function(A, eigenvalues, T) {
        // https://en.wikipedia.org/wiki/Diagonalizable_matrix : The row vectors of P^−1 are the left eigenvectors of A
        // https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors#Left_and_right_eigenvectors :  a left eigenvector of A is the same as the transpose of a right eigenvector of A^T, with the same eigenvalue
        var AT = A.transpose();
        var eigenvectors = Expression.getEigenvectors(AT, eigenvalues);
        var T_INVERSED = Matrix.fromVectors(eigenvectors).transpose();
        return _unscaleInverseMatrix(T_INVERSED, T);
    };

    var _unscaleInverseMatrix = function(T_INVERSED, T) {
        // we know, that the result is {{s_1, 0, 0, 0}, {0, s_2, 0, 0}, {0, 0, s_3, 0}, {0, 0, 0, s_4}}
        var trickyMultiply = function(a, b) {
            var n = a.rows();
            return Matrix.Zero(n, n).map(function(element, i, j) {
                if (i !== j) {
                    return Expression.ZERO;
                }
                var rows = n;
                var k = -1;
                while (++k < rows) {
                    var current = a.e(i, k).multiply(b.e(k, j));
                    element = k === 0 ? current : element.add(current);
                }
                return element;
            });
        };

        var S = trickyMultiply(T_INVERSED, T);
        var S_INVERSED = S.map(function(e, i, j) {
            return i === j ? e.inverse() : Expression.ZERO;
        });

        return S_INVERSED.multiply(T_INVERSED);
    };
    Expression._unscaleInverseMatrix = _unscaleInverseMatrix; //TODO: make private

    // A = T^-1 L T ,T-matrix of own vectors, L - matrix of own values

    Expression.diagonalize = function(matrix, eigenvalues, eigenvectors) {
        if (arguments.length > 3) {
            throw new TypeError();
        }
        if (!matrix.isSquare()) {
            throw new RangeError("NonSquareMatrixException");
        }
        if (eigenvalues.length !== matrix.cols()) {
            throw new RangeError();
        }
        if (eigenvectors.filter(function(v) {
                return v != null;
            }).length !== matrix.cols()) {
            throw new RangeError();
        }
        // https://en.wikipedia.org/wiki/Jordan_normal_form
        // A is diagonalizable if and only if, for every eigenvalue λ of A, its geometric and algebraic multiplicities coincide.

        // TODO: text
        //!!!
        var L = Matrix.I(matrix.cols()).map(function(element, i, j) {
            return (i === j ? eigenvalues[i] : Expression.ZERO);
        });
        var T = Matrix.fromVectors(eigenvectors);

        //var T_INVERSED = T.inverse();
        var T_INVERSED = T.isExact() ? T.inverse() : getInverse(matrix, eigenvalues, T);

        return {
            T: T,
            L: L,
            T_INVERSED: T_INVERSED
        };
    };

    Expression.LUDecomposition = function(matrix) {
        //https://en.wikipedia.org/wiki/LU_decomposition#Code_examples
        //TODO: remove(?) - matrix.toRowEchelon(...)
        var N = matrix.rows();
        var a = matrix;
        var Lower = Matrix.I(N);
        var P = Matrix.I(N);
        var swapFlag = false;
        var pivotRow = 0;
        for (var n = 0; n < matrix.cols(); n += 1) {
            if (pivotRow < N) {
                var c = pivotRow;
                if (a.e(pivotRow, n).equals(Expression.ZERO)) {
                    for (var k = pivotRow + 1; k < N && c === pivotRow; k += 1) {
                        if (!a.e(k, n).equals(Expression.ZERO)) {
                            c = k;
                        }
                    }
                    if (c !== pivotRow) {
                        var S = Matrix.I(N);
                        S = S.map(function(element, i, j) {
                            return i === pivotRow ? S.e(c, j) : (i === c ? S.e(pivotRow, j) : element);
                        });
                        a = S.multiply(a);
                        Lower = S.multiply(Lower.subtract(Matrix.I(N))).add(Matrix.I(N));
                        P = S.multiply(P);
                        swapFlag = true;
                    }
                }
                if (!a.e(pivotRow, n).equals(Expression.ZERO)) {
                    var L = Matrix.I(N).map(function(element, i, j) {
                        return j === pivotRow && i >= pivotRow + 1 ? a.e(i, n).divide(a.e(pivotRow, n)).negate() : element;
                    });
                    a = L.multiply(a);
                    Lower = Lower.multiply(L);
                    pivotRow += 1;
                }
            }
        }
        Lower = Lower.map(function(element, i, j) {
            return i === j ? element : element.negate();
        });
        return {
            swapFlag: swapFlag,
            P: new Expression.Matrix(P),
            A: new Expression.Matrix(matrix),
            L: new Expression.Matrix(Lower),
            U: new Expression.Matrix(a)
        };
    };

    Expression.isReal = function(e) {
        var isReal = function(e) {
            if (e instanceof Expression.Integer) {
                return true;
            }
            if (e instanceof Expression.NthRoot) {
                return isReal(e.a);
            }
            if (e instanceof Expression.BinaryOperation) {
                return isReal(e.a) && isReal(e.b);
            }
            if (e === Expression.E || e === Expression.PI) {
                return true;
            }
            if (e instanceof Expression.Function) {
                return isReal(e.a);
            }
            if (e instanceof Expression.PolynomialRootSymbol) {
                return true; //TODO: ?
            }
            if (e instanceof Expression.ExpressionWithPolynomialRoot) {
                return isReal(e.e);
            }
            if (e instanceof Expression.ExpressionPolynomialRoot) {
                return true;
            }
            return false;
        };
        return isReal(e);
    };
    Expression.isRealMatrix = function(A) {
        for (var i = 0; i < A.rows(); i += 1) {
            for (var j = 0; j < A.cols(); j += 1) {
                if (!Expression.isReal(A.e(i, j))) {
                    return false;
                }
            }
        }
        return true;
    };
    Expression.CholeskyDecomposition = function(matrix) {
        var A = matrix;

        // check if A is square
        if (!A.isSquare()) {
            throw new RangeError("NonSquareMatrixException");
        }

        var n = A.rows();

        // check if A from R
        var isReal = Expression.isRealMatrix(A);

        // check if A is symmetric
        for (var i = 0; i < n; i += 1) {
            for (var j = i; j < n; j += 1) {
                if (!A.e(i, j).equals(A.e(j, i).complexConjugate())) {
                    if (isReal) {
                        throw new RangeError("NonSymmetricMatrixException");
                    } else {
                        throw new RangeError("NonHermitianMatrixException");
                    }
                }
            }
        }

        var L = new Array(n);
        for (var i = 0; i < n; i += 1) {
            L[i] = new Array(n);
            for (var j = 0; j < n; j += 1) {
                L[i][j] = Expression.ZERO;
            }
        }

        for (var j = 0; j < n; j += 1) {
            for (var i = j; i < n; i += 1) {
                var e = null;
                if (j === i) {
                    var sum = null;
                    for (var k = 0; k < j; k += 1) {
                        var s = L[j][k].multiply(L[j][k].complexConjugate());
                        sum = sum == null ? s : sum.add(s);
                    }
                    var x = sum == null ? A.e(j, j) : A.e(j, j).subtract(sum);
                    //TODO: fix
                    if (!Expression._isPositive(x)) {
                        throw new RangeError("NonPositiveDefiniteMatrix");
                    }
                    e = x.squareRoot();
                } else {
                    var sum = null;
                    for (var k = 0; k < j; k += 1) {
                        var x = L[i][k].multiply(L[j][k].complexConjugate());
                        sum = sum == null ? x : sum.add(x);
                    }
                    e = (sum == null ? A.e(i, j) : A.e(i, j).subtract(sum)).divide(L[j][j]);
                }
                L[i][j] = e;
                console.log("l_%d%d = %s", i + 1, j + 1, L[i][j].toString());
            }
        }
        return {
            L: Matrix.padRows(L, null)
        };
    };


    Matrix.prototype.conjugateTranspose = function() {
        return this.transpose().map(function(e) {
            return e.complexConjugate();
        });
    };

    Matrix.fromVectors = function(vectors) {
        if (vectors.length === 0) {
            throw new RangeError();
        }
        var dimensions = vectors[0].dimensions();
        for (var i = 0; i < vectors.length; i += 1) {
            if (vectors[i].dimensions() !== dimensions) {
                throw new RangeError();
            }
        }
        return Matrix.Zero(dimensions, vectors.length).map(function(e, i, j) {
            return vectors[j].e(i);
        });
    };

    Expression.SVD = function(matrix) {
        // TODO: see email 
        // https://en.wikipedia.org/wiki/Singular_value_decomposition#Calculating_the_SVD
        // TODO: see https://web.mit.edu/be.400/www/SVD/Singular_Value_Decomposition.htm
        // The left-singular vectors of M are a set of orthonormal eigenvectors of MM*.
        var helper = function(matrix, eigenvectors) {
            //console.info('We need to orthonormalize eigenvectors so the matrix with those vectors as columns will be unitary:');
            if (eigenvectors.length > 1) { //TODO: https://math.stackexchange.com/questions/82467/eigenvectors-of-real-symmetric-matrices-are-orthogonal#answer-82471
                eigenvectors = GramSchmidtOrthogonalization(eigenvectors);
            } else {
                //console.debug('Eigenvectors of real symmetric matrices corresponding to distinct eigenvalues are orthogonal'); // no need to show (?)
            }
            return eigenvectors.map(function(vector) {
                return vector.toUnitVector();
            });
        };
        var MstarM = matrix.conjugateTranspose().multiply(matrix);
        var eigenvalues = Expression.getEigenvalues(MstarM); // use MstarM to have zero eigenvalues to make the set of eigenvectors full for V
        //!
        // "===" should still work after Array#map:
        var ks = Expression.unique(eigenvalues);
        var vs = Expression.unique(eigenvalues).map(function(eigenvalue) {
            return eigenvalue instanceof Expression.ExpressionWithPolynomialRoot || eigenvalue instanceof Expression.ExpressionPolynomialRoot ? eigenvalue.upgrade() : eigenvalue;
        });
        eigenvalues = eigenvalues.map(function(e) {
            return vs[ks.indexOf(e)];
        });
        //!

        eigenvalues = eigenvalues.slice(0).reverse().sort(function(a, b) {
            var diff = a.subtract(b);
            if (!Expression.isReal(diff)) {
                return NaN; //TODO: !?
            }
            return diff.compareTo(Expression.ZERO) > 0 ? -1 : 1;
        });

        //var Vstar = ExpressionParser.parse(matrix.toString()).transformEquality(ExpressionParser.parse(U.multiply(Sigma).toString() + '*' + 'X', ExpressionParser.parse.c).simplify());

        //console.info('M^{*}M (M^T*M) has the same non-negative eigenvalues as M*M^{*} (M*M^T)')
        var V = [];
        var diagonal = [];
        //TODO:
        //console.info('   eigenvectors: ');
        var uniqueEigenvalues = Expression.unique(eigenvalues);
        var eigenvectors = Expression.getEigenvectors(MstarM, eigenvalues);
        for (var iteratoreigenvalue = uniqueEigenvalues[globalThis.Symbol.iterator](), eigenvalue = iteratoreigenvalue.next().value; eigenvalue != null; eigenvalue = iteratoreigenvalue.next().value) {
            var eigenvalueEigenvectors = eigenvectors.filter(function(v, i) {
                return eigenvalues[i] === eigenvalue;
            });
            V = V.concat(helper(MstarM, eigenvalueEigenvectors));
            var entry = eigenvalue.squareRoot();
            // https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors#Eigenspaces,_geometric_multiplicity,_and_the_eigenbasis_for_matrices
            // https://people.math.carleton.ca/~kcheung/math/notes/MATH1107/wk12/12_singular_value_decomposition.html
            // it says, that geometric multiplicity of a _positive_ eigenvalue of A*A^T is the same as geometric multiplicity of A^T*A and same as algebraic multipliciy.
            // and those matrices has the same eigenvalues
            //var geometricMultiplicity = multiplicities[i] === 1 ? 1 : MMstar.cols() - MMstar.subtract(Matrix.I(MMstar.cols()).scale(eigenvalue)).rank();//?
            var geometricMultiplicity = V.length - diagonal.length;
            diagonal = diagonal.concat(new Array(geometricMultiplicity).fill(entry));
        }
        var Sigma = Matrix.Zero(matrix.rows(), matrix.cols()).map(function(e, i, j) {
            return (i === j && i < diagonal.length ? diagonal[i] : Expression.ZERO);
        });

        // see https://www.d.umn.edu/~mhampton/m4326svd_example.pdf
        //TODO: compute V or U using the property instead of the current variant of computation (?)

        console.time('U');
        var U = [];
        for (var i = 0; i < Sigma.rows() && i < Sigma.cols() && !Sigma.e(i, i).equals(Expression.ZERO); i += 1) {
            //TODO: another method when multiplicity is 1 - ? (for performance)
            var u_i = matrix.multiply(V[i]).col(0).scale(Sigma.e(i, i).inverse());
            U.push(u_i);
        }
        if (U.length < matrix.rows()) { // not enough vectors
            //TODO: details
            console.time('U1');
            var MMstar = matrix.multiply(matrix.conjugateTranspose());
            var eigenvectors = Expression.getEigenvectors(MMstar, new Array(matrix.rows()).fill(Expression.ZERO), true).filter(function(v) {
                return v != null;
            });
            var U2b = helper(MMstar, eigenvectors);
            console.timeEnd('U1');
            console.assert(U.length + U2b.length === matrix.rows());
            U = U.concat(U2b);
        }
        console.timeEnd('U');

        //var Vstar = s.multiply(U.inverse().multiply(matrix));
        //var Vstar = U.conjugateTranspose().multiply(matrix);
        //console.log(U.multiply(U.conjugateTranspose()).toString());
        //console.log(Vstar.multiply(Vstar.conjugateTranspose()).toString());

        U = Matrix.fromVectors(U);
        V = Matrix.fromVectors(V);
        return {
            U: U,
            Sigma: Sigma,
            Vstar: V.conjugateTranspose()
        };
    };

    Expression.QRDecomposition = function(matrix) {
        var A = matrix;
        // https://en.wikipedia.org/wiki/QR_decomposition#Example
        var columnVectors = new Array(A.cols());
        for (var i = 0; i < A.cols(); i += 1) {
            columnVectors[i] = A.col(i);
        }
        var U = GramSchmidtOrthogonalization(columnVectors).filter(function(vector) {
            return !vector.eql(Matrix.Vector.Zero(vector.dimensions()));
        });
        var Q = Matrix.fromVectors(U.map(function(vector) {
            return vector.toUnitVector();
        }));
        var R = Q.conjugateTranspose().multiply(A);
        console.log(Q);
        return {
            Q: Q,
            R: R
        };
    };


})();
(function() {
    "use strict";



    function Condition(array) {
        Object.freeze(array);
        this.array = array;
    }

    Condition.NEZ = " != 0";
    Condition.EQZ = " == 0";

    Condition.GTZ = " > 0";
    //Condition.GTEZ = " >= 0";

    Condition.prototype._and = function(operator, e) {
        //console.log('_and', e.toString(), this === Condition.FALSE || this === Condition.TRUE ? '' : this.toString());
        if (operator !== Condition.NEZ && operator !== Condition.EQZ && operator !== Condition.GTZ) {
            throw new TypeError();
        }
        if (e == undefined) {
            throw new RangeError();
        }
        if (this === Condition.FALSE) {
            return this;
        }

        var contains = function(array, operator, e) {
            for (var i = 0; i < array.length; i += 1) {
                if (array[i].operator === operator && array[i].expression.equals(e)) {
                    return true;
                }
            }
            return false;
        };

        if (e instanceof Expression.GF2Value) {
            return this._and(operator, e.value === 0 ? Expression.ZERO : Expression.ONE); //?
        }

        var add = function(oldArray, y) {

            //TODO: y is const
            if (contains(oldArray, y.operator, y.expression)) { //!TODO: it should work even without this (?)
                return oldArray;
            }
            if (contains(oldArray, y.operator === Condition.EQZ ? Condition.NEZ : Condition.EQZ, y.expression)) {
                return null;
            }

            var operator = null; // to not use a variable from scope accidently
            var e = y.expression; //!

            //!new 2019-12-15:
            //!substitute:  x = 0, sin(x) != 0
            if (Expression.has(e, Expression.Sin) ||
                Expression.has(e, Expression.Cos) ||
                Expression.has(e, Expression.Exponentiation) ||
                Expression.has(e, Expression.Arctan) ||
                Expression.has(e, Expression.Logarithm) ||
                Expression.has(e, Expression.Abs)) {
                if (oldArray.length > 0) { //TODO: test, fix
                    e = Expression._map(function(x) {
                        if (x instanceof Expression.Function && !(x instanceof Expression.NthRoot) ||
                            x instanceof Expression.Exponentiation && (!(x.b instanceof Expression.Integer) || !(x.a instanceof Expression.Symbol))) {
                            var r = x instanceof Expression.Exponentiation ? x.b : x.a;
                            var arg = null;
                            var array = null;
                            if (!(r instanceof Expression.Symbol)) {
                                arg = new Expression.Symbol('arg');
                                array = add(oldArray, {
                                    expression: arg.subtract(r),
                                    operator: Condition.EQZ
                                });
                                if (array == null) {
                                    //! TODO: fix, should not happen
                                    return x;
                                }
                            } else {
                                arg = r;
                                array = oldArray;
                            }
                            for (var i = 0; i < array.length; i += 1) { //TODO: fix
                                var y = array[i];
                                if (y.operator === Condition.EQZ) {
                                    var polynomial = Polynomial.toPolynomial(y.expression, arg);
                                    if (polynomial.getDegree() === 1) {
                                        var yy = polynomial.getCoefficient(0).negate().divide(polynomial.getCoefficient(1));
                                        if (!Expression.has(yy, Expression.Function)) { // sin(yy)/cos(yy) is supported
                                            if (yy.compare4Addition(arg) < 0 && !(yy instanceof Expression.Division) || Expression.isConstant(yy) || Expression.isConstant(yy.divide(Expression.PI))) { //TODO: fix
                                                if (x instanceof Expression.Exponentiation) {
                                                    //?TODO: tests
                                                    return x.a.pow(yy);
                                                } else if (x instanceof Expression.Arctan) {
                                                    return yy.arctan();
                                                } else if (x instanceof Expression.Logarithm) {
                                                    return yy.logarithm();
                                                } else if (x instanceof Expression.Abs) {
                                                    return yy.abs();
                                                } else {
                                                    yy = Expression.isConstant(yy) && !(yy.equals(Expression.ZERO)) && !(yy instanceof Expression.Radians) && !Expression.has(yy, Expression.Symbol) ? new Expression.Radians(yy) : yy;
                                                    if (x instanceof Expression.Sin) {
                                                        return yy.sin();
                                                    } else if (x instanceof Expression.Cos) {
                                                        return yy.cos();
                                                    } else {
                                                        throw new TypeError("NotSupportedError");
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            return x;
                        }
                        return x;
                    }, e);
                    y = {
                        expression: e,
                        operator: y.operator
                    }; //TODO: fix
                }
            }
            //!

            //!new
            if (e.isNegative() && (y.operator === Condition.EQZ || y.operator === Condition.NEZ)) {
                return add(oldArray, {
                    expression: e.negate(),
                    operator: y.operator
                });
            }

            // (x-1)^(1/2)
            if (e instanceof Expression.Exponentiation // &&
                //e.b.getNumerator() instanceof Expression.Integer &&
                //!e.b.getDenominator().equals(Expression.ONE)
            ) {
                if (y.operator === Condition.EQZ || y.operator === Condition.NEZ) {
                    return add(oldArray, {
                        expression: e.a,
                        operator: y.operator
                    });
                }
            }

            // (4*k+1)^(1/2)+1
            if (e instanceof Expression.Addition &&
                e.a instanceof Expression.Exponentiation &&
                Expression.isConstant(e.b) && //!
                e.a.b.getDenominator() instanceof Expression.Integer &&
                !e.a.b.getDenominator().equals(Expression.ONE)) {
                if (e.a.b.getDenominator().remainder(Expression.TWO).equals(Expression.ZERO) && !e.b.isNegative()) {
                    return add(oldArray, {
                        expression: Expression.ONE,
                        operator: y.operator
                    });
                }
                //if (!e.b.negate().pow(e.a.b.inverse()).pow(e.a.b).equals(e.b.negate())) {
                //  return add(oldArray, {expression: Expression.ONE, operator: y.operator});
                //}
                //TODO: fix
                return add(oldArray, {
                    expression: e.a.a.pow(e.a.b.getNumerator()).subtract(e.b.negate().pow(e.a.b.getDenominator())),
                    operator: y.operator
                });
            }

            if (y.expression instanceof Expression.Multiplication && y.expression.b instanceof Expression.IdentityMatrix) {
                return add(oldArray, {
                    expression: y.expression.a,
                    operator: y.operator
                });
            }
            if (y.expression instanceof Expression.Division) {
                var tmp = oldArray;
                tmp = add(tmp, {
                    expression: y.expression.a,
                    operator: y.operator
                });
                if (tmp == null) {
                    return null;
                }
                tmp = add(tmp, {
                    expression: y.expression.b,
                    operator: Condition.NEZ
                });
                return tmp;
            }
            /*if (y.expression instanceof Expression.Division && Expression.isConstant(y.expression.b)) {
              y = {
                expression: y.expression.a,
                operator: y.operator
              };
            }*/
            if (y.expression instanceof Expression.Integer || y.expression instanceof Expression.Complex) {
                if (y.operator === Condition.NEZ && y.expression.equals(Expression.ZERO) ||
                    y.operator === Condition.EQZ && !y.expression.equals(Expression.ZERO)) {
                    return null;
                }
                if (y.operator === Condition.GTZ && y.expression.equals(Expression.ZERO)) { //TODO: fix
                    return null;
                }
                if (y.operator === Condition.GTZ && y.expression instanceof Expression.Integer && y.expression.compareTo(Expression.ZERO) < 0) { //TODO: fix
                    return null;
                }
                return oldArray;
            }
            //TODO: check code coverage, remove extra branches
            if (Expression.isConstant(y.expression) && !y.expression.equals(Expression.ZERO)) {
                if (y.operator === Condition.NEZ) {
                    return oldArray;
                }
                if (y.operator === Condition.EQZ) {
                    return null;
                }
            }
            if (y.expression instanceof Expression.Matrix) {
                if (y.expression.matrix.isZero()) {
                    if (y.operator === Condition.EQZ) {
                        return oldArray;
                    }
                    if (y.operator === Condition.NEZ) {
                        return null;
                    }
                }
            }
            if (y.expression instanceof Expression.NthRoot) {
                return add(oldArray, {
                    expression: y.expression.a,
                    operator: y.operator
                });
            }
            if (Expression.has(y.expression, Expression.Abs)) {
                if (y.expression instanceof Expression.Abs && (y.operator === Condition.EQZ || y.operator === Condition.NEZ)) {
                    return add(oldArray, {
                        expression: y.expression.a,
                        operator: y.operator
                    });
                }
                if (y.expression instanceof Expression.Abs && (y.operator === Condition.GTZ)) {
                    return oldArray;
                }
                if (y.expression.negate() instanceof Expression.Abs && (y.operator === Condition.GTZ)) {
                    return null;
                }
            }
            if (Expression.has(y.expression, Expression.ComplexConjugate)) {
                if (!Expression.has(y.expression.complexConjugate(), Expression.ComplexConjugate)) {
                    return add(oldArray, {
                        expression: y.expression.complexConjugate(),
                        operator: y.operator
                    });
                }
            }
            if (y.expression instanceof Expression.Multiplication) {
                if (y.operator === Condition.EQZ) {
                    if (y.expression.a instanceof Expression.Integer && !y.expression.a.equals(Expression.ZERO)) {
                        //TODO: fix - ?
                        y = {
                            expression: y.expression.b,
                            operator: y.operator
                        };
                        return add(oldArray, y);
                    }
                }
                if (y.operator === Condition.NEZ) {
                    var tmp = oldArray;
                    tmp = add(tmp, {
                        expression: y.expression.a,
                        operator: Condition.NEZ
                    });
                    if (tmp == null) {
                        return null;
                    }
                    tmp = add(tmp, {
                        expression: y.expression.b,
                        operator: Condition.NEZ
                    });
                    return tmp;
                }
            }

            var p = Expression.getMultivariatePolynomial(y.expression);
            if (p != null) {
                //!new 2018-12-24
                //TODO: fix (?Polynomial#getContent()?)
                var t = Expression.getNthRootConjugate(p.p.getLeadingCoefficient());
                if (t != undefined && Expression.isConstant(t)) { //TODO: fix
                    return add(oldArray, {
                        expression: t.multiply(y.expression),
                        operator: y.operator
                    });
                }
                //!
                var content = p.p.getContent();
                if (!content.equals(Expression.ONE) && !content.equals(Expression.ONE.negate())) {
                    // content * y.expression.divide(content)
                    if (y.operator === Condition.NEZ) {
                        var tmp = add(oldArray, {
                            expression: y.expression.divide(content),
                            operator: Condition.NEZ
                        });
                        if (tmp == null) {
                            return null;
                        }
                        return add(tmp, {
                            expression: content,
                            operator: Condition.NEZ
                        });
                    }
                    while (p != null) {
                        if (y.operator === Condition.EQZ) {
                            var sf = p.p.getSquareFreePolynomial();
                            if (sf.getDegree() !== p.p.getDegree()) {
                                //?
                                return add(oldArray, {
                                    expression: y.expression.divide(p.p.divideAndRemainder(sf).quotient.calcAt(p.v)),
                                    operator: Condition.EQZ
                                });
                            }
                        }
                        content = p.p.getContent();
                        p = Expression.getMultivariatePolynomial(content);
                    }
                    //!new
                    if (Expression.isConstant(content)) {
                        if (!content.equals(Expression.ONE) && !content.equals(Expression.ONE.negate())) {
                            return add(oldArray, {
                                expression: y.expression.divide(content),
                                operator: Condition.EQZ
                            });
                        }
                    }
                    //y = {
                    //  expression: y.expression.divide(content),
                    //  operator: y.operator
                    //};
                }
                if (p != null && p.p.getDegree() > 1 && p.p.getCoefficient(0).equals(Expression.ZERO)) {
                    if (y.operator === Condition.NEZ) {
                        var tmp = add(oldArray, {
                            expression: p.v,
                            operator: Condition.NEZ
                        });
                        if (tmp == null) {
                            return null;
                        }
                        return add(tmp, {
                            expression: y.expression.divide(p.v),
                            operator: Condition.NEZ
                        });
                    }
                }
            }

            //!new 2019-12-24:
            var p = Expression.getMultivariatePolynomial(y.expression);
            if (p != null && p.p.getDegree() > 1) {
                var sf = p.p.getSquareFreePolynomial();
                if (sf.getDegree() !== p.p.getDegree()) { //TODO: test, fix
                    if (y.operator === Condition.EQZ || y.operator === Condition.NEZ) {
                        return add(oldArray, {
                            expression: sf.calcAt(p.v),
                            operator: y.operator
                        });
                    }
                }
            }
            //!

            var addRest = function(newArray, oldArray, i, other) {
                if (newArray == null) {
                    return null;
                }
                for (var j = i + 1; j < oldArray.length; j += 1) {
                    newArray = add(newArray, oldArray[j]);
                    if (newArray == null) {
                        return null;
                    }
                }
                if (other != null) {
                    newArray = add(newArray, other);
                }
                return newArray;
            };


            var newArray = [];
            for (var i = 0; i < oldArray.length; i += 1) {
                var x = oldArray[i]; // TODO: const


                // (e**(tx)-e**(-tx))/(2i)
                // (e**(tx)+e**(-tx))/2

                // sin(x)=0, cos(x)=0
                //!new 2020-01-01:
                if (Expression.has(x.expression, Expression.Sin) || Expression.has(x.expression, Expression.Cos)) {
                    if (Expression.has(y.expression, Expression.Sin) || Expression.has(y.expression, Expression.Cos)) {
                        var xx = {
                            operator: x.operator,
                            expression: Expression._replaceSinCos(x.expression)
                        };
                        var yy = {
                            operator: y.operator,
                            expression: Expression._replaceSinCos(y.expression)
                        };
                        var tmp1 = add([], xx);
                        if (tmp1 == null) {
                            return null;
                        }
                        var tmp = add(tmp1, yy);
                        if (tmp == null) {
                            return null;
                        }
                        if (tmp.length === 0) {
                            return []; //TODO: remove
                        }
                        if (tmp.length === 1) {
                            return addRest(newArray, oldArray, i, {
                                operator: tmp[0].operator,
                                expression: Expression._replaceBySinCos(tmp[0].expression)
                            });
                        }
                        //TODO: ?
                        //for (var i = 0; i < tmp.length; i++) {
                        //  newArray = add(newArray, {operator: tmp[i].operator, expression: Expression._replaceBySinCos(tmp[i].expression)});
                        //}
                        //return addRest(newArray, oldArray, i, {operator: Condition.EQZ, expression: Expression.ZERO});

                        // cos(y)=0, r*sin(y)=0
                        for (var i = 0; i < tmp.length; i++) {
                            if (!Expression.has(tmp[i], Expression.Exponentiation)) { //TODO: ?
                                if (tmp[i].expression.gcd(y.expression).equals(tmp[i].expression)) {
                                    newArray = add(newArray, x);
                                    return addRest(newArray, oldArray, i, {
                                        operator: tmp[i].operator,
                                        expression: Expression._replaceBySinCos(tmp[i].expression)
                                    });
                                }
                            }
                        }

                    }
                }
                //!
                if (Expression.has(x.expression, Expression.Function) || Expression.has(x.expression, Expression.Exponentiation)) {
                    if (!(Expression.has(y.expression, Expression.Function) || Expression.has(y.expression, Expression.Exponentiation))) {
                        return addRest(add(newArray, y), oldArray, i, x);
                    }
                }

                if ((x.operator === Condition.NEZ && y.operator === Condition.EQZ ||
                        x.operator === Condition.EQZ && y.operator === Condition.NEZ) &&
                    (Expression.isSingleVariablePolynomial(x.expression.multiply(y.expression)) || true)) {
                    var g = x.expression.polynomialGCD(y.expression);
                    //var g = x.expression.gcd(y.expression);
                    while (!g.equals(Expression.ONE) && !g.equals(Expression.ONE.negate())) {
                        if (x.operator === Condition.EQZ) {
                            x = {
                                operator: x.operator,
                                expression: x.expression.divide(g)
                            };
                            // the change may affect all previous conditions:
                        } else { // y.operator === Condition.EQZ
                            y = {
                                operator: y.operator,
                                expression: y.expression.divide(g)
                            };
                            // we have not checked the y agains the branches in the beginning of the "add"
                        }
                        newArray = add(newArray, x);
                        if (newArray == null) {
                            return null;
                        }
                        return addRest(newArray, oldArray, i, y);
                        //g = x.expression.gcd(y.expression);
                    }
                    //if (x.operator === Condition.EQZ) {
                    //  var tmp = y;
                    //  y = x;
                    //  x = tmp;
                    //}
                    if (x.operator === Condition.EQZ && Expression.isConstant(x.expression)) {
                        return null;
                    }
                    if (y.operator === Condition.EQZ && Expression.isConstant(y.expression)) {
                        return null;
                    }
                    //if (!Expression.isSingleVariablePolynomial(x.expression.multiply(y.expression))) {
                    //  if (x.operator === Condition.EQZ) {
                    //    newArray.push(y);
                    //  } else {
                    //    newArray.push(x);
                    //  }
                    //}
                }
                var newMethodEnabled = true;
                var singleVariablePolynomials = Expression.isSingleVariablePolynomial(x.expression) &&
                    Expression.isSingleVariablePolynomial(y.expression) &&
                    Expression.isSingleVariablePolynomial(x.expression.multiply(y.expression));
                if (x.operator === Condition.NEZ && y.operator === Condition.EQZ && singleVariablePolynomials) {
                    y = y;
                } else if (x.operator === Condition.EQZ && y.operator === Condition.NEZ && singleVariablePolynomials) {
                    y = x;
                } else if (x.operator === Condition.EQZ && y.operator === Condition.EQZ && singleVariablePolynomials) {
                    var g = x.expression.polynomialGCD(y.expression);
                    //var g = x.expression.gcd(y.expression);
                    if (g instanceof Expression.Integer) {
                        return null;
                    }
                    y = {
                        operator: y.operator,
                        expression: g
                    };
                    return addRest(newArray, oldArray, i, y);
                } else if (x.operator === Condition.NEZ && y.operator === Condition.NEZ && singleVariablePolynomials) {
                    var g = x.expression.gcd(y.expression);
                    x = {
                        operator: x.operator,
                        expression: x.expression.divide(g)
                    };
                    if (!Expression.isConstant(x.expression)) {
                        newArray.push(x);
                    }
                } else { // !isSingleVariablePolynomial
                    // TODO: use Expression.isSingleVariablePolynomial(x.expression.multiply(y.expression))) here, and remove in the branches above


                    //!new 2020-16-02
                    var getConstant = function(e) {
                        if (e instanceof Expression.Multiplication && e.a instanceof Expression.Matrix) { //TODO: ?
                            return e.a.multiply(getConstant(e.b));
                        }
                        var c = Expression.getConstant(e);
                        for (var iteratorf = e.divide(c).factors()[globalThis.Symbol.iterator](), f = iteratorf.next().value; f != null; f = iteratorf.next().value) {
                            if (f instanceof Expression.NthRoot && Expression.isConstant(f.a)) {
                                c = c.multiply(f);
                            }
                        }
                        return c;
                    };
                    var collapse = function(e, candidate) { // sqrt(2)*x*y+2*x*y
                        var term0 = candidate.divide(getConstant(candidate));
                        var result = Expression.ZERO;
                        for (var iteratora = e.summands()[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
                            var term = a.divide(getConstant(a));
                            if (term.equals(term0)) {
                                result = result.add(a);
                            }
                        }
                        return result;
                    };
                    var getPivotMonomial = function(e) {
                        // https://en.wikipedia.org/wiki/Monomial_order#Lexicographic_order
                        //TODO: change compare4Addition (?)
                        var getExponent = function(x) {
                            return x instanceof Expression.Exponentiation ? x.b : Expression.ONE;
                        };
                        var getBase = function(x) {
                            return x instanceof Expression.Exponentiation ? x.a : x;
                        };
                        var totalDegree = function(e) {
                            var result = Expression.ZERO;
                            for (var iteratorf = e.factors()[globalThis.Symbol.iterator](), f = iteratorf.next().value; f != null; f = iteratorf.next().value) {
                                if (!Expression.isConstant(f)) {
                                    var e = getExponent(f);
                                    //if (e instanceof Expression.Integer) {//?
                                    result = result.add(e);
                                    //}
                                }
                            }
                            return result;
                        };
                        var compare = function(x, y) {
                            //TODO: better order (see Wikipedia)
                            var s = totalDegree(x).subtract(totalDegree(y));
                            var c = s.isNegative() ? -1 : (s.negate().isNegative() ? +1 : 0);
                            if (c !== 0) {
                                return c;
                            }
                            //return x.compare4Addition(y);
                            //TODO: change Expression#compare4Addition - ?
                            var reversedFactors = function(e) {
                                return Array.from(e.divide(Expression.getConstant(e)).factors()).reverse().filter(function(e) {
                                    return !Expression.isConstant(e);
                                }).values();
                            };
                            var i = reversedFactors(x);
                            var j = reversedFactors(y);
                            var a = i.next().value;
                            var b = j.next().value;
                            while (a != null && b != null) {
                                var c = (0 - getBase(a).compare4Multiplication(getBase(b))) || getExponent(a).compare4Multiplication(getExponent(b));
                                if (c !== 0) {
                                    return c;
                                }
                                a = i.next().value;
                                b = j.next().value;
                            }
                            return a != null ? +1 : (b != null ? -1 : 0);
                        };
                        var candidate = null;
                        for (var iteratora = e.summands()[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
                            if (candidate == null || compare(a, candidate) > 0) {
                                candidate = a;
                            }
                        }
                        return candidate;
                    };
                    if (newMethodEnabled && x.operator === Condition.EQZ) {
                        var pivot = getPivotMonomial(x.expression);
                        var p = pivot.divide(getConstant(pivot))._abs();
                        pivot = collapse(x.expression, pivot);
                        var newYExpression = y.expression;
                        var c1 = 0;
                        for (var iteratora = y.expression.summands()[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
                            if (a.gcd(p)._abs().equals(p)) {
                                newYExpression = newYExpression.subtract(a.divide(pivot).multiply(x.expression));
                                c1 += 1;
                            }
                        }
                        if (c1 > 0) {
                            return addRest(add(newArray, x), oldArray, i, {
                                expression: newYExpression,
                                operator: y.operator
                            });
                        }
                    }
                    if (newMethodEnabled && y.operator === Condition.EQZ) {
                        var pivot = getPivotMonomial(y.expression);
                        var p = pivot.divide(getConstant(pivot))._abs();
                        pivot = collapse(y.expression, pivot);
                        for (var iteratora = x.expression.summands()[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
                            if (a.gcd(p)._abs().equals(p)) {
                                var newXExpression = x.expression.subtract(a.divide(pivot).multiply(y.expression));
                                //trying to avoid infinite recursion:
                                if (x.operator === Condition.EQZ) { //?
                                    return addRest(add(newArray, {
                                        expression: newXExpression,
                                        operator: x.operator
                                    }), oldArray, i, y);
                                }
                                return addRest(add(newArray, y), oldArray, i, {
                                    expression: newXExpression,
                                    operator: x.operator
                                });
                            }
                        }
                    }
                    if (newMethodEnabled && true) {
                        // Condition.TRUE.andNotZero(ExpressionParser.parse('b*c-a*d')).andZero(ExpressionParser.parse('2*b*c-2*a*d+b*c*d+c*d-a*d^2')) + ''
                        if (x.operator === Condition.NEZ && y.operator === Condition.EQZ) {
                            // consider y = x * q + r, where q is not zero (? and x is not zero)
                            // then y != r

                            var pivot = getPivotMonomial(x.expression);
                            var p = pivot.divide(Expression.getConstant(pivot));
                            for (var iteratora = y.expression.summands()[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
                                if (a.gcd(p).equals(p) || a.gcd(p).equals(p.negate())) {
                                    var q = a.divide(pivot);
                                    if (q instanceof Expression.Integer && !q.equals(Expression.ZERO)) { //TODO: when q is a multiplicaiton of other != 0 conditions
                                        //?TODO: prevent infinite loop: how?
                                        var r = y.expression.subtract(q.multiply(x.expression));
                                        var rr = {
                                            expression: r,
                                            operator: Condition.NEZ
                                        };
                                        var flag = false;
                                        if (true) {
                                            //! 2020-07-05
                                            var flag = false;
                                            for (var ii = 0; ii < oldArray.length; ii++) {
                                                var n = oldArray[ii];
                                                if (n.operator === Condition.EQZ) {
                                                    var g = n.expression.gcd(rr.expression);
                                                    if (!g.equals(Expression.ONE) && !g.equals(Expression.ONE.negate())) {
                                                        flag = true;
                                                    }
                                                }
                                            }
                                        }
                                        //flag = oldArray.length < add(oldArray.slice(0), rr).length;//?TODO: better way
                                        if (flag) {
                                            return addRest(add(add(newArray, x), rr), oldArray, i - 1, y);
                                        }
                                    }
                                }
                            }

                        }
                    }
                    //!
                    if (!newMethodEnabled || true) {

                        var p = null;
                        var pOperator = null;
                        var pp = null;
                        var other = null;
                        var px = Expression.getMultivariatePolynomial(x.expression);
                        var py = Expression.getMultivariatePolynomial(y.expression);
                        //var xy = Expression.getMultivariatePolynomial(x.expression.multiply(y.expression));

                        if (y.operator === Condition.EQZ && py != null && py.p.getDegree() !== 1) {
                            var tmp = Expression.getMultivariatePolynomial(py.p.getCoefficient(0));
                            if (tmp != null) {
                                var v = tmp.v;
                                if (v instanceof Expression.Symbol && tmp.p.getDegree() === 1) {
                                    py = {
                                        p: Polynomial.toPolynomial(y.expression, v),
                                        v: v
                                    };
                                }
                            }
                        }

                        //console.assert(px != null && py != null);

                        if ( //xy != null &&
                            //x.operator === Condition.EQZ &&
                            //y.operator === Condition.EQZ &&
                            px != null && py != null) {


                            //!new 2019-24-12
                            /*
                            //TODO: remove - buggy - ?
                            if (!newMethodEnabled && px != null && py != null && px.v.equals(py.v) && px.p.getDegree() !== 1 && py.p.getDegree() !== 1 && x.operator === Condition.EQZ && y.operator === Condition.EQZ) {
                              //TODO: test, fix
                              var tmp1 = py.p.getDegree() >= px.p.getDegree() ? Polynomial.pseudoRemainder(py.p, px.p) : py.p;
                              var tmp2 = tmp1.calcAt(px.v);
                              var tmp = {expression: tmp2, operator: y.operator};
                              newArray = add(newArray, tmp);
                              if (newArray == null) {
                                return null;
                              }
                              return addRest(newArray, oldArray, i, x);
                            }
                            */
                            //!?

                            //if (px != null && px.p.getDegree() !== 1 && py == null) {
                            //py = {p: Polynomial.toPolynomial(y.expression, px.v), v: px.v};
                            //if (xy.v === py.v) {
                            //  py = null;
                            //}
                            //}
                            //if (px == null && py != null && py.p.getDegree() !== 1) {
                            //px = {p: Polynomial.toPolynomial(x.expression, py.v), v: py.v};
                            //if (xy.v === px.v) {
                            //  px = null;
                            //}
                            //}
                            //if (px == null && py == null) {//?TODO:
                            //  px = {p: Polynomial.toPolynomial(x.expression, xy.v), v: xy.v};
                            //  py = {p: Polynomial.toPolynomial(y.expression, xy.v), v: xy.v};
                            //}

                            if (y.operator === Condition.EQZ && py != null && py.p.getDegree() === 1 &&
                                x.operator === Condition.EQZ && px != null && px.p.getDegree() === 1) {
                                //TODO: fix !!!
                                //TODO: test linear systems
                                if (Expression._getReplacement(y.expression, px.v).equals(px.v) && Polynomial.toPolynomial(y.expression, px.v).getDegree() === 0) {
                                    px = null;
                                }
                                if (Expression._getReplacement(x.expression, py.v).equals(py.v) && Polynomial.toPolynomial(x.expression, py.v).getDegree() === 0) {
                                    py = null;
                                }

                                if (px != null && py != null) { // TODO: ?
                                    if (!(px.p.getCoefficient(1) instanceof Expression.Integer)) {
                                        px = null;
                                    }
                                    if (!(py.p.getCoefficient(1) instanceof Expression.Integer)) {
                                        py = null;
                                    }
                                }

                                if (px != null && py != null) {

                                    //if (px.v.symbol < py.v.symbol) {//!
                                    if (px.v.compare4Addition(py.v) < 0) {
                                        px = null;
                                    }
                                    //}

                                }
                            }

                            if (y.operator === Condition.EQZ && py != null && py.p.getDegree() === 1) {
                                pp = py;
                                p = x.expression;
                                pOperator = x.operator;
                                other = y;
                            }
                            if (x.operator === Condition.EQZ && px != null && px.p.getDegree() === 1) {
                                pp = px;
                                p = y.expression;
                                pOperator = y.operator;
                                other = x;
                            }
                        }
                        if (pp != null) {
                            var ok = false;
                            // x = -b / a if a !== 0
                            ok = ok || pp.p.getDegree() === 1 && Expression.isConstant(pp.p.getCoefficient(1)) && Expression.isConstant(pp.p.getCoefficient(0));
                            // a * x + 1 = function (0) { return a !== 0 && x !== function (0) { return x = -1 / a; }; }
                            ok = ok || pp.p.getDegree() === 1 && Expression.isConstant(pp.p.getCoefficient(0)) && !pp.p.getCoefficient(0).equals(Expression.ZERO) && Expression.has(p, Expression.Exponentiation);
                            //if (Expression.isSingleVariablePolynomial(p) && pp.v instanceof Expression.Symbol && Expression.getVariable(pp.p.getCoefficient(0)) != null && Expression.getVariable(pp.p.getCoefficient(0)).compare4Multiplication(pp.v) > 0) {
                            //  ok = ok || pp.p.getDegree() === 1 && Expression.isConstant(pp.p.getCoefficient(1));
                            //}
                            //if ((pp.p.getCoefficient(1) instanceof Expression.Integer || polynomial.divideAndRemainder(pp.p, "undefined") != undefined || (!pp.p.getCoefficient(0).equals(Expression.ZERO) && Expression.isConstant(pp.p.getCoefficient(0)))) &&
                            //    (!newMethodEnabled || Expression.isConstant(pp.p.getCoefficient(0)) || (pp.p.getCoefficient(1) instanceof Expression.Integer && Expression.isSingleVariablePolynomial(polynomial.calcAt(pp.p.getCoefficient(0).negate().divide(pp.p.getCoefficient(1)))))) && //!? new 2020-06-18
                            //    !(p instanceof Expression.Symbol) || (polynomial.calcAt(pp.p.getCoefficient(0).negate().divide(pp.p.getCoefficient(1))) instanceof Expression.Integer)) {//TODO: replace only if the result is more simple (?): a*v != 0 or b != 0
                            if (ok) {
                                var alpha = pp.p.getCoefficient(0).negate().divide(pp.p.getCoefficient(1));
                                //var polynomial = Polynomial.toPolynomial(p, pp.v);
                                //var a = polynomial.calcAt(alpha);
                                var a = Expression._substitute(p, pp.v, alpha, {
                                    uniqueObject: 1
                                });
                                if (!a.equals(p)) {
                                    var tmp = {
                                        operator: pOperator,
                                        expression: a
                                    };
                                    newArray = add(newArray, tmp);
                                    if (newArray == null) {
                                        return null;
                                    }
                                    if (true) {
                                        return addRest(newArray, oldArray, i, other);
                                    } else {
                                        y = other;
                                    }
                                } else {
                                    newArray.push(x);
                                }
                            } else {
                                newArray.push(x);
                            }
                        } else {
                            newArray.push(x);
                        }
                    } else {
                        newArray.push(x);
                    }
                }
            }
            newArray.push(y);

            /*
            var allNEZ = function* (array) {
              for (var i = 0; i < array.length; i += 1) {
                var y = array[i];
                if (y.operator === Condition.EQZ) {
                  for (var j = 0; j < array.length; j += 1) {
                    var x = array[j];
                    if (x.operator === Condition.NEZ) {
                      // Condition.TRUE.andNotZero(ExpressionParser.parse('b*c-a*d')).andZero(ExpressionParser.parse('2*b*c-2*a*d+b*c*d+c*d-a*d^2')) + ''
                      // consider y = x * q + r, where q is not zero
                      // then y != r

                      var pivot = getPivotMonomial(x.expression);
                      var p = pivot.divide(Expression.getConstant(pivot));
                      for (var iteratora = y.expression.summands()[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
                        if (a.gcd(p).equals(p) || a.gcd(p).equals(p.negate())) {
                          var q = a.divide(pivot);
                          if (q instanceof Expression.Integer && !q.equals(Expression.ZERO)) {//TODO: when q is a multiplicaiton of other != 0 conditions
                            //?TODO: prevent infinite loop: how?
                            var r = y.expression.subtract(q.multiply(x.expression));
                            //if (oldArray.length < add(oldArray.slice(0), {expression: r, operator: Condition.NEZ}).length) {//?TODO: better way
                            //  return addRest(add(add(newArray, x), {expression: r, operator: Condition.NEZ}), oldArray, i - 1, y);
                            //}
                            yield r;
                          }
                        }
                      }
                    }
                  }
                }
              }

            };

            for (var i = 0; i < newArray.length; i += 1) {
              var y = newArray[i];
              if (y.operator === Condition.EQZ) {
                for (var iteratornez = allNEZ(newArray)[globalThis.Symbol.iterator](), nez = iteratornez.next().value; nez != null; nez = iteratornez.next().value) {
                  var g = y.expression.gcd(nez);
                  if (!g.equals(Expression.ONE) && !g.equals(Expression.ONE.negate())) {
                    return add(newArray, {expression: y.expression.divide(g), operator: Condition.EQZ});
                  }
                }
              }
            }
            */

            //?
            //TODO: only when multiple variables and has `f != 0`
            //TODO: test with replacements
            //TODO: !!!
            if (newMethodEnabled && true) {
                var base = new Condition(newArray);
                for (var i = 0; i < newArray.length; i += 1) {
                    var y = newArray[i];
                    if (y.operator === Condition.EQZ) {
                        var f = y.expression;
                        /*
                        //if (!Expression.isSingleVariablePolynomial(f)) {// performace (?)
                          if (!Expression.isConstant(f.divide(Expression.simpleDivisor(f)))) {
                            while (!Expression.isConstant(f)) {
                              var d = Expression.simpleDivisor(f);
                              var q = f.divide(d);
                              if (new Condition(newArray.slice(0, i).concat(newArray.slice(i + 1))).andZero(d).isFalse()) { // TODO: fix
                                return add(newArray, {expression: d, operator: Condition.NEZ});
                              }
                              f = q;
                            }
                          }
                        //}
                        */
                        var g = null;
                        for (var iterators = f.summands()[globalThis.Symbol.iterator](), s = iterators.next().value; s != null; s = iterators.next().value) {
                            var a = s.divide(Expression.getConstant(s));
                            if (g == null) {
                                g = a;
                            } else {
                                g = g.gcd(a);
                            }
                        }
                        if (!g.equals(Expression.ONE) && f instanceof Expression.Addition) {
                            // can g be equal to 0 ?
                            if (new Condition(newArray.slice(0, i).concat(newArray.slice(i + 1))).andZero(g).isFalse()) { // TODO: fix
                                return add(newArray, {
                                    expression: g,
                                    operator: Condition.NEZ
                                });
                            }
                        }

                    }
                }
            }
            //?

            return newArray;
        };

        //!new 2021-10-06
        if (e instanceof Expression.Division) { //TODO: !?
            return this._and(operator, e.getNumerator()).andNotZero(e.getDenominator());
        }
        //TODO: other cases, other types
        var c = this;
        if (true && operator === Condition.EQZ) {
            var getVariable1 = function(e) {
                var candidate = undefined;
                for (var iterators = e.summands()[globalThis.Symbol.iterator](), s = iterators.next().value; s != null; s = iterators.next().value) {
                    for (var iteratorf = s.factors()[globalThis.Symbol.iterator](), f = iteratorf.next().value; f != null; f = iteratorf.next().value) {
                        var b = f instanceof Expression.Exponentiation ? f.a : f;
                        if (b instanceof Expression.Symbol) {
                            if (candidate == undefined || b.symbol < candidate.symbol) {
                                candidate = b;
                            }
                        }
                    }
                }
                return candidate;
            };
            var v = getVariable1(e);
            if (v != undefined && Polynomial.of(e)._hasIntegerLikeCoefficients()) { // a^(1/2) or a/2
                var ep = Polynomial.toPolynomial(e, v);
                for (var iteratorx = this.array[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
                    if (x.operator === Condition.EQZ) {
                        if (Polynomial.of(x.expression)._hasIntegerLikeCoefficients() && getVariable1(x.expression).symbol >= v.symbol) {
                            var xp = Polynomial.toPolynomial(x.expression, v);
                            if (xp.getDegree() >= 1) {
                                var g = Polynomial.polynomialGCD(ep, xp); //TODO: !?
                                if (g.getDegree() === 0) { // it is slow to compute resultant, while it should be zero when gcd != 1
                                    var res = Polynomial.resultant(ep, xp);
                                    c = c.andZero(res);
                                    if (c.isFalse()) {
                                        return c;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        //!

        var newArray = add(c.array, {
            operator: operator,
            expression: e
        });
        if (newArray == null) {
            return Condition.FALSE;
        }
        if (newArray.length === 0) {
            return Condition.TRUE;
        }

        return new Condition(newArray);
    };

    Condition.prototype.andNotZero = function(e) {
        return this._and(Condition.NEZ, e);
    };
    Condition.prototype.andZero = function(e) {
        return this._and(Condition.EQZ, e);
    };
    Condition.prototype.andGreaterZero = function(e) {
        return this._and(Condition.GTZ, e);
    };
    Condition.prototype.and = function(b) {
        if (!(b instanceof Condition)) {
            throw new TypeError();
        }
        var c = this;
        for (var i = 0; i < b.array.length; i += 1) {
            c = c._and(b.array[i].operator, b.array[i].expression);
        }
        return c;
    };
    Condition.prototype.isFalse = function() {
        return this === Condition.FALSE;
    };
    Condition.prototype.isTrue = function() {
        return this === Condition.TRUE;
    };
    Condition.prototype.toString = function(options) {
        if (this === Condition.TRUE || this === Condition.FALSE) {
            // 1) no need; 2) no way to distinguish TRUE and FALSE
            throw new TypeError();
        }
        if (this.array.length === 0) {
            // assertion
            throw new TypeError();
        }
        var s = '';
        for (var i = 0; i < this.array.length; i += 1) {
            s += (i !== 0 ? ', ' : '') + this.array[i].expression.toString(options) + this.array[i].operator;
        }
        return s;
    };

    Condition.TRUE = new Condition(new Array(0));
    Condition.FALSE = new Condition(undefined);


    Condition.prototype.getSolutionFor = function(variable) {
        var condition = this;
        if (condition.array == null) {
            return null;
        }
        for (var i = 0; i < condition.array.length; i += 1) {
            var c = condition.array[i];
            if (c.operator === Condition.EQZ) {
                var p = Polynomial.toPolynomial(c.expression, variable);
                if (p.getDegree() === 1) {
                    return p.getroots()[0];
                }
            }
        }
        return null;
    };

    Condition.prototype.updateExpression = function(e, options) {
        return this.andNotZero(e).isFalse() ? Expression.ZERO : e;
        //var symbol = new Expression.Symbol('$e');
        //var condition = options && options.flag1 ? this : new Condition(this.array.filter(function (x) { return x.expression instanceof Expression.Symbol && x.operator === Condition.EQZ; }));
        //var c2 = condition.andZero(e.subtract(symbol));
        //return c2.getSolutionFor(symbol);
        //return e;
    };

    self.Condition = Condition;

})();
(function() {
    "use strict";

    //TODO:
    //TODO:
    //TODO:

    //TODO: remove - ?


    //!TODO: remove
    Polynomial.prototype.toString = function(options) {
        options = options || {};
        return this.toExpression(options.polynomialVariable || new Expression.Symbol("x")).toString(options);
    };
    Polynomial.prototype.toMathML = function(options) {
        options = options || {};
        return this.toExpression(options.polynomialVariable || new Expression.Symbol("x")).toMathML(options);
    };
    Expression.Polynomial.prototype.toString = function(options) {
        return this.polynomial.toString(options);
    };
    Expression.Polynomial.prototype.toMathML = function(options) {
        return this.polynomial.toMathML(options);
    };

    // coefficient - Expression
    // variable - Expression
    var printPartOfAddition = function(isLast, isFirst, coefficient, variable, options) {
        if (coefficient.equals(Expression.ZERO)) {
            return isLast && isFirst ? Expression.ZERO.toMathML() : "";
        }
        var isNegative = false;
        if (coefficient.isNegative() && !isFirst) {
            isNegative = true;
            coefficient = coefficient.negateCarefully(); //?
        }

        var precedenceOfMultiptication = new Expression.Multiplication(Expression.ZERO, Expression.ZERO).getPrecedence();
        var areBracketsRequired = coefficient.getPrecedence() < precedenceOfMultiptication; //?
        var c = coefficient.equals(Expression.ONE);
        //TODO: fix
        return (isFirst ? '' : '') + (!isFirst && isNegative ? '<mo form="infix">&minus;</mo>' : '') + (!isFirst && !isNegative ? '<mo form="infix">+</mo>' : '') + (c ? '' : '<mrow>') + (c || !areBracketsRequired ? '' : '<mrow><mo>(</mo>') + (c ? '' : coefficient.toMathML(options)) + (c || !areBracketsRequired ? '' : '<mo>)</mo></mrow>') + (c ? '' : '<mo>&sdot;</mo>') + variable.toMathML(options) + (c ? '' : '</mrow>');
    };
    var decimalToMathML = function(decimal) {
        var match = /^([+\-])?(\d+\.?\d*(?:\(\d+\)\d*)?)(?:[eE]\+?(\-?\d+))?$/.exec(decimal);
        var groups = {
            sign: match[1] || "",
            significand: match[2] || "",
            exponent: match[3] || ""
        };
        return (groups.exponent !== "" ? "<mrow>" : "") + (groups.sign !== "" ? "<mrow>" : "") + (groups.sign === "+" ? "<mo>+</mo>" : "") + (groups.sign === "-" ? "<mo>&minus;</mo>" : "") + "<mn>" + numberFormat.format(groups.significand.replace(/[\(\)]/g, '')).replace(/^[\s\S]+$/g, function(p) {
            var a = groups.significand.indexOf('(');
            var b = groups.significand.lastIndexOf(')');
            if (a === -1 || b === -1) {
                return p;
            }
            var digitLength = numberFormat.format('0').trim().length;
            var i = p.length - (groups.significand.length - a - '('.length - ')'.length) * digitLength;
            var j = p.length - (groups.significand.length - b - ')'.length) * digitLength;
            return p.slice(0, i) + '<span style="text-decoration:overline;">' + p.slice(i, j) + '</span>' + p.slice(j);
        }) + "</mn>" + (groups.sign !== "" ? "</mrow>" : "") + (groups.exponent !== "" ? "<mo lspace=\"0\" rspace=\"0\">&sdot;</mo>" + "<msup>" + "<mn>" + numberFormat.format('10') + "</mn>" + decimalToMathML(groups.exponent) + "</msup>" : "") + (groups.exponent !== "" ? "</mrow>" : "");
    };
    var complexToMathML = function(real, imaginary) {
        if (imaginary.replace(/<[^>]+>/g, '') === '1') {
            return '<mrow>' + real + '<mo>+</mo><mi>&ii;</mi></mrow>';
        }
        if (imaginary.replace(/<[^>]+>/g, '').replace(/&minus;/g, '-') === '-1') {
            return '<mrow>' + real + '<mo>&minus;</mo><mi>&ii;</mi></mrow>';
        }
        if (real === '') {
            return '<mrow>' + imaginary + '<mo>' + (/<msup>/.test(imaginary) || /[^0-9]/.test(imaginary) ? '&sdot;' : '&it;') + '</mo><mi>&ii;</mi></mrow>';
        }
        var signBetween = '+';
        if (/<mrow><mo>&minus;<\/mo><mn>([^<]*)<\/mn><\/mrow>(?!<\/msup>)/.test(imaginary)) {
            signBetween = '-';
            imaginary = imaginary.replace(/<mrow><mo>&minus;<\/mo><mn>([^<]*)<\/mn><\/mrow>(?!<\/msup>)/g, '<mn>$1</mn>');
        }
        return '<mrow>' + real + '<mo>' + (signBetween === '-' ? '&minus;' : '+') + '</mo>' + '<mrow>' + imaginary + '<mo>' + (/<msup>/.test(imaginary) || /[^0-9]/.test(imaginary) ? '&sdot;' : '&it;') + '</mo>' + '<mi>&ii;</mi>' + '</mrow>' + '</mrow>';
    };
    Expression._decimalToMathML = decimalToMathML;
    Expression._complexToMathML = complexToMathML;

    function isConstant(e) {
        if (e instanceof Expression.NonSimplifiedExpression) {
            return false;
        }
        if (e instanceof Expression.Matrix) {
            return false;
        }
        if (e instanceof Expression.Polynomial) {
            return false;
        }
        return Expression.isConstant(e);
    }
    var groupByTerm = function(e) {
        if (e instanceof Expression.Division || e instanceof Expression.Addition) {
            var numerator = e.getNumerator();
            var denominator = e.getDenominator();
            //TODO: fix
            var denominatorContent = denominator instanceof Expression.Integer ? denominator : (Expression.getMultivariatePolynomial(denominator) || {
                p: {
                    getContent: function() {
                        return Expression.ONE;
                    }
                }
            }).p.getContent();
            var denominatorRest = denominator.divide(denominatorContent);
            if (isConstant(denominatorContent)) {
                //TODO: fix when the content has multiple variables
                var summands = [];
                for (var iteratorsummand = numerator.summands()[globalThis.Symbol.iterator](), summand = iteratorsummand.next().value; summand != null; summand = iteratorsummand.next().value) {
                    summands.push(summand);
                }
                var map = {}; //TODO: FIX, test(?)
                summands.reverse();
                for (var i = 0; i < summands.length; i += 1) {
                    var summand = summands[i];
                    //var constant = Expression.getConstant(summand); - ?
                    var constant = Expression.ONE;
                    for (var iteratorfactor = summand.factors()[globalThis.Symbol.iterator](), factor = iteratorfactor.next().value; factor != null; factor = iteratorfactor.next().value) {
                        if (isConstant(factor)) {
                            constant = constant.multiply(factor);
                        }
                    }
                    var term = summand.divide(constant);
                    var key = "_" + term.toString();
                    map[key] = map[key] || {
                        constant: Expression.ZERO,
                        term: term
                    };
                    map[key].constant = map[key].constant.add(constant.divide(denominatorContent));
                }
                var result = null;
                for (var key in map) {
                    if (Object.prototype.hasOwnProperty.call(map, key)) {
                        var constant = map[key].constant;
                        var term = map[key].term;
                        var s = false;
                        if (result != null && constant.isNegative()) {
                            constant = constant.negate();
                            s = true;
                        }
                        var x = new NonSimplifiedExpression(term.equals(Expression.ONE) ? constant : constant.equals(Expression.ONE) ? map[key].term : new Expression.Multiplication(constant, map[key].term));
                        result = result == null ? x : new Expression.Addition(result, s ? new Expression.Multiplication(Expression.ONE.negate(), x) : x);
                    }
                }
                if (!denominatorRest.equals(Expression.ONE)) {
                    result = new Expression.Division(result, denominatorRest);
                }
                return new NonSimplifiedExpression(result);
            }
        }
        return undefined;
    };
    var getRounding = function(options) {
        var rounding = options != undefined ? options.rounding : undefined;
        if (options != undefined && rounding == undefined && options.fractionDigits != undefined && options.fractionDigits !== -1) {
            console.debug('deprecated fractionDigits, use rounding instead');
            rounding = {
                fractionDigits: options.fractionDigits
            };
        }
        return rounding;
    };

    //TODO: move
    Expression.toDecimalString = function(x, options) {
        var rounding = getRounding(options);
        if (rounding != null) {
            if (isConstant(x)) {
                return toDecimalStringInternal(x, rounding, decimalToMathML, complexToMathML);
            } else if (!Expression.has(x, NonSimplifiedExpression)) {
                var grouped = groupByTerm(x);
                if (grouped != undefined) {
                    return grouped.toMathML(options);
                }
            }
        }
        return undefined;
    };
    var getPrecedence = function(x, options) {
        var rounding = getRounding(options);
        if (rounding != null && isConstant(x.unwrap()) && Expression.has(x.unwrap(), Expression.Complex)) {
            if (!x.unwrap().equals(Expression.I)) {
                return new Expression.Addition(Expression.ONE, Expression.ONE).getPrecedence();
            }
        }
        return x.getPrecedence();
    };
    Expression.idCounter = 0;
    Expression.id = function() {
        return (Expression.idCounter += 1).toString();
    };

    //TODO: ?
    Expression.escapeHTML = function(s) {
        return s.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    };
    Expression.Matrix.prototype.toMathML = function(options) {
        var x = this.matrix;
        options = Expression.setTopLevel(true, options);
        var useMatrixContainer = options.useMatrixContainer == undefined ? true : options.useMatrixContainer;
        //TODO: fix!
        var braces = options.useBraces == undefined ? undefined : options.useBraces;
        var columnlines = options.columnlines == undefined ? 0 : options.columnlines;
        var variableNames = options.variableNames == undefined ? undefined : options.variableNames;
        var verticalStrike = options.verticalStrike == undefined ? -1 : options.verticalStrike;
        var horizontalStrike = options.horizontalStrike == undefined ? -1 : options.horizontalStrike;
        var cellIdGenerator = options.cellIdGenerator == undefined ? undefined : options.cellIdGenerator;
        var pivotCell = options.pivotCell == undefined ? undefined : options.pivotCell;
        var isLUDecomposition2 = options.isLUDecomposition2 == undefined ? undefined : options.isLUDecomposition2;
        var highlightRow = options.highlightRow == undefined ? -1 : options.highlightRow;
        var highlightCol = options.highlightCol == undefined ? -1 : options.highlightCol;
        options = Object.assign({}, options, {
            useBraces: undefined,
            columnlines: undefined,
            variableNames: undefined,
            verticalStrike: undefined,
            horizontalStrike: undefined,
            cellIdGenerator: undefined,
            pivotCell: undefined,
            isLUDecomposition2: undefined,
            highlightRow: undefined,
            highlightCol: undefined
        });
        var result = "";
        var rows = x.rows();
        var cols = x.cols();
        var i = -1;

        //TODO: remove `Expression.id()`
        var containerId = options.idPrefix + "-" + Expression.id();
        if (useMatrixContainer) {
            result += "<munder accentunder=\"true\">";
            // <menclose href="#"> will not be supported by MathML Core, so using <mrow>
            result += '<mrow id="' + containerId + '" data-matrix="' + Expression.escapeHTML(x.toString()) + '" draggable="true" tabindex="0" contextmenu="matrix-menu">';
        }
        result += braces == undefined ? '<mrow><mo>(</mo>' : '<mrow>' + (braces[0] === ' ' ? '' : '<mo>' + braces[0] + '</mo>');
        var columnlinesAttribute = "";
        if (columnlines !== 0 && cols - 1 > 0) {
            var k = -1;
            while (++k < cols - 1) {
                columnlinesAttribute += cols - 1 + columnlines === k ? "solid " : "none ";
            }
            // whitespace
            columnlinesAttribute = columnlinesAttribute.slice(0, -1);
        }
        //! 2017-07-06 rowspacing="0ex" was added to make it look better with Native MathML (when it is supported) and to have the same style as in mathml.css
        //  rowspacing="0ex" is also needed when verticalStrike !== -1
        var useColumnspacing = verticalStrike !== -1 || horizontalStrike !== -1 || pivotCell != undefined || cellIdGenerator != undefined;
        result += "<mtable" + " rowspacing=\"0ex\"" + (useColumnspacing ? " columnspacing=\"0em\"" : "") + (variableNames != undefined ? " columnalign=\"right\"" : "") + (columnlinesAttribute !== "" ? " columnlines=\"" + columnlinesAttribute + "\"" : "") + ">";
        while (++i < rows) {
            var j = -1;
            if (variableNames != undefined) {
                // TODO: fix?
                //TODO: use code from polynomialToExpression3 (shared)
                var row = "";
                var wasNotZero = false;
                while (++j < cols - 1) {
                    // TODO: fix `new Expression.Symbol()`
                    row += "<mtd>";
                    row += printPartOfAddition(j === cols - 2, !wasNotZero, x.e(i, j), new Expression.Symbol(variableNames[j]), options);
                    row += "</mtd>";
                    wasNotZero = wasNotZero || !x.e(i, j).equals(Expression.ZERO);
                }
                row += "<mtd><mo>=</mo></mtd><mtd>" + x.e(i, cols - 1).toMathML(options) + "</mtd>";
                if (wasNotZero || !x.e(i, cols - 1).equals(Expression.ZERO)) {
                    result += "<mtr>";
                    result += row;
                    result += "</mtr>";
                }
            } else {
                result += "<mtr>";
                while (++j < cols) {
                    result += "<mtd" + (cellIdGenerator != undefined ? " id=\"" + cellIdGenerator(i, j) + "\"" : "") + ">";
                    if (pivotCell != undefined && i === pivotCell.i && j === pivotCell.j) {
                        result += "<mrow style=\"font-weight: bolder\">";
                        result += "<menclose notation=\"circle\">";
                    }
                    if (horizontalStrike === i) {
                        result += "<menclose notation=\"horizontalstrike\">";
                    }
                    if (verticalStrike === j) {
                        result += "<menclose notation=\"verticalstrike\">";
                    }
                    // <mpadded> is an extra element, it is too many elements if to use it, which can cause performance problems
                    if (useColumnspacing) {
                        result += "<mpadded width=\"+0.8em\" lspace=\"+0.4em\">";
                    }
                    var highlight = j < i && isLUDecomposition2 || highlightRow === i && (columnlines === 0 || j <= cols - 1 + columnlines) || highlightCol === j;
                    if (highlight) {
                        result += "<mrow mathbackground=\"#80FF80\" mathcolor=\"#3C78C2\">";
                    }
                    result += x.e(i, j).toMathML(options);
                    if (highlight) {
                        result += "</mrow>";
                    }
                    if (useColumnspacing) {
                        result += "</mpadded>";
                    }
                    if (verticalStrike === j) {
                        result += "</menclose>";
                    }
                    if (horizontalStrike === i) {
                        result += "</menclose>";
                    }
                    if (pivotCell != undefined && i === pivotCell.i && j === pivotCell.j) {
                        result += "</menclose>";
                        result += "</mrow>";
                    }
                    result += "</mtd>";
                }
                result += "</mtr>";
            }
        }
        result += "</mtable>";
        result += braces == undefined ? '<mo>)</mo></mrow>' : (braces[1] === ' ' ? '' : '<mo>' + braces[1] + '</mo>') + '</mrow>';
        if (useMatrixContainer) {
            result += '</mrow>';
            result += "<mtext>";
            result += '<button type="button" class="matrix-menu-show" data-for-matrix="' + containerId + '" aria-haspopup="true" title="' + i18n.matrixMenu.title + '"></button>';
            result += "</mtext>";
            result += "</munder>";
        }
        return result;
    };
    Expression.Determinant.prototype.toMathML = function(options) {
        var x = this;
        if (x.a instanceof Expression.Matrix || x.a instanceof NonSimplifiedExpression && x.a.e instanceof Expression.Matrix) {
            options = Object.assign({}, options, {
                useBraces: ["|", "|"]
            });
            //TODO: fix
            return x.a.toMathML(options);
        }
        //return "<mrow><mo>|</mo>" + x.a.toMathML(options) + "<mo>|</mo></mrow>";
        return Expression.Function.prototype.toMathML.call(this, options); // det(X)
    };

    Expression.Transpose.prototype.toMathML = function(options) {
        var x = this;
        //TODO: ^T ?
        // https://www.w3.org/TR/MathML3/chapter4.html#contm.transpose
        var f = this.getPrecedence() >= x.a.getPrecedence();
        return "<msup>" + (f ? "<mrow><mo>(</mo>" : "") + x.a.toMathML(options) + (f ? "<mo>)</mo></mrow>" : "") + "<mi>T</mi>" + "</msup>";
    };
    Expression.ComplexConjugate.prototype.toMathML = function(options) {
        var x = this;
        // https://w3c.github.io/mathml/chapter4-d.html#contm.conjugate
        return "<mover accent=\"true\">" + x.a.toMathML(options) + "<mo>¯</mo>" + "</mover>";
    };
    Expression.Pseudoinverse.prototype.toMathML = function(options) {
        var x = this;
        var f = this.getPrecedence() >= x.a.getPrecedence();
        return "<msup>" + (f ? "<mrow><mo>(</mo>" : "") + x.a.toMathML(options) + (f ? "<mo>)</mo></mrow>" : "") + "<mi><span title=\"pseudoinverse\">+</span></mi>" + "</msup>";
    };
    Expression.SquareRoot.prototype.toMathML = function(options) {
        var d = Expression.toDecimalString(this, options);
        if (d != undefined) {
            return d;
        }
        return "<msqrt>" + this.a.toMathML(Expression.setTopLevel(true, options)) + "</msqrt>";
    };
    Expression.NthRoot.prototype.toMathML = function(options) {
        var d = Expression.toDecimalString(this, options);
        if (d != undefined) {
            return d;
        }
        console.assert(typeof this.n === "number" && Math.floor(this.n) === this.n && this.n >= 3);
        return "<mroot>" + this.a.toMathML(Expression.setTopLevel(true, options)) + "<mn>" + numberFormat.format(this.n.toString()) + "</mn>" + "</mroot>";
    };
    Expression.denotations = {};
    Expression.Function.prototype.toMathML = function(options) {
        var d = Expression.toDecimalString(this, options);
        if (d != undefined) {
            return d;
        }
        var x = this;
        var fa = !(x.a instanceof Expression.Matrix) && !(x.a instanceof NonSimplifiedExpression && x.a.e instanceof Expression.Matrix); //?
        //TODO: fix
        return "<mrow>" + "<mi>" + (Expression.denotations[x.name] || x.name) + "</mi>" + "<mo>&af;</mo>" + (fa ? "<mrow><mo>(</mo>" : "") + x.a.toMathML(Expression.setTopLevel(true, options)) + (fa ? "<mo>)</mo></mrow>" : "") + "</mrow>";
    };
    Expression.Division.prototype.toMathML = function(options) {
        if (options != null && options.nofractions) {
            return Expression.BinaryOperation.prototype.toMathML.call(this, options);
        }
        var d = Expression.toDecimalString(this, options);
        if (d != undefined) {
            return d;
        }
        var x = this;
        var denominator = x.getDenominator();
        var numerator = x.getNumerator();
        //???
        //if (numerator.isNegative()) {
        //  return "<mrow><mo>&minus;</mo>" + x.negateCarefully().toMathML(options) + "</mrow>";
        //}
        return "<mfrac>" + numerator.toMathML(Expression.setTopLevel(true, options)) + denominator.toMathML(Expression.setTopLevel(true, options)) + "</mfrac>";
    };
    Expression.numberFormat = {
        format: function(number) {
            return number.toString();
        }
    };
    var decimalNumberRegExp = new RegExp('\\p{Decimal_Number}', 'u');
    var replaceSimpleDigit = function(codePoint) {
        var i = 0;
        while (decimalNumberRegExp.test(String.fromCodePoint(codePoint - i))) {
            i += 1;
        }
        return i === 0 ? -1 : (i - 1) % 10;
    };
    var cachedFormatData = {
        format: null,
        decimalSeparator: '.',
        decimalZeroOffset: 0
    };

    // only for non-negative integers without groupping, but large
    var numberFormat = {
        format: function(string) {
            var getDecimalSeparator = function() {
                var s = Expression.numberFormat.format(1.5).trim();
                var tmp = /[٫,\.]/.exec(s);
                if (tmp == null) {
                    console.error(s);
                    return '.';
                }
                return tmp[0];
            };
            var getDecimalZeroOffset = function() {
                var codePoint = Expression.numberFormat.format(0).trim().codePointAt(0);
                var isDecimalZero = replaceSimpleDigit(codePoint) === 0;
                if (!isDecimalZero) {
                    console.error(codePoint);
                    return 0;
                }
                return codePoint - "0".charCodeAt(0);
            };
            if (cachedFormatData.format !== Expression.numberFormat) {
                cachedFormatData = {
                    format: Expression.numberFormat,
                    decimalSeparator: getDecimalSeparator(),
                    decimalZeroOffset: getDecimalZeroOffset()
                };
            }
            // This method is needed as native Intl.NumberFormat cannot format strings.
            // https://github.com/tc39/ecma402/issues/334
            var decimalSeparator = string.indexOf('.');
            if (decimalSeparator !== -1) {
                return numberFormat.format(string.slice(0, decimalSeparator)) + cachedFormatData.decimalSeparator + numberFormat.format(string.slice(decimalSeparator + '.'.length));
            }
            var decimalZeroOffset = cachedFormatData.decimalZeroOffset;
            if (decimalZeroOffset === 0) {
                return string;
            }
            var result = "";
            for (var i = 0; i < string.length; i += 1) {
                result += String.fromCodePoint(decimalZeroOffset + string.charCodeAt(i));
            }
            return result;
        }
    };
    Expression.Integer.prototype.toMathML = function(options) {
        //var d = Expression.toDecimalString(this, options);
        //if (d != undefined) {
        //  return d;
        //}
        var x = this;
        var sign = x.compareTo(Expression.ZERO) < 0 ? '-' : '';
        var abs = x.compareTo(Expression.ZERO) < 0 ? x.negate() : x;
        var s = abs.value.toString();
        var tmp = numberFormat.format(s);
        return sign === "-" ? "<mrow>" + "<mo>&minus;</mo>" + "<mn>" + tmp + "</mn>" + "</mrow>" : "<mn>" + tmp + "</mn>";
    };
    Expression.BinaryOperation.prototype.toMathML = function(options) {
        options = options == null ? {} : options;
        if (options != null && options.rounding != null && this.unwrap() instanceof Expression.Exponentiation && this.unwrap().a.unwrap() instanceof Expression.Symbol && this.unwrap().a.unwrap() !== Expression.E && this.unwrap().a.unwrap() !== Expression.PI && !(this.unwrap().a.unwrap() instanceof Expression.PolynomialRootSymbol) && !(this.unwrap().a.unwrap() instanceof Expression.ExpressionPolynomialRoot) && (this.unwrap().b.unwrap() instanceof Expression.Integer || this.unwrap().b.unwrap() instanceof Expression.Negation && this.unwrap().b.unwrap().b.unwrap() instanceof Expression.Integer)) {
            options = Object.assign({}, options, {
                rounding: null
            });
        }
        var d = Expression.toDecimalString(this, options);
        if (d != undefined) {
            return d;
        }

        //!2019-05-16
        if (this instanceof Expression.Addition && options.printId == undefined) {
            var summands = function(e) {
                //if (true) { return e.summands(); }
                var result = [];
                while (e.unwrap() instanceof Expression.Addition) {
                    result.push(e.unwrap().b);
                    e = e.unwrap().a;
                }
                result.push(e);
                return result;
            };
            var s = [];
            var b = null;
            for (var iteratorx = summands(this)[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
                if (b != null) {
                    var n = false;
                    if (b.isNegative()) {
                        n = true;
                        b = b.negateCarefully();
                    }
                    var fence = this.getPrecedence() >= getPrecedence(b, options);
                    fence = fence || b.isUnaryPlusMinus();
                    s.push((fence ? '<mrow><mo>(</mo>' : '') + b.toMathML(Expression.setTopLevel(fence, options)) + (fence ? '<mo>)</mo></mrow>' : ''));
                    s.push(n ? '<mo>&minus;</mo>' : '<mo>+</mo>');
                }
                b = x;
            }
            s = s.reverse().join('');
            var a = b;
            var fence = a.getPrecedence() + (a.isRightToLeftAssociative() ? -1 : 0) < this.getPrecedence();
            if (options != undefined && options.isTopLevel != undefined && options.isTopLevel === false) {
                fence = fence || a.isUnaryPlusMinus();
            }
            s = (fence ? "<mrow><mo>(</mo>" : "") + a.toMathML(Expression.setTopLevel(fence || options == undefined || options.isTopLevel, options)) + (fence ? "<mo>)</mo></mrow>" : "") + s;
            return '<mrow>' + s + '</mrow>';
        }

        //!
        var a = this.a;
        var b = this.b;
        var isSubtraction = false;
        // TODO: check
        if (this instanceof Expression.Addition && b.isNegative()) {
            isSubtraction = true;
            b = b.negateCarefully(); //?
        }

        var fa = a.getPrecedence() + (a.isRightToLeftAssociative() ? -1 : 0) < this.getPrecedence();
        var fb = this.getPrecedence() + (this.isRightToLeftAssociative() ? -1 : 0) >= b.getPrecedence();
        if (options != undefined && options.isTopLevel != undefined && options.isTopLevel === false) {
            fa = fa || a.isUnaryPlusMinus();
        }
        fb = fb || b.isUnaryPlusMinus();
        fb = fb || this.unwrap() instanceof Expression.Exponentiation && b.unwrap() instanceof Expression.Exponentiation; // 2^3^4
        fa = fa || this.unwrap() instanceof Expression.Exponentiation && a.unwrap() instanceof Expression.Function; // cos(x)^(2+3)
        fa = fa || options.rounding != null && isConstant(a.unwrap()) && Expression.has(a.unwrap(), Expression.Complex); // sqrt(2)*(1+i)*x
        var s = isSubtraction ? "-" : this.getS();
        if (this instanceof Expression.Exponentiation) {
            if (a.unwrap() === Expression.E && b.unwrap() instanceof Expression.Matrix) {
                return '<mrow><mi>exp</mi><mo>&af;</mo>' + b.toMathML(options) + '</mrow>';
            }
            var boptions = options;
            if (!(a.unwrap() instanceof Expression.Matrix)) {
                boptions = Object.assign({}, options || {}, {
                    nofractions: true
                });
            }
            return "<msup>" + (fa ? "<mrow><mo>(</mo>" : "") + a.toMathML(Expression.setTopLevel(fa || options == undefined || options.isTopLevel, options)) + (fa ? "<mo>)</mo></mrow>" : "") + (fb ? "<mrow><mo>(</mo>" : "") + b.toMathML(Expression.setTopLevel(fb, boptions)) + (fb ? "<mo>)</mo></mrow>" : "") + "</msup>";
        }
        if (this.isNegation()) {
            // assert(fa === false);
            return "<mrow><mo>&minus;</mo>" + (fb ? "<mrow><mo>(</mo>" : "") + b.toMathML(Expression.setTopLevel(fb, options)) + (fb ? "<mo>)</mo></mrow>" : "") + "</mrow>";
        }
        //TODO: fix spaces (matrix parsing)
        // &times; looks better than &it; when multiplying matrices (?)
        // &sdot; looks better than &times;
        var isScalarOrMatrixSymbol = function(e) {
            return Expression.isScalar(e.unwrap()) || e.unwrap() instanceof Expression.MatrixSymbol;
        };
        var base = function(e) {
            return e instanceof Expression.Exponentiation && (e.b.unwrap() instanceof Expression.Integer || e.b.unwrap() instanceof Expression.Symbol && e.b.unwrap().symbol === "T") ? e.a.unwrap() : e;
        };
        var canUseInvisibleTimes = function(e) {
            return !fa && !fb && (e.a.unwrap() instanceof Expression.Integer || base(e.a.unwrap()) instanceof Expression.Symbol || e.a.unwrap() instanceof Expression.Multiplication && base(e.a.unwrap().b.unwrap()) instanceof Expression.Symbol) && (base(e.b.unwrap()) instanceof Expression.Symbol || options.rounding == null && e.b.unwrap() instanceof Expression.SquareRoot);
            //return options.rounding == null && !fa && !fb && isScalarOrMatrixSymbol(e.a) && isScalarOrMatrixSymbol(e.b) && !(e.a instanceof Expression.Integer && (e.b instanceof Expression.Integer || e.b instanceof Expression.Exponentiation && e.b.a instanceof Expression.Integer))
        };
        //!2020-08-02
        if (this instanceof Expression.Multiplication && options.printId == undefined) {
            var f = true;
            for (var x = this; x != null; x = x instanceof Expression.Multiplication ? x.a.unwrap() : null) {
                var factor = x instanceof Expression.Multiplication ? x.b.unwrap() : x;
                if (!(base(factor).unwrap() instanceof Expression.Symbol && Expression.isScalar(factor))) {
                    f = false;
                }
                if (factor instanceof Expression.ExpressionWithPolynomialRoot) {
                    f = false; // like a+b*i
                }

                if (factor instanceof Expression.ExpressionPolynomialRoot) {
                    f = false;
                }
            }
            if (f) {
                var s = [];
                for (var x = this; x != null; x = x instanceof Expression.Multiplication ? x.a.unwrap() : null) {
                    var factor = x instanceof Expression.Multiplication ? x.b.unwrap() : x;
                    //TODO: fence(?)
                    s.push(factor.toMathML(Expression.setTopLevel(fence, options)));
                }
                s = s.reverse().join('<mo>&it;</mo>');
                return '<mrow>' + s + '</mrow>';
            }
        }
        return "<mrow>" + (fa ? "<mrow><mo>(</mo>" : "") + a.toMathML(Expression.setTopLevel(fa || options == undefined || options.isTopLevel, options)) + (fa ? "<mo>)</mo></mrow>" : "") + (s === '*' ? canUseInvisibleTimes(this) ? '<mo>&it;</mo>' : '<mo>&sdot;</mo>' : s === '-' ? '<mo>&minus;</mo>' : s === '/' ? '<mo>&#x2215;</mo>' : this instanceof Expression.Comma ? '<mo lspace="0em" rspace="0.55em">' + ',' + '</mo>' : '<mo>' + s + '</mo>') + (fb ? "<mrow><mo>(</mo>" : "") + b.toMathML(Expression.setTopLevel(fb, options)) + (fb ? "<mo>)</mo></mrow>" : "") + "</mrow>";
    };
    Expression.Symbol.prototype.toMathML = function(options) {
        var x = this;
        var s = x.symbol;
        var i = s.indexOf("_");
        if (i !== -1) {
            var indexes = s.slice(i + 1).replace(/^\(|\)$/g, "").split(",");
            var indexesMathML = "";
            for (var j = 0; j < indexes.length; j += 1) {
                indexesMathML += j !== 0 ? "<mo>,</mo>" : "";
                indexesMathML += /^\d+$/.exec(indexes[j]) != undefined ? Expression.Integer.fromString(indexes[j]).toMathML() : "<mi>" + indexes[j] + "</mi>";
            }
            if (indexes.length > 1) {
                indexesMathML = "<mrow>" + indexesMathML + "</mrow>";
            }
            var isVector = this instanceof Expression.MatrixSymbol && /^[a-z]$/.test(s.slice(0, i));
            return "<msub>" + "<mi" + (isVector ? " mathvariant=\"bold-italic\"" : "") + ">" + s.slice(0, i) + "</mi>" + indexesMathML + "</msub>";
        }
        var isVector = this instanceof Expression.MatrixSymbol && /^[a-z]$/.test(s);
        return "<mi" + (isVector ? " mathvariant=\"bold-italic\"" : "") + ">" + (this instanceof Expression.IdentityMatrix ? '<span class="dotted-underline" title="' + i18n.identityMatrix + '" aria-label="' + i18n.identityMatrix + '">' + s + '</span>' : s) + "</mi>";
    };
    Expression.Negation.prototype.toMathML = function(options) {
        var b = this.b;
        var fb = this.getPrecedence() + (this.isRightToLeftAssociative() ? -1 : 0) >= b.getPrecedence();
        fb = fb || b.isUnaryPlusMinus();
        // assert(fa === false);
        return "<mrow><mo>&minus;</mo>" + (fb ? "<mrow><mo>(</mo>" : "") + b.toMathML(Expression.setTopLevel(fb, options)) + (fb ? "<mo>)</mo></mrow>" : "") + "</mrow>";
    };
    Expression.Factorial.prototype.toMathML = function(options) {
        var n = this.n.unwrap();
        var fn = !(n instanceof Expression.Integer && n.compareTo(Expression.ZERO) > 0);
        return "<mrow>" + (fn ? "<mrow><mo>(</mo>" : "") + n.toMathML(Expression.setTopLevel(fn, options)) + (fn ? "<mo>)</mo></mrow>" : "") + "<mo>!</mo></mrow>";
    };
    Condition.prototype.toMathML = function(options) {
        if (this === Condition.TRUE || this === Condition.FALSE) {
            // 1) no need; 2) no way to distinguish TRUE and FALSE
            throw new TypeError();
        }
        if (this.array.length === 0) {
            // assertion
            throw new TypeError();
        }
        var s = '';
        for (var i = 0; i < this.array.length; i += 1) {
            var c = this.array[i];
            s += i !== 0 ? '<mo lspace="0em" rspace="0.55em">,</mo>' : '';
            s += '<mrow>';
            var operator = '<mo>' + (c.operator === Condition.NEZ ? '&ne;' : c.operator === Condition.EQZ ? '=' : c.operator === Condition.GTZ ? '&gt;' : '???') + '</mo>';
            if (c.expression instanceof Expression.Addition && c.expression.a instanceof Expression.Symbol && c.expression.b instanceof Expression.Integer) {
                //TODO: ?
                var left = c.expression.a;
                var right = c.expression.b.negate();
                s += left.toMathML(options) + operator + right.toMathML(options);
            } else {
                s += c.expression.toMathML(options) + operator + Expression.ZERO.toMathML();
            }
            s += '</mrow>';
        }
        return this.array.length === 1 ? s : '<mrow>' + s + '</mrow>';
    };
    Expression.Complex.prototype.toMathML = function(options) {
        return this.toStringInternal(options, "<mo>&it;</mo>", "<mi>&ii;</mi>", "<mo>&minus;</mo>", "<mo>+</mo>", "<mrow>", "</mrow>", function(x, options) {
            return x.toMathML(options);
        });
    };
    Expression.GF2.prototype.toMathML = function(options) {
        //TODO: fix
        return this.a.toMathML(options);
    };
    Expression.GF2Value.prototype.toMathML = function(options) {
        return "<mrow>" + "<mn>" + this.value.toString() + "</mn>" + "</mrow>";
    };
    Expression.Degrees.prototype.toMathML = function(options) {
        return "<mrow>" + this.value.toMathML(options) + "<mo>&it;</mo><mi>&deg;</mi></mrow>";
    };
    Expression.Radians.prototype.toMathML = function(options) {
        return "<mrow>" + this.value.toMathML(options) + "<mo>&it;</mo><mi>rad</mi></mrow>";
    };
    NonSimplifiedExpression.prototype.toMathML = function(options) {
        //?
        //options = options.rounding != null ? Object.assign({}, options, {rounding: null}) : options;
        if (options != null && options.printId != undefined) {
            return "<mrow id=\"" + this.getId() + "\">" + this.e.toMathML(options) + "</mrow>";
        }
        return this.e.toMathML(options);
    };
    Expression.prototype.toMathML = function(options) {
        throw new TypeError();
    };
    Expression.DecimalFraction.prototype.toMathML = function(options) {
        return decimalToMathML(this.toString());
    };
})();
var maybeJSBI = {
    toNumber: function toNumber(a) {
        return typeof a === "object" ? JSBI.toNumber(a) : Number(a);
    },
    add: function add(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.add(a, b) : a + b;
    },
    subtract: function subtract(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.subtract(a, b) : a - b;
    },
    multiply: function multiply(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.multiply(a, b) : a * b;
    },
    divide: function divide(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.divide(a, b) : a / b;
    },
    remainder: function remainder(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.remainder(a, b) : a % b;
    },
    exponentiate: function exponentiate(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.exponentiate(a, b) : typeof a === "bigint" && typeof b === "bigint" ? new Function("a", "b", "return a**b")(a, b) : Math.pow(a, b);
    },
    leftShift: function leftShift(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.leftShift(a, b) : a << b;
    },
    signedRightShift: function signedRightShift(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.signedRightShift(a, b) : a >> b;
    },
    bitwiseAnd: function bitwiseAnd(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.bitwiseAnd(a, b) : a & b;
    },
    bitwiseOr: function bitwiseOr(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.bitwiseOr(a, b) : a | b;
    },
    bitwiseXor: function bitwiseXor(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.bitwiseXor(a, b) : a ^ b;
    },
    lessThan: function lessThan(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.lessThan(a, b) : a < b;
    },
    greaterThan: function greaterThan(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.greaterThan(a, b) : a > b;
    },
    lessThanOrEqual: function lessThanOrEqual(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.lessThanOrEqual(a, b) : a <= b;
    },
    greaterThanOrEqual: function greaterThanOrEqual(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.greaterThanOrEqual(a, b) : a >= b;
    },
    equal: function equal(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.equal(a, b) : a === b;
    },
    notEqual: function notEqual(a, b) {
        return typeof a === "object" && typeof b === "object" ? JSBI.notEqual(a, b) : a !== b;
    },
    unaryMinus: function unaryMinus(a) {
        return typeof a === "object" ? JSBI.unaryMinus(a) : -a;
    },
    bitwiseNot: function bitwiseNot(a) {
        return typeof a === "object" ? JSBI.bitwiseNot(a) : ~a;
    }
};

(function() {
    "use strict";

    // https://en.wikipedia.org/wiki/Quadratic_integer
    // https://en.wikipedia.org/wiki/Factorization#Unique_factorization_domains

    // It is possible to use the comparision operators if a is a safe integer or BigIntegerInternal or BigInt and n is a safe integer:
    // a < n
    // a <= n
    // a > n
    // a >= n
    // a == n
    // a != n

    /*
  
          if (qi instanceof QuadraticInteger && qi.a < 0 || qi.b < 0) {
            var c = pow(qi.conjugate(), n, new QuadraticInteger(1, 0, qi.D));
            return qi.multiply(c).toExpression()._nthRoot(n).divide(new QuadraticInteger(Math.abs(qi.a), Math.abs(qi.b), qi.D).toExpression());
          }
  
    */
    function abs(a) {
        return JSBI.lessThan(a, JSBI.BigInt(0)) ? maybeJSBI.unaryMinus(a) : a;
    }

    function ngcd(a, b) {
        return JSBI.BigInt(bigIntGCD(JSBI.BigInt(a), JSBI.BigInt(b)));
    }

    // (a + b*sqrt(D))/(overTwo ? 2 : 1)
    // a, b, D - integers,
    // D - squarefree integer
    function QuadraticInteger(a, b, D, overTwo) {
        overTwo = overTwo == undefined ? false : overTwo;
        a = typeof a === "number" ? JSBI.BigInt(a) : a;
        b = typeof b === "number" ? JSBI.BigInt(b) : b;
        D = maybeJSBI.toNumber(D);
        //TODO:
        if (typeof a === "number" && Math.abs(a) > Number.MAX_SAFE_INTEGER) {
            throw new RangeError();
        }
        if (typeof b === "number" && Math.abs(b) > Number.MAX_SAFE_INTEGER) {
            throw new RangeError();
        }
        if (overTwo && D % 4 === 0) {
            throw new RangeError();
        }
        if (overTwo && JSBI.equal(JSBI.remainder(a, JSBI.BigInt(2)), JSBI.BigInt(0)) && JSBI.equal(JSBI.remainder(b, JSBI.BigInt(2)), JSBI.BigInt(0))) {
            overTwo = false;
            a = JSBI.divide(a, JSBI.BigInt(2));
            b = JSBI.divide(b, JSBI.BigInt(2));
        }
        if (overTwo && (JSBI.equal(JSBI.remainder(a, JSBI.BigInt(2)), JSBI.BigInt(0)) || JSBI.equal(JSBI.remainder(b, JSBI.BigInt(2)), JSBI.BigInt(0)))) {
            throw new RangeError();
        }
        this.a = a;
        this.b = b;
        this.D = D;
        this.overTwo = overTwo;
    }
    QuadraticInteger.prototype.multiply = function(y) {
        var x = this;
        if (!maybeJSBI.equal(x.D, y.D)) {
            throw new TypeError();
        }
        var a = JSBI.add(maybeJSBI.multiply(x.a, y.a), JSBI.multiply(maybeJSBI.multiply(x.b, y.b), JSBI.BigInt(y.D)));
        var b = maybeJSBI.add(maybeJSBI.multiply(x.a, y.b), maybeJSBI.multiply(x.b, y.a));
        var d = (x.overTwo ? 1 : 0) + (y.overTwo ? 1 : 0);
        while (d > 0 && JSBI.equal(JSBI.remainder(a, JSBI.BigInt(2)), JSBI.BigInt(0)) && JSBI.equal(JSBI.remainder(b, JSBI.BigInt(2)), JSBI.BigInt(0))) {
            a = JSBI.divide(a, JSBI.BigInt(2));
            b = JSBI.divide(b, JSBI.BigInt(2));
            d -= 1;
        }
        return new QuadraticInteger(a, b, x.D, d === 1);
    };
    QuadraticInteger.prototype.conjugate = function(y) {
        return new QuadraticInteger(this.a, maybeJSBI.unaryMinus(this.b), this.D, this.overTwo);
    };
    QuadraticInteger.prototype.norm = function() {
        //var x = this.a * this.a;
        //var y = this.b * this.b;
        //return x % this.D + (((x - x % this.D) / this.D) - y) * this.D;
        var a = this.a;
        var b = this.b;
        var D = this.D;
        var aa = maybeJSBI.multiply(a, a);
        var bb = maybeJSBI.multiply(b, b);
        var norm = JSBI.subtract(aa, JSBI.multiply(bb, JSBI.BigInt(D)));
        if (this.overTwo) {
            if (!JSBI.equal(JSBI.remainder(norm, JSBI.BigInt(4)), JSBI.BigInt(0))) {
                throw new RangeError("assertion");
            }
            norm = JSBI.divide(norm, JSBI.BigInt(4));
        }
        if (typeof norm === "number" && Math.abs(norm) > Number.MAX_SAFE_INTEGER) {
            throw new TypeError();
        }
        if (typeof a === "number" && maybeJSBI.greaterThanOrEqual(norm, maybeJSBI.unaryMinus(Number.MAX_SAFE_INTEGER)) && norm <= +Number.MAX_SAFE_INTEGER) {
            norm = maybeJSBI.toNumber(norm);
        }
        return norm;
    };
    QuadraticInteger.prototype.truncatingDivideInteger = function(x) {
        return new QuadraticInteger(x.toBigInt(), Expression.ZERO.toBigInt(), this.D).truncatingDivide(this);
    };
    QuadraticInteger.prototype.truncatingDivide = function(y) {
        if (!(y instanceof QuadraticInteger)) {
            if (!y instanceof Expression.Integer) {
                throw new RangeError();
            }
            y = new QuadraticInteger(y.toBigInt(), Expression.ZERO.toBigInt(), this.D);
        }
        var x = this;
        if (!maybeJSBI.equal(x.D, y.D)) {
            throw new TypeError();
        }
        var n = x.multiply(y.conjugate());
        var d = y.norm();
        while (JSBI.equal(JSBI.remainder(d, JSBI.BigInt(2)), JSBI.BigInt(0)) && JSBI.equal(JSBI.remainder(n.a, JSBI.BigInt(2)), JSBI.BigInt(0)) && JSBI.equal(JSBI.remainder(n.b, JSBI.BigInt(2)), JSBI.BigInt(0))) {
            n = new QuadraticInteger(JSBI.divide(n.a, JSBI.BigInt(2)), JSBI.divide(n.b, JSBI.BigInt(2)), n.D, n.overTwo);
            d = JSBI.divide(d, JSBI.BigInt(2));
        }
        if (!n.overTwo && n.D % 4 === 1 && JSBI.notEqual(JSBI.remainder(n.a, JSBI.BigInt(2)), JSBI.BigInt(0)) && JSBI.notEqual(JSBI.remainder(n.b, JSBI.BigInt(2)), JSBI.BigInt(0)) && JSBI.equal(JSBI.remainder(d, JSBI.BigInt(2)), JSBI.BigInt(0))) {
            n = new QuadraticInteger(n.a, n.b, n.D, true);
            d = JSBI.divide(d, JSBI.BigInt(2));
        }
        return JSBI.equal(maybeJSBI.remainder(n.a, d), JSBI.BigInt(0)) && JSBI.equal(maybeJSBI.remainder(n.b, d), JSBI.BigInt(0)) ? new QuadraticInteger(maybeJSBI.divide(n.a, d), maybeJSBI.divide(n.b, d), x.D, n.overTwo) : null;
    };
    QuadraticInteger.prototype.negate = function() {
        return new QuadraticInteger(maybeJSBI.unaryMinus(this.a), maybeJSBI.unaryMinus(this.b), this.D, this.overTwo);
    };

    /*
    function primeFactor(n) {
      var i = n - n;
      ++i;
      ++i;
      if (n % i == 0) {
        return i;
      }
      ++i;
      while (i * i <= n) {
        if (n % i == 0) {
          return i;
        }
        ++i;
        ++i;
      }
      return n;
    }
    */

    function factors(n) {
        if (JSBI.lessThan(n, JSBI.BigInt(1))) {
            throw new TypeError();
        }
        var p = JSBI.greaterThan(n, JSBI.BigInt(1)) ? JSBI.BigInt(primeFactor(n)) : JSBI.BigInt(1);
        var t = JSBI.BigInt(1);
        var f = JSBI.BigInt(1);
        var fs = null;
        var i = JSBI.BigInt(1);
        var result = {
            done: false,
            value: null,
            next: function() {
                if (JSBI.equal(p, JSBI.BigInt(1))) {
                    this.value = null;
                    this.done = true;
                    return this;
                }
                if (fs == null) {
                    if (JSBI.equal(JSBI.remainder(n, p), JSBI.BigInt(0))) {
                        t = JSBI.multiply(t, p);
                        n = JSBI.divide(n, p);
                        this.value = t;
                        this.done = false;
                        return this;
                    }
                    fs = factors(n);
                    i = t;
                }
                if (JSBI.equal(i, t)) {
                    i = JSBI.BigInt(1);
                    f = fs.next().value;
                } else {
                    i = JSBI.multiply(i, p);
                }
                this.value = f == null ? null : JSBI.multiply(f, i);
                this.done = f == null;
                return this;
            }
        };
        result[Symbol.iterator] = function() {
            return this;
        };
        return result;
    }
    QuadraticInteger._factors = function(n) {
        return factors(JSBI.BigInt(n));
    };
    QuadraticInteger._complexIntegerPrimeFactor = function(r, i) {
        r = JSBI.BigInt(r);
        i = JSBI.BigInt(i);

        function canBePerfectSquare(n) {
            // https://www.johndcook.com/blog/2008/11/17/fast-way-to-test-whether-a-number-is-a-square/#comment-15700
            //var bitset = 0;
            //for (var i = 0; i < 32; i += 1) {
            //  bitset |= 1 << ((i * i) % 32);
            //}
            var bitset = 33751571;
            var result = (bitset >> JSBI.toNumber(JSBI.remainder(n, JSBI.BigInt(32)))) % 2;
            return result === 1;
        }

        function norm(a, b) {
            return maybeJSBI.add(maybeJSBI.multiply(a, a), maybeJSBI.multiply(b, b));
        }

        function hasDivisor(r, i, a, b) {
            var d = maybeJSBI.add(maybeJSBI.multiply(a, a), maybeJSBI.multiply(b, b));
            var x = maybeJSBI.add(maybeJSBI.multiply(r, a), maybeJSBI.multiply(i, b));
            var y = maybeJSBI.subtract(maybeJSBI.multiply(i, a), maybeJSBI.multiply(r, b));
            return JSBI.equal(maybeJSBI.remainder(x, d), JSBI.BigInt(0)) && JSBI.equal(maybeJSBI.remainder(y, d), JSBI.BigInt(0));
        }
        var n = norm(r, i);
        //if (n > (Number.MAX_SAFE_INTEGER + 1) / 2) {
        //TODO: should not throw (see a call from Polynomial#getroots)
        //throw new RangeError("NotSupportedError");
        //}

        for (var iteratorp = QuadraticInteger._factors(n)[globalThis.Symbol.iterator](), p = iteratorp.next().value; p != null; p = iteratorp.next().value) {
            var b = JSBI.BigInt(0);
            var c = p;
            while (JSBI.greaterThan(c, JSBI.BigInt(0))) {
                if (canBePerfectSquare(c)) {
                    var a = JSBI.BigInt(nthRoot(JSBI.BigInt(c), 2));
                    if (maybeJSBI.equal(maybeJSBI.multiply(a, a), c)) {
                        if (JSBI.greaterThan(norm(a, b), JSBI.BigInt(1)) && hasDivisor(r, i, a, b)) {
                            return JSBI.equal(b, JSBI.BigInt(0)) ? new Expression.Complex(Expression.ZERO, Expression.Integer.fromBigInt(a)) : new Expression.Complex(Expression.Integer.fromBigInt(a), Expression.Integer.fromBigInt(b));
                        }
                    }
                }
                b = JSBI.add(b, JSBI.BigInt(1));
                c = maybeJSBI.subtract(p, maybeJSBI.multiply(b, b));
            }
        }
        if (JSBI.greaterThan(n, JSBI.BigInt(1))) {
            throw new TypeError();
        }
        return new Expression.Complex(Expression.Integer.fromBigInt(r), Expression.Integer.fromBigInt(i));
    };

    //  Compute (k n), where k is numerator
    function jacobiSymbol(k, n) {
        if (k < 0 || n % 2 == 0) {
            throw new Error("Invalid value. k = " + k + ", n = " + n);
        }
        k %= n;
        var jacobi = 1;
        while (k > 0) {
            while (k % 2 == 0) {
                k /= 2;
                var r = n % 8;
                if (r == 3 || r == 5) {
                    jacobi = -jacobi;
                }
            }
            var temp = n;
            n = k;
            k = temp;
            if (k % 4 == 3 && n % 4 == 3) {
                jacobi = -jacobi;
            }
            k %= n;
        }
        if (n == 1) {
            return jacobi;
        }
        return 0;
    }

    // D**((p - 1) / 2) % p
    function LegendreSymbol(a, p) {
        // https://en.wikipedia.org/wiki/Legendre_symbol#:~:text=Special%20formulas
        // https://rosettacode.org/wiki/Jacobi_symbol#Java
        return jacobiSymbol(a, p);
    }

    function quadraticIntegers(norm, D, b) {
        var overTwo = maybeJSBI.toNumber(D) % 4 === 1;
        while (true) {
            var bbD = maybeJSBI.multiply(maybeJSBI.multiply(b, b), D);
            var guess1 = JSBI.add(JSBI.multiply(maybeJSBI.unaryMinus(norm), overTwo ? JSBI.BigInt(4) : JSBI.BigInt(1)), bbD);
            var guess2 = JSBI.add(JSBI.multiply(norm, overTwo ? JSBI.BigInt(4) : JSBI.BigInt(1)), bbD);
            //if (typeof norm === "number") {//TODO:
            if (maybeJSBI.toNumber(guess2) > Number.MAX_SAFE_INTEGER || maybeJSBI.toNumber(guess1) > Number.MAX_SAFE_INTEGER) {
                throw new RangeError(norm);
            }
            //}
            var guess = guess1;
            if (JSBI.greaterThanOrEqual(guess, JSBI.BigInt(0))) {
                var a = JSBI.BigInt(nthRoot(JSBI.BigInt(guess), 2));
                if (JSBI.equal(guess, JSBI.exponentiate(a, JSBI.BigInt(2)))) {
                    // && ngcd(a, b) === 1
                    return new QuadraticInteger(a, b, D, overTwo);
                }
            }
            var guess = guess2;
            if (JSBI.greaterThanOrEqual(guess, JSBI.BigInt(0))) {
                var a = JSBI.BigInt(nthRoot(JSBI.BigInt(guess), 2));
                if (JSBI.equal(guess, JSBI.exponentiate(a, JSBI.BigInt(2)))) {
                    // && ngcd(a, b) === 1
                    return new QuadraticInteger(a, b, D, overTwo);
                }
            }
            b = JSBI.add(b, JSBI.BigInt(1));
        }
    }
    QuadraticInteger._fundamentalUnit = function(D) {
        return quadraticIntegers(JSBI.BigInt(1), D, JSBI.BigInt(1));
    };
    QuadraticInteger.prototype.primeFactor = function() {
        var a = this.a;
        var b = this.b;
        var D = JSBI.BigInt(this.D);
        var g = ngcd(a, D);

        // from AlmostQuadraticInteger:
        //if (this.k.toBigInt() % this.qi.D == 0) {
        //TODO: ?
        //return this._toQuadraticInteger().primeFactor();
        //}
        var k = ngcd(a, b);
        if (JSBI.notEqual(k, JSBI.BigInt(1)) && JSBI.notEqual(k, JSBI.unaryMinus(JSBI.BigInt(1)))) {
            return JSBI.notEqual(k, D) ? Expression.Integer.fromBigInt(k).primeFactor() : new QuadraticInteger(JSBI.BigInt(0), JSBI.BigInt(1), D);
        }
        //

        if (JSBI.equal(g, D)) {
            //TODO: g != 1 - ?
            return new QuadraticInteger(JSBI.BigInt(0), JSBI.BigInt(1), D);
        }

        //var g = ngcd(a, b);
        var g = k;
        //!
        //while (g % 2 == 0) {
        //  g = g / 2;
        //}
        //!
        if (JSBI.notEqual(g, JSBI.BigInt(1))) {
            //TODO:
            //return new QuadraticInteger(primeFactor(g), 0, D);
            //return new QuadraticInteger(QuadraticInteger._factors(g).next().value, b - b, D);
        }
        var norm = this.norm();
        //if (a == 0 || b == 0) {
        //return this;
        //}
        if (JSBI.equal(norm, JSBI.BigInt(1)) || JSBI.equal(norm, JSBI.unaryMinus(JSBI.BigInt(1)))) {
            // https://en.wikipedia.org/wiki/Quadratic_field#Orders_of_quadratic_number_fields_of_small_discriminant
            var unit = QuadraticInteger._fundamentalUnit(D);
            var uniti = unit.conjugate();
            var x = this;
            if (JSBI.lessThan(maybeJSBI.multiply(x.b, x.a), JSBI.BigInt(1))) {
                return JSBI.lessThan(x.a, JSBI.BigInt(0)) ? uniti.negate() : uniti;
            }
            return unit;
        }
        var v = this;
        for (var fs = QuadraticInteger._factors(abs(norm)), p = fs.next().value; p != null; p = fs.next().value) {
            //if (p * p <= norm || abs(norm) === p) {
            // ? https://www.johndcook.com/blog/2008/11/17/fast-way-to-test-whether-a-number-is-a-square/
            /*if (D === 17) {
              var t = Math.abs(norm);
              while (t % 2 === 0) {
                t /= 2;
              }
              p = t === 1 ? norm : primeFactor(t);
            }*/
            if (JSBI.equal(JSBI.remainder(D, JSBI.BigInt(4)), JSBI.BigInt(1)) && JSBI.equal(p, JSBI.BigInt(2))) {
                continue;
            }
            if (JSBI.equal(D, JSBI.BigInt(37)) && (JSBI.equal(p, JSBI.BigInt(7)) || JSBI.equal(p, JSBI.BigInt(14)) || JSBI.equal(p, JSBI.BigInt(3)) || JSBI.equal(p, JSBI.BigInt(11)))) {
                continue;
            }
            //?
            // http://oeis.org/wiki/Quadratic_integer_rings
            if (isPrime(p) && JSBI.notEqual(JSBI.remainder(D, p), JSBI.BigInt(0)) && JSBI.notEqual(p, JSBI.BigInt(2)) && LegendreSymbol(JSBI.toNumber(D), maybeJSBI.toNumber(p)) !== 1) {
                continue;
            }
            //?
            var i = quadraticIntegers(p, D, JSBI.BigInt(0));
            //console.log(i + '');
            var x = v.truncatingDivide(i);
            if (x != null) {
                return this.equals(i) ? i : i.primeFactor();
            }
            var ic = i.conjugate();
            var x = v.truncatingDivide(ic);
            if (x != null) {
                return this.equals(ic) ? ic : ic.primeFactor();
            } // 1+9sqrt(2)
            //}
        }

        //console.log('!');
        return this;
        //throw new TypeError();
    };

    QuadraticInteger.prototype.toString = function() {
        var s = this.a.toString() + '+' + this.b.toString() + 'sqrt(' + this.D + ')';
        if (this.overTwo) {
            s = '(' + s + ')' + '/' + '2';
        }
        return s;
    };
    QuadraticInteger.prototype.isUnit = function() {
        var n = this.norm();
        return JSBI.equal(n, JSBI.BigInt(1)) || JSBI.equal(n, JSBI.unaryMinus(JSBI.BigInt(1)));
    };
    QuadraticInteger.prototype.equals = function(y) {
        var x = this;
        if (!(y instanceof QuadraticInteger)) {
            if (y.equals(Expression.ZERO)) {
                return JSBI.equal(x.a, JSBI.BigInt(0)) && JSBI.equal(x.b, JSBI.BigInt(0));
            }
            if (y.equals(Expression.ONE)) {
                return JSBI.equal(x.a, JSBI.BigInt(1)) && JSBI.equal(x.b, JSBI.BigInt(0));
            }
            throw new TypeError();
        }
        return maybeJSBI.equal(x.a, y.a) && maybeJSBI.equal(x.b, y.b) && maybeJSBI.equal(x.D, y.D) && maybeJSBI.equal(x.overTwo, y.overTwo);
    };
    QuadraticInteger.prototype.subtract = function(y) {
        var x = this;
        if (!maybeJSBI.equal(x.D, y.D)) {
            throw new TypeError();
        }
        var xa = x.a;
        var xb = x.b;
        var ya = y.a;
        var yb = y.b;
        if (maybeJSBI.notEqual(x.overTwo, y.overTwo)) {
            if (x.overTwo) {
                ya = JSBI.multiply(ya, JSBI.BigInt(2));
                yb = JSBI.multiply(yb, JSBI.BigInt(2));
            }
            if (y.overTwo) {
                xa = JSBI.multiply(xa, JSBI.BigInt(2));
                xb = JSBI.multiply(xb, JSBI.BigInt(2));
            }
        }
        return new QuadraticInteger(maybeJSBI.subtract(xa, ya), maybeJSBI.subtract(xb, yb), x.D, x.overTwo || y.overTwo);
    };
    QuadraticInteger.prototype.isDivisibleBy = function(y) {
        return this.truncatingDivide(y) != null;
    };
    QuadraticInteger.prototype.isDivisibleByInteger = function(x) {
        return x.truncatingDivide(this) != null;
    };
    QuadraticInteger.prototype.remainder = function(y) {
        if (!(y instanceof QuadraticInteger)) {
            if (y instanceof Expression.Multiplication && y.a instanceof Expression.Integer && y.b instanceof Expression.SquareRoot) {
                return this.remainder(new QuadraticInteger(Expression.ZERO.toBigInt(), y.a.toBigInt(), y.b.a.toBigInt()));
            }
            if (!(y instanceof Expression.Integer)) {
                throw new RangeError();
            }
            y = new QuadraticInteger(y.toBigInt(), Expression.ZERO.toBigInt(), this.D);
        }
        var x = this;
        if (!maybeJSBI.equal(x.D, y.D)) {
            throw new TypeError();
        }
        var n = x.multiply(y.conjugate());
        var d = y.norm();
        if (JSBI.equal(d, JSBI.BigInt(1)) || JSBI.equal(d, JSBI.unaryMinus(JSBI.BigInt(1)))) {
            // y.isUnit()
            return x.subtract(x);
        }
        var q1 = maybeJSBI.divide(maybeJSBI.subtract(n.a, maybeJSBI.remainder(n.a, d)), d);
        var q2 = maybeJSBI.divide(maybeJSBI.subtract(n.b, maybeJSBI.remainder(n.b, d)), d);
        if (JSBI.equal(q1, JSBI.BigInt(0)) && JSBI.equal(q2, JSBI.BigInt(0))) {
            //if (abs(x.norm()) >= abs(y.norm())) {
            //?
            if (maybeJSBI.greaterThan(x.a, y.a) && JSBI.greaterThan(y.a, JSBI.BigInt(0))) {
                return x.subtract(y.multiply(new QuadraticInteger(maybeJSBI.divide(maybeJSBI.subtract(x.a, maybeJSBI.remainder(x.a, y.a)), y.a), JSBI.BigInt(0), x.D)));
            }
            if (maybeJSBI.greaterThan(x.a, maybeJSBI.unaryMinus(y.a)) && JSBI.lessThan(y.a, JSBI.BigInt(0))) {
                return x.subtract(y.multiply(new QuadraticInteger(maybeJSBI.divide(maybeJSBI.subtract(x.a, maybeJSBI.remainder(x.a, maybeJSBI.unaryMinus(y.a))), maybeJSBI.unaryMinus(y.a)), JSBI.BigInt(0), x.D)));
            }
            if (JSBI.equal(y.b, JSBI.BigInt(0))) {
                return new QuadraticInteger(JSBI.BigInt(1), JSBI.BigInt(0), x.D); //?
            }
            //throw new RangeError("NotSupportedError");//TODO:!!!
            //}
        }

        var q = new QuadraticInteger(q1, q2, x.D);
        var r = x.subtract(y.multiply(q));
        return r;
    };
    QuadraticInteger.prototype.remainderInteger = function(x) {
        return new QuadraticInteger(x.toBigInt(), Expression.ZERO.toBigInt(), this.D).remainder(this);
    };
    QuadraticInteger.prototype.toExpression = function() {
        return Expression.Integer.fromBigInt(this.a).add(Expression.Integer.fromBigInt(this.b).multiply(Expression.Integer.fromNumber(this.D).squareRoot())).divide(this.overTwo ? Expression.TWO : Expression.ONE);
    };
    QuadraticInteger.prototype.abs = function() {
        if (JSBI.lessThanOrEqual(this.a, JSBI.BigInt(0)) && JSBI.lessThanOrEqual(this.b, JSBI.BigInt(0)) || JSBI.lessThan(this.a, JSBI.BigInt(0)) && JSBI.greaterThan(this.norm(), JSBI.BigInt(0)) || JSBI.lessThan(this.b, JSBI.BigInt(0)) && JSBI.lessThan(this.norm(), JSBI.BigInt(0))) {
            return this.negate();
        }
        return this;
    };

    //TODO: merge with the QuadraticInteger.toQuadraticInteger
    QuadraticInteger.prototype.isValid = function() {
        if (true) {
            //return false;
        }
        if (this.D === 5) {
            //return true;//TODO:!!!
        }
        if (this.D === 37) { //TODO: ?
            //return true;
        }
        if (this.D === 6) {
            //TODO: ?
            return false;
        }
        if (this.D % 4 === 1) {
            //TODO: ?
            return false;
        }
        if ([2, 3, 5, 6, 7, 11, 13, 17, 19, 21, 29, 33, 37, 41, 57, 73].indexOf(this.D) === -1) {
            // https://oeis.org/A048981
            return false;
        }
        return true;
    };
    QuadraticInteger.prototype.isPositive = function() {
        var qq = this;
        return JSBI.greaterThan(qq.a, JSBI.BigInt(0)) && JSBI.greaterThan(qq.b, JSBI.BigInt(0)) || JSBI.greaterThan(qq.a, JSBI.BigInt(0)) && JSBI.greaterThan(qq.norm(), JSBI.BigInt(0)) || JSBI.greaterThan(qq.b, JSBI.BigInt(0)) && JSBI.lessThan(qq.norm(), JSBI.BigInt(0));
    };
    self.QuadraticInteger = QuadraticInteger;

    //new QuadraticInteger(-67, 15, 37).primeFactor()

    // new QuadraticInteger(1, 1, 2).remainder(new QuadraticInteger(1, 1, 2))
    // new QuadraticInteger(2, 2, 2).truncatingDivide(new QuadraticInteger(2, 2, 2))

    function toQuadraticInteger(e) {
        //if (e instanceof Expression.Complex) {//!
        //  return e;
        //}
        // qq.a * qq.a + qq.D * qq.b * qq.b < Number.MAX_SAFE_INTEGER
        if (e instanceof Expression.Addition && e.b instanceof Expression.Integer && e.a instanceof Expression.SquareRoot && e.a.a instanceof Expression.Integer) {
            return new QuadraticInteger(e.b.toBigInt(), Expression.ONE.toBigInt(), e.a.a.toBigInt());
        }
        if (e instanceof Expression.Addition && e.b instanceof Expression.Integer && e.a instanceof Expression.Multiplication && e.a.a instanceof Expression.Integer && e.a.b instanceof Expression.SquareRoot && e.a.b.a instanceof Expression.Integer) {
            return new QuadraticInteger(e.b.toBigInt(), e.a.a.toBigInt(), e.a.b.a.toBigInt());
        }
        if (e instanceof Expression.Division) {
            if (e.getDenominator().equals(Expression.TWO)) {
                var tmp = toQuadraticInteger(e.getNumerator());
                if (tmp != null) {
                    return tmp.truncatingDivide(new QuadraticInteger(2, 0, tmp.D));
                }
            }
        }
    }
    //!

    QuadraticInteger.toQuadraticInteger = toQuadraticInteger;
    QuadraticInteger.gcd = function(x, y) {
        var a = x;
        var b = y;
        while (!b.equals(Expression.ZERO)) {
            var r = a.remainder(b);
            if (!maybeJSBI.lessThanOrEqual(abs(r.norm()), abs(b.norm()))) {
                throw new TypeError("norm");
            }
            a = b;
            b = r;
        }
        return a;
    };

    /*
    QuadraticInteger.prototype.compareTo = function (e) {
      if (e === Expression.ZERO) {
        var n = this.a * this.a - this.b * this.b * this.D;
        return this.a === 0 && this.b === 0 ? 0 : (this.a < 0 && this.b < 0 || this.a < 0 && n > 0 || this.b < 0 && n < 0 ? -1 : 1);
      }
      if (e === Expression.ONE) {
        return this.a === 1 && this.b === 0 ? 0 : 1;
      }
      throw new TypeError();
    };
    */

    /*
    // http://oeis.org/wiki/Quadratic_integer_rings#Quadratic_integer_ring_with_discriminant_2
    var expected = {
      "2": {
        "1": "",
        "2": "0+1sqrt(2), 0+1sqrt(2)",
        "3": "3+0sqrt(2)",
        "4": "0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2)",
        "5": "5+0sqrt(2)",
        "6": "0+1sqrt(2), 0+1sqrt(2), 3+0sqrt(2)",
        "7": "3+1sqrt(2), 3+-1sqrt(2)",
        "8": "0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2)",
        "9": "3+0sqrt(2), 3+0sqrt(2)",
        "10": "0+1sqrt(2), 0+1sqrt(2), 5+0sqrt(2)",
        "11": "11+0sqrt(2)",
        "12": "0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2), 3+0sqrt(2)",
        "13": "13+0sqrt(2)",
        "14": "0+1sqrt(2), 0+1sqrt(2), 3+1sqrt(2), 3+-1sqrt(2)",
        "15": "3+0sqrt(2), 5+0sqrt(2)",
        "16": "0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2)",
        "17": "5+2sqrt(2), 5+-2sqrt(2)",
        "18": "0+1sqrt(2), 0+1sqrt(2), 3+0sqrt(2), 3+0sqrt(2)",
        "19": "19+0sqrt(2)",
        "20": "0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2), 5+0sqrt(2)"
      }
    };
  
    var allFactors = function* (qi) {
      while (!qi.isUnit()) {
        var pf = qi.primeFactor();
        yield pf.toString();
        qi = qi.truncatingDivide(pf);
      }
      if (!/^1\+0sqrt\(\d+\)$/.test(qi.toString())) {
        yield qi.toString();
      }
    };
    for (var iteratorD = [2, 3, 5, 6, 7, 11, 13, 17, 19, 21, 29, 33, 37, 41, 57, 73][globalThis.Symbol.iterator](), D = iteratorD.next().value; D != null; D = iteratorD.next().value) {
      expected[D] = expected[D] || {};
      if (D === 3) debugger;
      for (var i = 1; i <= 20; i += 1) {
        expected[D][i] = Array.from(allFactors(new QuadraticInteger(i, 0, D))).join(', ');
        //console.log(i, Array.from(allFactors(new QuadraticInteger(i, 0, D))));
      }
      console.log(D, JSON.stringify(expected[D], null, 2));
    }
    debugger;
    throw new Error();
    */

    //

    /*
  
        if (n === 2) {
          var q = isQuadraticInteger(x);
          //TODO: (q.D === 2 || q.D === 3 || q.D === 5 || q.D === 17)
  
          if (q != null && q.D === 2 && Math.abs(q.a * q.a - q.b * q.b * q.D) === Math.pow(Math.gcd(q.a, q.b), 2)) {
            var ff = Expression.ONE;
            if (q.a % q.D === 0) {
              q = {
                a: q.b,
                b: Math.floor(q.a / q.D),
                D: q.D
              };
              ff = new SquareRoot(Integer.fromNumber(q.D));
              x = x.divide(ff);
            }
            var n = q.a * q.a - q.b * q.b * q.D;
            if (q.a > 0 && q.b > 0 || q.a > 0 && n > 0 || q.b > 0 && n < 0) {
              var t = new QuadraticInteger(q.a, q.b, q.D);
              if (t.primeFactor().equals(t)) {
                return (new SquareRoot(x.multiply(ff)));
              }
              var k1 = new QuadraticInteger(1, 0, q.D);
              var k2 = new QuadraticInteger(1, 0, q.D);
              var i = t;
              var p = null;
              while (!i.equals(Expression.ONE)) {
                var d = i.primeFactor();
                if (p == null) {
                  p = d;
                } else {
                  if (p.equals(d)) {
                    k1 = k1.multiply(d);
                    p = null;
                  } else {
                    k2 = k2.multiply(p);
                    p = d;
                  }
                }
                i = i.truncatingDivide(d);
              }
              if (p != null) {
                k2 = k2.multiply(p);
              }
              return k1.toExpression().multiply(new Expression.SquareRoot(k2.toExpression().multiply(ff)));
            }
          }
        }
    */

    /*
  
  
  
    // +1, -1, +i, -i
    // a+bi
  
    // a === 0, i*(a+bi)
    // a < 0, -(a+bi)
    // b < 0, i*(a+bi)
  
    // a > 0, b > 0
  
  
    /*
      for (var a = 1; a * a <= n; a += 1) {
        for (var b = 0; b * b <= n - a * a; b += 1) {
          if (norm(a, b) > 1n && hasDivisor(r, i, a, b)) {
            return [a, b];
          }
          if (norm(a, -b) > 1n && hasDivisor(r, i, a, -b)) {
            return [a, -b];
          }
        }
      }
      return [r, i];
    */

    function isPrime(n) {
        return maybeJSBI.equal(primeFactor(n), n);
    }

    /*
  
    function primeFactor(n) {
      var i = 2;
      var s = 0;
      var r = Math.floor(Math.sqrt(n + 0.5));
      while (i <= r) {
        if (n % i === 0) {
          return i;
        }
        i += s === 2 ? 2 : s + 1;
        s += 1;
        if (s === 4) {
          s = 2;
        }
      }
      return n;
    }
  
    function norm(x) {
      return x instanceof Expression.Integer ? x.multiply(x).value : x.multiply(x.conjugate()).value;
    }
  
    function checkFactorization(i) {
      var results = [];
      var x = i;
      while (norm(x) > 1) {
        var p = x.primeFactor();
        results.push(p);
  
        //A Gaussian integer a + bi is a Gaussian prime if and only if either:
        //  one of a, b is zero and absolute value of the other is a prime number of the form 4n + 3 (with n a nonnegative integer), or
        //  both are nonzero and a**2 + b**2 is a prime number (which will not be of the form 4n + 3).
        var n = norm(p);
        console.assert(isPrime(n) || ((p instanceof Expression.Integer || p.real.equals(Expression.ZERO) || p.imaginary.equals(Expression.ZERO)) && Math.abs(p instanceof Expression.Integer ? p : p.real.add(p.imaginary).value) % 4 === 3), n, p.toString());
  
        x = x.divide(p);
        if (x instanceof Expression.Integer && norm(x) > 1) {
          x = new Expression.Complex(Expression.ZERO, x);
        }
      }
      console.log(i + '=' + results.map(function (x) { return '(' + x + ')'; }).join(''));
    }
  
  
    // 5-5i
  
    checkFactorization(new Complex(new Expression.Integer(3), new Expression.Integer(3)));
  
    checkFactorization(new Complex(new Expression.Integer(0), new Expression.Integer(2)));
    checkFactorization(new Complex(new Expression.Integer(0), new Expression.Integer(-2)));
    checkFactorization(new Complex(new Expression.Integer(5), new Expression.Integer(1)));
  
    var A = 11;
    for (var i = -A; i <= A; i += 1) {
      for (var j = -A; j <= A; j += 1) {
        if (j !== 0) {
          checkFactorization(new Complex(new Expression.Integer(i), new Expression.Integer(j)));
        }
      }
    }
  
  
    */

    /*
              if (i == null && isOnePlusSqrtOf2(y.a)) {
                i = y.a;
              }
              if (i == null) {
                throw new TypeError();
              }
              } else if (isOnePlusSqrtOf2(y.a)) {
                if (!p.equals(y.a)) {
                  throw new TypeError();
                }
                degree += 1;
  
    */

    // http://oeis.org/wiki/Quadratic_integer_rings
    // https://oeis.org/A048981
    // https://en.wikipedia.org/wiki/Euclidean_domain#Norm-Euclidean_fields
    // https://en.wikipedia.org/wiki/Fundamental_unit_(number_theory)
    // https://en.wikipedia.org/wiki/Pell%27s_equation
    // https://en.wikipedia.org/wiki/Diophantine_equation
    // https://ru.wikipedia.org/wiki/Гауссовы_целые_числа#Определение
    // https://en.wikipedia.org/wiki/Gaussian_integer
    // https://en.wikipedia.org/wiki/Prime_element

    globalThis.QuadraticInteger = QuadraticInteger;

    // ExpressionParser.parse('((17^0.5+7)**3)**(1/3)') + ''

    // new QuadraticInteger(7, 1, 17).remainder(new QuadraticInteger(3, 1, 17))

    QuadraticInteger._checkFactorization = function checkFactorization(i) {
        if (typeof i === "string") {
            i = QuadraticInteger.toQuadraticInteger(RPN(i));
        }
        var results = [];
        var x = i;
        while (Math.abs(maybeJSBI.toNumber(x.norm())) > 1) {
            //debugger;
            var p = x.primeFactor();
            results.push(p);
            x = x.truncatingDivide(p);
        }
        if (x.a.toString() !== '1' || x.b.toString() !== '0') {
            results.unshift(x);
        }
        console.log(i + '=' + results.map(function(x) {
            return '(' + x.toString() + ')';
        }).join(''));
    };
})();
(function() {
    "use strict";
    /*jslint plusplus: true, vars: true, indent: 2, white: true */
    /*global i18n, Condition, ExpressionParser, Polynomial, Expression, Matrix, NonSimplifiedExpression*/

    var RPN = ExpressionParser.parse; //TODO: fix
    RPN.Context = ExpressionParser.Context;
    var polynomialToExpression3 = function(matrix, row, variableSymbols) {
        var pivotColumn = 0;
        while (pivotColumn < matrix.cols() - 1 && matrix.e(row, pivotColumn).equals(Expression.ZERO)) {
            pivotColumn += 1;
        }
        if (pivotColumn === matrix.cols() - 1) {
            throw new TypeError();
        }
        var result = undefined;
        for (var i = pivotColumn; i < matrix.cols() - 1; i += 1) {
            var c = i === pivotColumn ? matrix.e(row, matrix.cols() - 1) : matrix.e(row, i).negate();
            var v = i === pivotColumn ? undefined : variableSymbols[i];
            if (!c.equals(Expression.ZERO)) {
                var current = v == undefined ? c : c.equals(Expression.ONE) ? v : new Expression.Multiplication(c, v);
                result = result == undefined ? current : new Expression.Addition(result, current);
            }
        }
        return result == undefined ? Expression.ZERO : result;
    };
    RPN.toMathML = function(input, printOptions) {
        return ExpressionParser.parse(input, new ExpressionParser.Context()).toMathML(printOptions);
    };

    //Note: matrixTableState.inputValues were filled by `getInputValue`
    RPN.getElementsArray = function(matrixTableState) {
        var mode = matrixTableState.mode;
        var type = matrixTableState.type;
        var textareaValue = matrixTableState.textareaValue;
        var inputValues = matrixTableState.inputValues;
        if (mode !== "cells") {
            //?
            //!!!
            if (type === "system") {
                // to support custom input in SLE: 3x+y-2z=2; 2x+y-1=3; ...
                if (/\=/.exec(textareaValue) != undefined) {
                    //?
                    try {
                        var tmp = getAugmentedSystemMatrix(textareaValue);
                        if (tmp != undefined) {
                            return tmp;
                        }
                    } catch (error) {
                        console.log(error);
                    }
                }
            }
            //!!!

            var resultRows = Matrix.split(textareaValue);
            return {
                elements: resultRows,
                variableNames: undefined
            }; // the user, probably, does not expecte varible names, and matrixTableState.variableNames contains less number of variables
        }

        return {
            elements: inputValues,
            variableNames: matrixTableState.variableNames
        };
    };
    var getSymbols = function(e) {
        if (e instanceof Expression.Symbol) {
            return [e];
        }
        if (e instanceof Expression.Integer) {
            return [];
        }
        if (e instanceof Expression.Complex) {
            return [];
        }
        if (e instanceof Expression.BinaryOperation) {
            var sa = getSymbols(e.a);
            var sb = getSymbols(e.b);
            return sa != null && sb != null ? sa.concat(sb) : null;
        }
        if (e instanceof Expression.Function) {
            return getSymbols(e.a);
        }
        return null;
    };
    var getAugmentedSystemMatrix = function(s) {
        //!2018-07-16
        s = s.replace(/[;\r]|,(?!\d)/g, "\n");
        //!

        var lines = s.split("\n");
        var k = -1;
        var rows = [];
        var frees = [];
        var variableToColumnNumberMap = {}; // string -> number
        var columnNumberToVariableMap = []; // number -> string

        var free = undefined;
        var row = undefined;
        var onVariable = function(coefficient, variable) {
            if (variable === "") {
                free = free.add(coefficient);
            } else {
                var columnIndex = variableToColumnNumberMap[variable];
                if (columnIndex == undefined) {
                    columnIndex = columnNumberToVariableMap.length;
                    variableToColumnNumberMap[variable] = columnIndex;
                    columnNumberToVariableMap.push(variable);
                }
                while (row.length < columnIndex + 1) {
                    row.push(Expression.ZERO);
                }
                row[columnIndex] = row[columnIndex].add(coefficient);
            }
        };
        var cvLists = new Array(lines.length);
        RPN.p = 0; //!
        while (++k < lines.length) {
            cvLists[k] = undefined;
            var line = lines[k];
            var x = line.split("=");
            if (x.length === 2) {
                //TODO: fix
                var leftString = x[0];
                var rightString = x[1];
                var left = ExpressionParser.parse(leftString);
                RPN.p += leftString.length;
                RPN.p += "=".length;
                var right = ExpressionParser.parse(rightString);
                RPN.p += rightString.length;
                RPN.p += "\n".length;
                var y = left.subtract(right).getNumerator();
                cvLists[k] = Expression.collectLinearEquationVariables(y);
            } else {
                RPN.p += line.length + "\n".length;
                if (line.replace(/^\s+|\s+$/g, "") !== "") {
                    // to skip empty lines
                    return undefined;
                }
            }
        }

        // second pass:
        var nonVariableSymbols = {};
        for (var i = 0; i < cvLists.length; i += 1) {
            if (cvLists[i] != undefined) {
                var list = cvLists[i];
                for (var j = 0; j < list.length; j += 1) {
                    var symbols = getSymbols(list[j].c);
                    if (symbols == null) {
                        // `getSymbols` does not support this expression
                        return undefined;
                    }
                    for (var k = 0; k < symbols.length; k += 1) {
                        nonVariableSymbols[symbols[k]] = true;
                    }
                }
            }
        }
        for (var i = 0; i < cvLists.length; i += 1) {
            if (cvLists[i] != undefined) {
                var list = cvLists[i];
                for (var j = 0; j < list.length; j += 1) {
                    if (nonVariableSymbols[list[j].v] === true) {
                        list[j] = {
                            c: list[j].c.multiply(new Expression.Symbol(list[j].v)),
                            v: ""
                        };
                    }
                }
            }
        }
        for (var i = 0; i < cvLists.length; i += 1) {
            if (cvLists[i] != undefined) {
                row = [];
                free = Expression.ZERO;
                var list = cvLists[i];
                for (var j = 0; j < list.length; j += 1) {
                    onVariable(list[j].c, list[j].v);
                }
                frees.push(free);
                rows.push(row);
            }
        }
        var a = -1;
        while (++a < rows.length) {
            row = rows[a];
            while (row.length < columnNumberToVariableMap.length) {
                row.push(Expression.ZERO);
            }
            row.push(frees[a].negate());
        }
        var b = -1;
        while (++b < rows.length) {
            row = rows[b];
            var c = -1;
            while (++c < row.length) {
                row[c] = row[c].toString(); //!slow?
            }
        }
        //!TODO: fix: reverse variables and coefficients, as Expression.collectLinearEquationVariables gives wrong order
        b = -1;
        while (++b < rows.length) {
            row = rows[b];
            var f = -1;
            var d = row.length - 1; // skipping free
            while (++f < --d) {
                var tmp = row[f];
                row[f] = row[d];
                row[d] = tmp;
            }
        }
        var newColumnNumberToVariableMap = []; // number -> Expression
        b = -1;
        while (++b < columnNumberToVariableMap.length) {
            newColumnNumberToVariableMap.push(columnNumberToVariableMap[columnNumberToVariableMap.length - 1 - b]);
        }
        columnNumberToVariableMap = newColumnNumberToVariableMap;
        //!
        return {
            elements: rows,
            variableNames: columnNumberToVariableMap
        };
    };
    Matrix.toMatrix = function(array) {
        var context = new ExpressionParser.Context();
        return Matrix.padRows(array, function(e) {
            return ExpressionParser.parse(e, context);
        });
    };

    // ---------------------------------------i18n.js-----------------------------------------

    // see https://www.w3.org/TR/2006/NOTE-arabic-math-20060131/#Persian
    // and https://en.wikipedia.org/wiki/Modern_Arabic_mathematical_notation#Mathematical_letters
    // https://ru.wikipedia.org/wiki/Википедия:Формулы#:~:text=в%20русской%20традиции%20многие%20тригонометрические%20и%20гиперболические%20функции%20обозначаются%20иначе

    // i18n.rankDenotation
    // i18n.sinDenotation
    // i18n.tanDenotation
    // TODO: denotations on the main page in information

    // 'ar-u-nu-arab' === arz (as on Wikipedia) - ?

    var denotationsByOperation = {
        sqrt: {
            de: "wurzel"
        },
        rank: {
            bg: "ранг",
            de: "rang",
            en: "rank",
            es: "rango",
            fr: "rg",
            gl: "rango",
            it: "rango",
            nl: "rang",
            pt: "posto",
            tr: "rank"
        },
        transpose: {
            es: "traspuesta"
        },
        determinant: {
            pt: "determinante"
        },
        sin: {
            'ar-u-nu-arab': "حا‎‎",
            es: "sen"
        },
        cos: {
            'ar-u-nu-arab': "حتا‎‎‎"
        },
        tan: {
            'ar-u-nu-arab': "طا‎",
            ru: "tg",
            uk: "tg",
            fr: "tg"
        },
        cot: {
            'ar-u-nu-arab': "طتا‎‎‎‎",
            ru: "ctg",
            uk: "ctg"
        },
        sinh: {
            'ar-u-nu-arab': "حاز",
            es: "senh",
            pt: "senh",
            ru: 'sh'
        },
        cosh: {
            'ar-u-nu-arab': "حتاز‎",
            ru: 'ch'
        },
        tanh: {
            'ar-u-nu-arab': "طاز‎",
            ru: 'th'
        },
        coth: {
            'ar-u-nu-arab': 'طتاز‎',
            ru: 'cth'
        },
        arctan: {
            ru: 'arctg',
            uk: 'arctg'
        },
        arccot: {
            ru: 'arcctg',
            uk: 'arcctg'
        },
        arsinh: {
            ru: 'arsh'
        },
        arcosh: {
            ru: 'arch'
        },
        artanh: {
            ru: 'arth'
        },
        arcoth: {
            ru: 'arcth'
        }
    };
    ExpressionParser.addDenotations(denotationsByOperation);
    var lang = document.documentElement.lang;
    for (var name in denotationsByOperation) {
        if (Object.prototype.hasOwnProperty.call(denotationsByOperation, name)) {
            Expression.denotations[name] = denotationsByOperation[name][lang];
        }
    }
    Expression.denotations["log"] = "ln"; //!
    Expression.denotations["determinant"] = "det"; //!
    Expression.denotations["adjugate"] = "adj"; //!

    // --------------------------------------------- end ----------------------------------------------

    var getResultAndHTML = function(expression, variableNames, result, printOptions) {
        // TODO: fix
        var resultHTML = "";
        if (result instanceof Expression.NoAnswerExpression) {
            var name = result.name;
            var matrix = result.a.matrix;
            var second = result.second; //!
            //result = undefined;
            if (name === "solve") {
                resultHTML = ""; //TODO:
            } else {
                resultHTML = Expression.Details.getCallback(name)(printOptions, matrix, second == undefined ? variableNames : second);
            }
        } else if (result instanceof Expression.Equality) {
            //TODO: counter
            resultHTML = "";
            resultHTML += "<div>" + "<math>" + expression.toMathML(printOptions) + "</math>" + "</div>";
            resultHTML += "<div>" + "<math>" + result.toMathML(printOptions) + "</math>" + "</div>";
        } else {
            resultHTML = "<math>" + expression.toMathML(printOptions) + "<mo>=</mo>" + result.toMathML(printOptions) + "</math>";
        }
        return {
            result: result,
            html: resultHTML
        };
    };

    //? bestMethodsLimit - with highest priority
    var createDetailsSummary = function(idPrefix, details, bestMethodsLimit) {
        bestMethodsLimit = bestMethodsLimit == undefined ? 1 : bestMethodsLimit;
        var s = "";
        for (var j = 0; j < details.length; j += 1) {
            //TODO: FIX
            //var rows = details[j].matrix.split("},").length;
            var countRows = function(s) {
                var state = 0;
                var result = 1;
                for (var i = 0; i < s.length; i += 1) {
                    var c = s.charCodeAt(i);
                    if (c === ",".charCodeAt(0)) {
                        if (state === 1) {
                            result += 1;
                        }
                    } else if (c === "{".charCodeAt(0)) {
                        state += 1;
                    } else if (c === "}".charCodeAt(0)) {
                        state -= 1;
                    }
                }
                return result;
            };
            var rows = countRows(details[j].matrix);
            //TODO: what if some `type` was provided?
            var type = details[j].type;
            var items = [];
            var edetails = Expression.Details.getAll(type, rows);
            for (var i = 0; i < edetails.length; i += 1) {
                var x = edetails[i];
                var jsonObject = {
                    type: x.type,
                    matrix: details[j].matrix,
                    second: details[j].second
                };
                // It is needed to use an individual prefix to have unique ids (consider if Expression.idCounter was reset after reload)
                var detailsIdPrefix = idPrefix + '-' + 'd' + i;
                //TODO: Tree View - ?
                var item = "" + "<details data-id-prefix=\"" + detailsIdPrefix + "\" " + "data-details=\"" + Expression.escapeHTML(JSON.stringify(jsonObject)) + "\"" + ">" + "<summary>" + i18n.misc.summaryLabel + (x.i18n != undefined ? " (" + x.i18n() + ")" : "") + "</summary>" + ('activeElement' in document ? "<div class=\"indented\"></div>" : "<a class=\"indented\"></a>") + "</details>";
                items.push(item);
            }
            var groupId = idPrefix + "-" + Expression.id();
            if (items.length > bestMethodsLimit + 1) {
                s += items.slice(0, bestMethodsLimit).join("");
                s += "<div id=\"" + groupId + "\" role=\"group\" hidden>";
                s += items.slice(bestMethodsLimit).join("");
                s += "</div>";
                s += "<button type=\"button\" class=\"more-button\" aria-expanded=\"false\" aria-controls=\"" + groupId + "\">&hellip;</button>";
            } else {
                s += items.join("");
            }
        }
        return s;
    };
    Expression.Minor = function(matrix, i, j) {
        Expression.Determinant.call(this, matrix);
        this.i = i;
        this.j = j;
    };
    Expression.Minor.prototype = Object.create(Expression.Determinant.prototype);
    Expression.Minor.prototype.toMathML = function(options) {
        options = Object.assign({}, options, {
            horizontalStrike: this.i,
            verticalStrike: this.j,
            useBraces: ["|", "|"]
        });
        //TODO: fix
        return this.a.toMathML(options);
    };
    Expression.p = function(s, args, printOptions) {
        if (typeof s === "number") {
            return Expression.Integer.fromNumber(s).toMathML(printOptions);
        }
        if (args == null && printOptions != null || args != null && printOptions == null) {
            throw new TypeError();
        }
        args = args || null;
        printOptions = printOptions || null;
        var result = "";
        var parts = s.split("=");
        for (var i = 0; i < parts.length; i += 1) {
            var e = ExpressionParser.parse(parts[i], new ExpressionParser.Context(function(id) {
                return args != undefined && args[id] != undefined ? args[id] : undefined;
            }));
            //TODO: how to fix e.isExact() - ?
            if (i !== 0) {
                result += "<mo>" + (e.isExact() ? "=" : "&asymp;") + "</mo>";
            }
            result += e.toMathML(printOptions);
        }
        return result;
    };
    Expression.Details = function() {};

    // TODO: optimize
    Expression.Details._details = [];
    Expression.Details.details = null;

    // https://stackoverflow.com/a/53357343/839199
    var lowerBound = function(array, compare) {
        var start = 0;
        var end = array.length;
        while (start < end) {
            var middle = start + Math.floor((end - start) / 2);
            var value = array[middle];
            if (compare(value) <= 0) {
                end = middle;
            } else {
                start = middle + 1;
            }
        }
        return start;
    };
    var sortDetails = function() {
        if (Expression.Details.details == null) {
            Expression.Details._details.sort(function(a, b) {
                return a.type < b.type ? -1 : +1;
            });
            Expression.Details.details = Expression.Details._details;
        }
    };
    Expression.Details.getCallback = function(type) {
        sortDetails();
        var i = lowerBound(Expression.Details.details, function(a) {
            return type <= a.type ? -1 : +1;
        });
        if (i < Expression.Details.details.length) {
            if (Expression.Details.details[i].type === type) {
                return Expression.Details.details[i].callback;
            }
        }
        return undefined;
    };
    Expression.Details.add = function(data) {
        var x = {
            type: data.type,
            i18n: data.i18n,
            minRows: data.minRows || 1,
            maxRows: data.maxRows || 1 / 0,
            priority: data.priority || 0,
            // the number comparision should work
            callback: data.callback
        };
        Expression.Details._details.push(x);
        Expression.Details.details = null;

        //?
        if (x.type !== "multiply" && x.type !== "add" && x.type !== "pow" && x.type !== "special-determinant") {
            ExpressionParser.addOperation(x.type, x.type === "expand-along-column" || x.type === "expand-along-row" || x.type === "obtain-zeros-in-column" || x.type === "obtain-zeros-in-row" || x.type === "polynomial-multiply" ? 2 : 1);
        }
    };
    Expression.Details.getAll = function(typePrefix, rows) {
        var result = [];
        sortDetails();
        for (var i = lowerBound(Expression.Details.details, function(a) {
                return typePrefix <= a.type ? -1 : +1;
            }); i < Expression.Details.details.length && Expression.Details.details[i].type.indexOf(typePrefix) === 0; i += 1) {
            var x = Expression.Details.details[i];
            if (x.type.indexOf(typePrefix) === 0) {
                if (rows >= x.minRows && rows <= x.maxRows) {
                    if (rows <= 4 || rows >= 10) {
                        // limit maxRows to reduce "de tricherie aux examens" and un-hiding them for large matrices (>=10x10) it seems unlikely that such examples will be on exams
                        result.push(x);
                    }
                }
            }
        }
        result.sort(function(a, b) {
            return b.priority - a.priority;
        });
        return result;
    };
    Expression.Details.add({
        type: "property-adjugate-of-multiplication",
        callback: function() {
            return "<math>" + Expression.p("adj(A*B)=adj(B)*adj(A)") + "</math>" + " " + i18n.adjugateMatrixPropertiesLink;
        }
    });
    Expression.Details.add({
        type: "property-determinant-of-multiplication",
        callback: function() {
            return "<math>" + Expression.p("det(A*B)=det(A)*det(B)") + "</math>" + " " + i18n.determinantPropertiesLink;
        }
    });
    Expression.Details.add({
        type: "property-inverse-of-multiplication",
        callback: function() {
            return "<math>" + Expression.p("(A*B)^-1=B^-1*A^1") + "</math>" + " " + i18n.inversePropertiesLink;
        }
    });
    Expression.Details.add({
        type: "property-transpose-of-multiplication",
        callback: function() {
            return "<math>" + Expression.p("(A*B)^T=B^T*A^T") + "</math>" + " " + i18n.transposePropertiesLink;
        }
    });
    Expression.Details.add({
        type: "steps-to-diagonalize",
        minRows: 2,
        callback: function(printOptions, matrix) {
            // TODO: move to details
            //TODO: details of determinant calculation, details of roots finding
            var html = "";
            html += "<ol>";
            var tmp = Expression.getEigenvaluesWithSteps(printOptions, matrix);
            var eigenvalues = tmp.eigenvalues;
            html += "<li>";
            html += tmp.html;
            html += "</li>";

            // https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors#Algebraic_multiplicity
            if (eigenvalues.length !== matrix.cols()) {
                //TODO: show polynomial in html anyway
                //TODO: fix message
                html += "</ol>"; //TODO: fix
                //TODO: fix
                return html;
            }
            var tmp2 = Expression.getEigenvectorsWithSteps(printOptions, matrix, Expression.unique(eigenvalues));
            html += "<li>";
            html += tmp2.html;
            html += "</li>";
            var eigenvectors = tmp2.eigenvectors;
            //  html += "</ol>";

            if (eigenvectors.length !== matrix.cols()) {
                //TODO: show polynomial in html anyway
                html += "</ol>"; //TODO: fix
                //TODO: fix
                return html;
            }
            var results = Expression.diagonalize(matrix, eigenvalues, eigenvectors);
            var T = results.T;
            var L = results.L;
            var T_INVERSED = results.T_INVERSED;
            html += "<li>";
            html += "<ul>";
            html += "<li>";
            var eigenvaluesLinks = [];
            var uniqueEigenvalues = Expression.unique(eigenvalues);
            for (var i = 0; i < uniqueEigenvalues.length; i += 1) {
                var eigenvalue = uniqueEigenvalues[i];
                var multiplicity = eigenvalues.reduce(function(count, e) {
                    return count + (e === eigenvalue ? 1 : 0);
                }, 0);
                for (var j = 0; j < multiplicity; j += 1) {
                    eigenvaluesLinks.push("<a href=\"#" + printOptions.idPrefix + "-eigenvalue-" + (i + 1) + "\">" + "<math>" + Expression.p("λ_" + (i + 1)) + "</math>" + "</a>");
                }
            }
            var listFormat = getListFormat();
            html += "<div>" + i18n.diagonalization.theDiagonalMatrixTheDiagonalEntriesAreTheEigenvalues.replace(/\$\{eigenvaluesLinks\}/g, listFormat.format(eigenvaluesLinks)) + "</div>";
            html += "<math>" + Expression.p("D=M", {
                M: new Expression.Matrix(L)
            }, printOptions) + "</math>";
            html += "</li>";
            html += "<li>";
            var eigenvectorsLinks = [];
            for (var i = 0; i < eigenvectors.length; i += 1) {
                eigenvectorsLinks.push("<a href=\"#" + printOptions.idPrefix + "-eigenvector-" + (i + 1) + "\">" + "<math>" + Expression.p("v_0", {
                    v_0: new Expression.MatrixSymbol('v_' + (i + 1))
                }, printOptions) + "</math>" + "</a>");
            }
            html += "<div>" + i18n.diagonalization.theMatrixWithTheEigenvectorsAsItsColumns.replace(/\$\{eigenvectorsLinks\}/g, listFormat.format(eigenvectorsLinks)) + "</div>";
            html += "<math>" + Expression.p("P=M", {
                M: new Expression.Matrix(T)
            }, printOptions) + "</math>";
            html += "</li>";
            html += "<li>";
            html += "<math>" + Expression.p("P^-1=M", {
                M: new Expression.Matrix(T_INVERSED)
            }, printOptions) + "</math>";
            html += createDetailsSummary(printOptions.idPrefix, [{
                type: T.getDeterminantEventType("inverse").type,
                matrix: T.toString(),
                second: undefined
            }]);
            html += "</li>";
            html += "<li>";
            html += "<math>" + Expression.p("A=P*D*P^-1") + "</math>";
            html += " ";
            html += i18n.matrixDiagonalizationLink;
            html += "</li>";
            html += "</ul>";
            html += "</li>";
            html += "</ol>";
            return html;
        }
    });
    Expression.Details.add({
        type: "diagonalize",
        minRows: 2,
        callback: function(printOptions, matrix) {
            var eigenvalues = Expression.getEigenvalues(matrix);
            //TODO: fix
            var detailsHTML = createDetailsSummary(printOptions.idPrefix, [{
                type: 'steps-to-diagonalize',
                matrix: matrix.toString(),
                second: undefined
            }]);
            if (eigenvalues.length !== matrix.cols()) {
                return "<div>" + i18n.diagonalization.notEnoughRationalEigenvalues + "</div>" + detailsHTML;
            }
            var eigenvectors = Expression.getEigenvectors(matrix, eigenvalues);
            if (eigenvectors.filter(function(v) {
                    return v != null;
                }).length !== matrix.cols()) {
                // The matrix is not diagonalizable, because it does not have {n} linearly independent eigenvectors.
                var message = i18n.diagonalization.notDiagonalizable.replace(/\$\{n\}/g, matrix.cols());
                //!2019-04-18
                message += " " + "<small>" + i18n.JordanDecomposition.tryToFindJordanNormalForm.replace(/\*([^\*]+)\*/g, '<a href="#Jordan-decomposition(' + matrix.toString() + ')">$1</a>') + "</small>";
                //!
                return "<div>" + message + "</div>" + detailsHTML;
            }
            var results = Expression.diagonalize(matrix, eigenvalues, eigenvectors);

            //var detailsHTML = "<details open=\"open\"><summary>" + i18n.misc.summaryLabel + "</summary><div class=\"indented\">" + html + "</div></details>";
            var resultHTML = "<math>" + new Expression.Matrix(matrix).toMathML(printOptions) + "<mo>" + (results.L.isExact() ? "=" : "&asymp;") + "</mo>" + "<mrow>" + new Expression.Matrix(results.T).toMathML(printOptions) + "<mo>&sdot;</mo>" + new Expression.Matrix(results.L).toMathML(printOptions) + "<mo>&sdot;</mo>" + new Expression.Matrix(results.T_INVERSED).toMathML(printOptions) + "</mrow>" + "</math>";
            //result = results.T;
            return resultHTML + detailsHTML;
        }
    });

    function getListFormat() {
        var listFormat = typeof Intl !== 'undefined' && Intl.ListFormat != null ? new Intl.ListFormat([]) : {
            format: function(array) {
                return array.join(', ');
            }
        };
        return listFormat;
    }

    //!2018-10-03
    Expression.Details.add({
        type: "Jordan-decomposition",
        minRows: 2,
        //i18n: function () {
        //  return i18n.vectors.JordanDecomposition;//use cases -?
        //},
        callback: function(printOptions, matrix) {
            var tmp = Expression.getEigenvaluesWithSteps(printOptions, matrix);
            var eigenvalues = tmp.eigenvalues;
            if (eigenvalues.length !== matrix.cols()) {
                //TODO: allow complex roots
                //TODO: show polynomial in html anyway
                //TODO: fix message
                var html = undefined; //!
                html = tmp.html;
                var detailsHTML = "<details open=\"open\"><summary>" + i18n.misc.summaryLabel + "</summary><div class=\"indented\">" + html + "</div></details>";
                return "<div>" + i18n.diagonalization.notEnoughRationalEigenvalues + "</div>" + detailsHTML;
            }
            //var results = Expression.getFormaDeJordan(matrix, eigenvalues);
            //TODO: solution steps

            //TODO: merge with `Expression.getFormaDeJordan`
            //TODO: i18n
            //TODO: hide <details>, compute on demand
            //TODO: better details (links to vectors, subdetails for solution of systems)
            function matrixFromBlocks(blocks) {
                var start = 0;
                var J = Matrix.Zero(n, n);
                for (var i = 0; i < blocks.length; i += 1) {
                    var b = blocks[i];
                    J = J.map(function(e, i, j) {
                        if (i >= start && i < start + b.size) {
                            return i === j ? b.eigenvalue : i !== start + b.size - 1 && j === i + 1 ? Expression.ONE : Expression.ZERO;
                        }
                        return e;
                    });
                    start += b.size;
                }
                return J;
            }

            function isSolution(coefficientMatrix, vector) {
                var f = coefficientMatrix.multiply(vector);
                return f.eql(Matrix.Zero(f.rows(), 1));
            }

            function isLinearlyIndependentSet(basis, vectors) {
                // https://math.stackexchange.com/questions/412563/determine-if-vectors-are-linearly-independent
                return Matrix.fromVectors(basis.concat(vectors)).rank() === basis.length + vectors.length;
            }
            var containerId = printOptions.idPrefix + "-" + Expression.id();
            var links = [];
            var basis = [];
            var blocks = [];
            var A = matrix;
            var n = A.cols();
            var html = '';
            var listFormat = getListFormat();
            html += '<h3>' + i18n.JordanDecomposition.findAMatrixInJordanNormalFormSimilarToOriginal + ' ' + i18n.JordanDecompositionLink + '</h3>';
            html += '<ol>';
            html += '<li>';
            html += '<h4>' + i18n.JordanDecomposition.solveTheCharacteristicEquationForEigenvaluesAndTheirAlgebraicMultiplicities + '</h4>';
            html += tmp.html;
            html += '</li>';
            html += '<li>';
            html += '<h4>' + i18n.JordanDecomposition.findLinearlyIndependentGeneralizedEigenvectorsForEveryEigenvalue + '</h4>';
            html += '<ol>';
            var uniqueEigenvalues = Expression.unique(eigenvalues);
            for (var i = 0; i < uniqueEigenvalues.length; i += 1) {
                html += '<li>';
                var basisCorrespondingToTheEigenvalue = [];
                var eigenvalue = uniqueEigenvalues[i];
                var algebraicMultiplicity = eigenvalues.reduce(function(count, e) {
                    return count + (e === eigenvalue ? 1 : 0);
                }, 0);
                var B = A.subtract(Matrix.I(n).scale(eigenvalue));
                html += '<h5>';
                html += i18n.JordanDecomposition.eigenvalue + ' ' + '<math>' + Expression.p('λ_' + (i + 1) + '=v', {
                    v: eigenvalue
                }, printOptions) + '</math>' + ', ' + i18n.JordanDecomposition.algebraicMultiplicity + ' ' + '<math>' + Expression.p('μ_' + (i + 1) + '=' + algebraicMultiplicity) + '</math>';
                html += '</h5>';
                html += '<p>' + i18n.JordanDecomposition.determineTheMaximalRankOfGeneralizedEigenvectors + '</p>';
                var m = 0;
                html += '<ul>';
                do {
                    m += 1;
                    html += '<li>';
                    var rank = B.pow(m).rank();
                    html += '<math>' + Expression.p('rank(A-l*I)**' + m + '=' + rank, {
                        A: new Expression.Matrix(matrix),
                        l: eigenvalue
                    }, printOptions) + '</math>';
                    html += '</li>';
                } while (B.pow(m).rank() > n - algebraicMultiplicity);
                html += '</ul>';
                m += 1;
                html += '<p>' + i18n.JordanDecomposition.determineEachJordanChain + '</p>';
                html += '<ol>';
                while (--m >= 1) {
                    html += '<li>';
                    html += i18n.JordanDecomposition.findSolutionsOfX.replace(/\$\{X\}/g, '<math>' + Expression.p('(A-l*I)**' + m + '*X=0', {
                        A: new Expression.Matrix(matrix),
                        l: eigenvalue
                    }, printOptions) + '</math>');
                    var solutionSet = Expression.getSolutionSet(B.pow(m));
                    html += '<div>';
                    html += i18n.JordanDecomposition.aBasisForTheSolutionSet + ' ';
                    html += '<math>';
                    html += '<mrow>';
                    html += '<mo stretchy="false">{</mo>';
                    html += solutionSet.length !== 1 ? '<mrow>' : '';
                    for (var j = 0; j < solutionSet.length; j += 1) {
                        var solution = solutionSet[j];
                        if (j !== 0) {
                            html += '<mo>,</mo>';
                        }
                        html += new Expression.Matrix(solution).toMathML(printOptions);
                    }
                    html += solutionSet.length !== 1 ? '</mrow>' : '';
                    html += '<mo stretchy="false">}</mo>';
                    html += '</mrow>';
                    html += '</math>';
                    html += '</div>';
                    html += '<ol>';
                    for (var j = 0; j < solutionSet.length; j += 1) {
                        var solution = solutionSet[j];
                        html += '<li>';
                        html += '<h6>';
                        html += '<math>' + Expression.p('x_' + (j + 1) + '=v', {
                            v: new Expression.Matrix(solution)
                        }, printOptions) + '</math>';
                        html += '</h6>';
                        if (!isSolution(B.pow(m - 1), solution)) {
                            //TODO: "link" to m/"highlight" of m
                            html += '<p>' + '<math>' + Expression.p('(A-l*I)**(' + m + '-1)*X', {
                                A: new Expression.Matrix(matrix),
                                l: eigenvalue
                            }, printOptions) + '<mo>&ne;</mo>' + Expression.p(0) + '</math>' + ' &rarr; ' + i18n.JordanDecomposition.itIsAGeneralizedEigenvector + '</p>';
                            var chain = [];
                            chain.push(solution);
                            html += '<p>' + i18n.JordanDecomposition.generateAJordanChainForThisGeneralizedEigenvector + '</p>';
                            var chainHtml = '';
                            chainHtml += '<ol>';
                            chainHtml += '<li>';
                            chainHtml += '<math>' + Expression.p('v_1=S', {
                                S: new Expression.Matrix(solution)
                            }, printOptions) + '</math>';
                            chainHtml += '</li>';
                            var s = solution;
                            for (var k = 1; k < m; k += 1) {
                                var previous = s;
                                s = B.multiply(s).col(0);
                                chain.push(s);
                                chainHtml += '<li>';
                                chainHtml += '<math>' + Expression.p('v_' + (k + 1) + '=(A-l*I)*S=X', {
                                    A: new Expression.Matrix(matrix),
                                    l: eigenvalue,
                                    S: new Expression.Matrix(previous),
                                    X: new Expression.Matrix(s)
                                }, printOptions) + '</math>';
                                chainHtml += '</li>';
                            }
                            chainHtml += '</ol>';
                            chain.reverse();
                            if (isLinearlyIndependentSet(basisCorrespondingToTheEigenvalue, chain)) {
                                var id = containerId + '-' + (blocks.length + 1);
                                html += '<table role="presentation" class="anchor-table anchor" id="' + id + '">';
                                html += '<tr>';
                                html += '<td>';
                                html += chainHtml;
                                html += '</td>';
                                html += '<td>';
                                html += '(' + localeString(blocks.length + 1) + ')';
                                html += '</td>';
                                html += '</tr>';
                                html += '</table>';
                                links.push('<a href="#' + id + '">(' + localeString(blocks.length + 1) + ')</a>');
                                basis = basis.concat(chain);
                                basisCorrespondingToTheEigenvalue = basisCorrespondingToTheEigenvalue.concat(chain);
                                blocks.push({
                                    size: m,
                                    eigenvalue: eigenvalue
                                });
                            } else {
                                html += chainHtml;
                            }
                        } else {
                            //TODO: ? identityMatrixDenotation
                            //TODO: 1*I - do not use invisible times here (?)
                            html += '<p>' + '<math>' + Expression.p('(A-l*I)**(' + m + '-1)*X=0', {
                                A: new Expression.Matrix(matrix),
                                l: eigenvalue
                            }, printOptions) + '</math>' + ' &rarr; ' + i18n.JordanDecomposition.itIsNotAGeneralizedEigenvector + '</p>';
                        }
                        html += '</li>';
                    }
                    html += '</ol>';
                    html += '</li>';
                }
                html += '</ol>';
                html += '<p>' + i18n.JordanDecomposition.theJordanChainsMakeBasis.replace(/\$\{links\}/g, listFormat.format(links.slice(-basisCorrespondingToTheEigenvalue.length))) + '</p>';
                html += '</li>';
            }
            html += '</ol>';
            html += '</li>';
            html += '<li>';
            var J = matrixFromBlocks(blocks);
            var P = Matrix.fromVectors(basis);
            var P_INVERSED = P.isExact() ? P.inverse() : Expression._getInverse(A, eigenvalues, P);
            html += '<p>' + i18n.JordanDecomposition.generalizedModalMatrix.replace(/\$\{links\}/g, listFormat.format(links)) + '</p>';
            html += '<math>' + Expression.p('M=S', {
                S: new Expression.Matrix(P)
            }, printOptions) + '</math>';
            html += '<p>' + i18n.JordanDecomposition.JordanMatrix + '</p>';
            html += '<math>' + Expression.p('J=S', {
                S: new Expression.Matrix(J)
            }, printOptions) + '</math>';
            html += '</li>';
            html += '</ol>';

            //TODO: solution steps
            //var html = tmp.html;
            //html += "<div>...</div>";
            //html += "<div>" + i18n.JordanDecompositionLink + "</div>";
            var detailsHTML = "<details open=\"open\"><summary>" + i18n.misc.summaryLabel + "</summary><div class=\"indented\">" + html + "</div></details>";
            return "<math>" + new Expression.Matrix(matrix).toMathML(printOptions) + "<mo>" + (J.isExact() ? "=" : "&asymp;") + "</mo>" + "<mrow>" + new Expression.Matrix(P).toMathML(printOptions) + "<mo>&sdot;</mo>" + new Expression.Matrix(J).toMathML(printOptions) + "<mo>&sdot;</mo>" + new Expression.Matrix(P_INVERSED).toMathML(printOptions) + "</mrow>" + "</math>" + detailsHTML;
        }
    });
    //!

    function powUsingTransformationsHelper(x) {
        var pm1 = "<msup><mi>P</mi>" + Expression.ONE.negate().toMathML() + "</msup>";
        return "<munder accentunder=\"true\">" + "<munder accentunder=\"true\">" + "<mrow>" + "<mi>P</mi>" + "<mo>&sdot;</mo>" + x + "<mo>&sdot;</mo>" + "<menclose notation=\"updiagonalstrike\">" + pm1 + "</menclose>" + "<mo>&sdot;</mo>" + "<menclose notation=\"updiagonalstrike\">" + "<mi>P</mi>" + "</menclose>" + "<mo>&sdot;</mo>" + x + "<mo>&sdot;</mo>" + "<menclose notation=\"updiagonalstrike\">" + pm1 + "</menclose>" + "<mo>&sdot;</mo><mi>&hellip;</mi><mo>&sdot;</mo>" + "<menclose notation=\"updiagonalstrike\">" + "<mi>P</mi>" + "</menclose>" + "<mo>&sdot;</mo>" + x + "<mo>&sdot;</mo>" + pm1 + "</mrow>" + "<mo stretchy=\"true\">&UnderBrace;</mo>" + "</munder>" + "<mi>n</mi>" + "</munder>";
    }

    function powUsingTransformations(N) {
        return "<math>" + Expression.p("A^n") + "<mo>=</mo>" + Expression.p("(P*" + N + "*P^-1)^n") + "<mo>=</mo>" + powUsingTransformationsHelper(Expression.p(N)) + "<mo>=</mo>" + Expression.p("P*" + N + "^n*P^-1") + "</math>";
    }

    function nthRootUsingTransformations(N) {
        return "<math>" + powUsingTransformationsHelper(Expression.p(N + "**(1/n)")) + "<mo>=</mo>" + Expression.p("P*" + N + "*P^-1") + "<mo>=</mo>" + Expression.p("A") + "</math>";
    }
    Expression.Details.add({
        type: "pow-using-diagonalization",
        minRows: 2,
        callback: function(printOptions, matrix) {
            var html = '';
            html += '<div>';
            html += i18n.misc.powUsingDiagonalizationIntro;
            html += '</div>';
            html += '<div>';
            html += powUsingTransformations("D") + " " + i18n.powUsingDiagonalizationLink;
            html += '</div>';
            return html;
        }
    });

    //!new

    Expression.Details.add({
        type: "pow-using-Jordan-normal-form",
        minRows: 2,
        callback: function(printOptions, matrix) {
            var html = '';
            //TODO:...

            html += '<div>';
            html += i18n.misc.powUsingJordanNormalFormIntro;
            html += '</div>';
            html += '<div>';
            html += powUsingTransformations("J") + " " + i18n.powUsingJordanNormalFormLink;
            html += '</div>';
            var eigenvalues = Expression.getEigenvalues(matrix);
            var J = Expression.getFormaDeJordan(matrix, eigenvalues).J;
            html += '<p>' + i18n.misc.powOfJordanMatrix + '</p>';

            //html += Expression.Details.getCallback('Jordan-matrix-pow')(printOptions, matrix);
            html += Expression.Details.getCallback('DpN-matrix-pow')(printOptions, J);
            return html;
        }
    });
    Expression.Details.add({
        type: "DpN-matrix-pow",
        i18n: function() {
            //return i18n.matrixExponentiation;
            return "exponentiation";
        },
        minRows: 2,
        callback: function(printOptions, matrix) {
            var html = '';

            // Заметим, что A = D + N, где D - диагональная матрица, а N - нильпотентна, т.к. N**n = 0.
            // Также, заметим, что D*N=N*D.
            // Тогда A**n=(D+N)**n=[binomial expansion] = ...

            //TODO: ...
            html += '<p>' + i18n.dpnMatrixPow.define + '</p>';
            var D = new Expression.Matrix(matrix.map(function(e, i, j) {
                return i === j ? e : Expression.ZERO;
            }));
            var N = new Expression.Matrix(matrix.map(function(e, i, j) {
                return i !== j ? e : Expression.ZERO;
            }));
            if (!N.matrix.isNilpotent()) {
                throw new RangeError();
            }

            //TODO: share ?
            var index = 1;
            while (!N.matrix.pow(index).eql(Matrix.Zero(N.matrix.cols(), N.matrix.cols()))) {
                if (index >= N.matrix.cols()) {
                    throw new TypeError('assertion');
                }
                index += 1;
            }
            html += '<math>' + Expression.p('D=X', {
                X: D
            }, printOptions) + '</math>';
            html += ', '; //?
            html += '<math>' + Expression.p('N=X', {
                X: N
            }, printOptions) + '</math>';
            html += '<p>' + i18n.dpnMatrixPow.soThat.replaceAll('${(D+N)**n}', '<math>' + Expression.p('(D+N)**n') + '</math>') + '</p>';
            html += '<ul>';
            html += '<li>' + '<math>' + Expression.p('D*N=N*D') + '</math>' + ' — ' + i18n.dpnMatrixPow.DAndNCommute.replace(/\$\{D\}/g, '<math>' + Expression.p('D') + '</math>').replace(/\$\{N\}/g, '<math>' + Expression.p('N') + '</math>') + '</li>';
            html += '<li>' + '<math>' + Expression.p('N**' + index + '=0') + '</math>' + '</li>'; //TODO: say something about nilpotent of a triangular with zeroes on diagonal
            html += '</ul>';
            html += '<p>' + i18n.dpnMatrixPow.whichEnables + '</p>';
            html += '<math>';
            html += Expression.p('(D+N)**n');
            html += '<mo>=</mo>';
            html += '<mrow>';
            html += '<munderover accentunder="false" accent="false"><mo>∑</mo><mrow><mi>k</mi><mo>=</mo>' + Expression.p(0) + '</mrow><mi>n</mi></munderover>';
            html += '<mrow>';
            html += '<mrow><mo>(</mo><mfrac linethickness="0"><mi>n</mi><mi>k</mi></mfrac><mo>)</mo></mrow>';
            html += '<mo>&it;</mo>';
            html += Expression.p('D**(n-k)*N**k').replace(/&times;/g, '&it;');
            html += '</mrow>';
            html += '</mrow>';
            html += '<mo>=</mo>';
            var s = '';
            for (var k = 0; k < index; k += 1) {
                s += s !== '' ? '+' : '';
                var bc = '';
                for (var i = 0; i < k; i += 1) {
                    bc += i === 0 ? 'n' : '(n-' + i + ')';
                }
                var f = Expression.Integer.fromNumber(k).factorial().toBigInt();
                s += k !== 0 ? k !== 1 ? bc + '/' + f + '*' + 'D**(n-' + k + ')*N**' + k : 'n' + '*' + 'D**(n-1)*N' : 'D**n';
            }
            html += Expression.p(s).replace(/&times;/g, '&it;');
            html += '</math>';
            html += ' ';
            html += '<a href="https://math.stackexchange.com/questions/2079950/compute-the-n-th-power-of-triangular-3-times3-matrix/2079981#2079981">(*)</a>';
            return html;
        }
    });
    var outputJordanMatrix = function(n, block1Size) {
        var html = '';
        html += '<mrow>';
        html += '<mo>(</mo>';
        html += '<mtable rowspacing="0ex">';
        for (var i = 0; i < n; i += 1) {
            html += '<mtr>';
            for (var j = 0; j < n; j += 1) {
                html += '<mtd>';
                var c = undefined;
                if (i === j) {
                    c = j < block1Size ? 'λ_1' : 'λ_2';
                } else if (j === i + 1) {
                    c = j !== block1Size ? 1 : 0;
                } else {
                    c = 0;
                }
                html += Expression.p(c);
                html += '</mtd>';
            }
            html += '</mtr>';
        }
        html += '</mtable>';
        html += '<mo>)</mo>';
        html += '</mrow>';
        return html;
    };

    /*
    //TODO: remove - ?
    Expression.Details.add({
      type: "Jordan-matrix-pow",
      minRows: 2,
      callback: function (printOptions, matrix) {
        var html = '';

        html += i18n.misc.powOfJordanMatrix;
        html += '<div>';
        html += '<math>';

        // thanks to http://fred-wang.github.io/TeXZilla/
        html += '<msup>';
        html += outputJordanMatrix(5, 3);
        html += '<mi>n</mi>';
        html += '</msup>';

        html += '<mo>=</mo>';

        html += '<mrow>';
        html += '<mo>(</mo>';
        html += '<mtable rowspacing="0ex">';
        for (var i = 0; i < 5; i += 1) {
          html += '<mtr>';
          for (var j = 0; j < 5; j += 1) {
            html += '<mtd>';
            var c = i < 3 ? 1 : 2; // lambda
            if (i === j) {
              html += '<msup>' + Expression.p('λ_' + c) + '<mi>n</mi></msup>';
            } else if (i < j && (j < 3 || i >= 3)) {
              var m = j < 3 ? j - i : j - 3;
              var binomialCoefficient = '<mrow><mo>(</mo><mfrac linethickness="0"><mi>n</mi>' + Expression.p(m) + '</mfrac><mo>)</mo></mrow>';
              html += binomialCoefficient;
              html += '<mo>&it;</mo>';
              html += '<msup>' + Expression.p('λ_' + c) + '<mrow><mi>n</mi><mo>&minus;</mo>' + Expression.p(m) + '</mrow></msup>';
            } else {
              html += Expression.p(0);
            }
            html += '</mtd>';
          }
          html += '</mtr>';
        }
        html += '</mtable>';
        html += '<mo>)</mo>';
        html += '</mrow>';

        html += '</math>';
        html += ' ';
        html += i18n.blockOfJordanPowerFormulaLink;
        html += '</div>';
        return html;
      }
    });

    */

    Expression.Details.add({
        type: "Jordan-matrix-nth-root",
        minRows: 2,
        callback: function(printOptions, matrix) {
            var html = '';
            html += i18n.misc.nthRootOfJordanMatrix;
            html += '<div>';
            html += '<math>';

            // thanks to http://fred-wang.github.io/TeXZilla/
            html += '<msup>';
            html += outputJordanMatrix(6, 4);
            html += '<mfrac>' + Expression.p(1) + '<mi>n</mi></mfrac>'; //!
            html += '</msup>';
            html += '<mo>=</mo>';
            html += '<mrow>';
            html += '<mo>(</mo>';
            html += '<mtable rowspacing="0ex">';
            for (var i = 0; i < 6; i += 1) {
                html += '<mtr>';
                for (var j = 0; j < 6; j += 1) {
                    html += '<mtd>';
                    var c = i < 4 ? 1 : 2; // lambda
                    if (i === j) {
                        html += '<msup><mi>λ</mi><mrow><mo>(</mo><mrow>' + Expression.p(1) + '<mo>&#x2215;</mo><mi>n</mi></mrow><mo>)</mo></mrow></msup>'; //!
                    } else if (i < j && (j < 4 || i >= 4)) {
                        var m = j < 4 ? j - i : j - 4;

                        // (1-n)(1-2n)(1-3n)/(4!*n**4) * 1/λ**m * λ**(1/n)
                        var s = '';
                        if (m > 1) {
                            for (var k = 1; k < m; k += 1) {
                                s += '(1-' + (k === 1 ? '' : k) + 'n)';
                            }
                            s += '/(' + m + '!' + 'n**' + m + ')';
                        } else {
                            s += '1/n';
                        }
                        s += '*(λ**(1/n)/λ' + (m !== 1 ? '**' + m : '') + ')';
                        html += Expression.p(s).replace(/&times;/g, '&it;'); //TODO:
                    } else {
                        html += Expression.p(0);
                    }
                    html += '</mtd>';
                }
                html += '</mtr>';
            }
            html += '</mtable>';
            html += '<mo>)</mo>';
            html += '</mrow>';
            html += '</math>';
            html += ' ';
            html += i18n.blockOfJordanPowerFormulaLink;
            html += '</div>';
            return html;
        }
    });
    Expression.Details.add({
        type: "nth-root-using-diagonalization",
        minRows: 2,
        callback: function(printOptions, matrix) {
            var html = '';
            html += '<div>' + i18n.misc.ifXisARootOfAMatrixInDiagonalFormThen.replaceAll('${D^(1/n)}', Expression.p('D^(1/n)')) + '</div>';
            html += nthRootUsingTransformations("D") + " " + i18n.nthRootUsingDiagonalizationLink;
            html += '<div>' + i18n.misc.thisMeansThatXIsANthRootOfTheMatrix.replaceAll('${P*J^(1/n)*P^-1}', Expression.p('P*J^(1/n)*P^-1')).replace(/<mi>J<\/mi>/g, '<mi>D</mi>') + '</div>';
            return html;
        }
    });
    Expression.Details.add({
        type: "nth-root-using-Jordan-normal-form",
        minRows: 2,
        callback: function(printOptions, matrix) {
            //TODO: change the link (?), tests - ?
            //TODO: some text explaining, that J - is a matrix in Jordan normal form, P - is a Generalized Nodal Matrix

            var html = "";
            html += '<div>' + i18n.misc.ifXisARootOfAMatrixInJordanNormalFormThen.replaceAll('${J^(1/n)}', Expression.p('J^(1/n)')) + '</div>';
            html += nthRootUsingTransformations("J") + " " + (i18n.nthRootUsingJordanNormalFormLink || i18n.nthRootUsingDiagonalizationLink);
            html += '<div>' + i18n.misc.thisMeansThatXIsANthRootOfTheMatrix.replaceAll('${P*J^(1/n)*P^-1}', Expression.p('P*J^(1/n)*P^-1')) + '</div>';
            // The nth-root of a Jordan normal form can be found by using the formula:
            //TODO: formula
            html += Expression.Details.getCallback('Jordan-matrix-nth-root')(printOptions, matrix);
            return html;
        }
    });
    Expression.Details.add({
        type: "exponential-using-Jordan-canonical-form",
        minRows: 2,
        i18n: function() {
            return i18n.vectors.matrixExponential; //use cases -?
        },

        callback: function(printOptions, matrix) {
            //TODO: when the matrix is already diagonal, when the matrix is a [projection matrix](https://en.wikipedia.org/wiki/Matrix_exponential#Projection_case)
            //  Expression.Details.getCallback("exponential-using-Jordan-canonical-form")({}, RPN("{{0,1,0},{0,1,0},{0,0,0}}").matrix);

            var diagonalCase = function(name, expD) {
                var html = '';
                html += '<h4>' + i18n.exponential.findTheExponentialOfTheDiagonalMatrixD.replace(/\$\{D\}/g, '<math>' + Expression.p(name) + '</math>') + '</h4>';
                html += '<div>';
                html += i18n.exponential.exponentialOfDiagonalMatrix;
                html += '</div>';
                html += '<div>';
                html += '<math>' + Expression.p('e**' + name + '=M', {
                    M: expD
                }, printOptions) + '</math>';
                html += '</div>';
                return html;
            };
            var nilpotentCase = function(N, expN) {
                var html = '';
                html += '<h4>' + i18n.exponential.findTheExponentialOfTheNilpotentMatrixN.replace(/\$\{N\}/g, '<math><mi>N</mi></math>') + '</h4>';
                html += '<div>';
                // \u22EF == &hellip;
                html += '<math>' + Expression.p('e**N=I+N+1/2*N**2+1/6*N**3+a+1/f*N**k').replace(/<mi>a<\/mi>/g, '<mi>&hellip;</mi>').replace(/<mi>f<\/mi>/g, '<mrow><mi>k</mi><mo>!</mo></mrow>') + '</math>' + ' ' + i18n.exponentialOfNilpotentMatrixLink + i18n.colonSpacing + ':';
                html += '</div>';
                //TODO: steps
                html += '<div>';
                var M = N;
                var k = 1;
                while (!M.eql(Matrix.Zero(M.rows(), M.cols()))) {
                    M = M.multiply(M);
                    k += 1;
                    if (k > 2) {
                        html += '; '; //?
                    }

                    html += '<math>' + Expression.p('N**' + k + '=M', {
                        A: new Expression.Matrix(N),
                        M: new Expression.Matrix(M)
                    }, printOptions) + '</math>';
                }
                html += '</div>';
                html += '<div>';
                html += '<math>' + Expression.p('e**N=M', {
                    M: expN
                }, printOptions) + '</math>';
                html += '</div>';
                return html;
            };
            if (matrix.isDiagonal()) {
                var expD = new Expression.Matrix(matrix).exp();
                var html = '';
                html += diagonalCase('D', expD);
                return html;
            }
            //TODO: The characteristic polynomial for N is det(xI-N)=x^{n}
            if (matrix.isNilpotent()) {
                var expN = new Expression.Matrix(matrix).exp();
                var html = '';
                html += '<h3>' + i18n.exponential.theMatrixIsNilpotent + '</h3>';
                html += nilpotentCase(matrix, expN);
                return html;
            }
            var A = matrix;
            var eigenvalues = Expression.getEigenvalues(A);
            var tmp = Expression.getFormaDeJordan(A, eigenvalues);
            var D = tmp.J.map(function(e, i, j) {
                return i === j ? e : Expression.ZERO;
            });
            var N = tmp.J.map(function(e, i, j) {
                return i !== j ? e : Expression.ZERO;
            });
            var expN = new Expression.Matrix(N).exp().matrix; //TODO: ?
            var expJmN = D.map(function(e, i, j) {
                return i === j ? e.exp() : Expression.ZERO;
            });
            var expA = tmp.P.multiply(expJmN).multiply(expN).multiply(tmp.P_INVERSED);
            var data = {
                A: A,
                P: tmp.P,
                J: tmp.J,
                P_INVERSED: tmp.P_INVERSED,
                N: N,
                JmN: D,
                expN: expN,
                expJmN: expJmN,
                expA: expA
            };
            for (var i in data) {
                if (Object.prototype.hasOwnProperty.call(data, i)) {
                    data[i] = new Expression.Matrix(data[i]);
                }
            }
            var html = '';
            html += '<h3>' + i18n.exponential.exponentialUsingJordanCanonicalForm + '</h3>';
            html += '<math>' + Expression.p('exp(A)=exp(P*J*P^-1)=P*exp(J-N)*exp(N)*P^-1') + '</math>';
            // data.P
            // data.J
            // data.P_INVERSED
            // data.N
            // data.JmN
            // data.expN
            // data.expJmN
            // data.expA

            // 1. Find a matrix in Jordan normal form:
            //   ...
            //   A = P*J*P**(-1) = X*Y*Z
            // 2. Then:
            //   N = M, J-N = M
            // 3. Find the exponential of the Nilpotent matrix (N):
            //   e**N=I+N+1/2*N**2+1/6*N**3+...+1(q-1)!*N**(q-1) (*)[https://en.wikipedia.org/wiki/Matrix_exponential#Nilpotent_case]:
            // ...
            // 4. Find the exponential of the diagonal matrix (J-N):
            //   Exponential can be obtained by exponentiating each entry on the main diagonal (*)[https://en.wikipedia.org/wiki/Matrix_exponential#Diagonalizable_case]:
            //   exp(J-N)=M
            // 5. Then:
            //   exp(A)=X*Y=Z

            html += '<ol>';
            html += '<li>';
            html += '<h3>' + i18n.exponential.findAMatrixInJordanNormalForm + '</h3>';
            html += createDetailsSummary(printOptions.idPrefix, [{
                type: "Jordan-decomposition",
                matrix: matrix.toString(),
                second: undefined
            }]);
            html += '<div>';
            html += '<math>' + Expression.p('A=P*J*P**(-1)') + '</math>' + ':';
            html += '</div>';
            html += '<div>';
            html += '<math>' + Expression.p('A=P*J*V', {
                A: data.A,
                P: data.P,
                J: data.J,
                V: data.P_INVERSED
            }, printOptions) + '</math>';
            html += '</div>';
            html += '</li>';
            html += '<li>';
            html += '<h4>' + i18n.exponential.then + '</h4>';
            html += '<div>';
            html += '<math>' + Expression.p('N=M', {
                M: data.N
            }, printOptions) + '</math>';
            html += ', ';
            html += '<math>' + Expression.p('J-N=M', {
                M: data.JmN
            }, printOptions) + '</math>';
            html += '</div>';
            html += '</li>';
            html += '<li>';
            //TODO: when matrix is diagonalizable (?)
            html += nilpotentCase(data.N.matrix, data.expN);
            html += '</li>';
            html += '<li>';
            html += diagonalCase('(J-N)', data.expJmN);
            html += '</li>';
            html += '<li>';
            html += '<h4>' + i18n.exponential.then + '</h4>';
            html += '<div>';
            html += '<math>' + Expression.p('exp(A)=P*X*Y*V=M', {
                A: data.A,
                P: data.P,
                X: data.expJmN,
                Y: data.expN,
                V: data.P_INVERSED,
                M: data.expA
            }, printOptions) + '</math>';
            html += '</div>';
            html += '</li>';
            html += '</ol>';

            //TODO:...
            return html;
        }
    });
    Expression.Details.add({
        type: "logarithm-using-diagonalization",
        minRows: 2,
        i18n: function() {
            return i18n.misc.calculatingTheLogarithmOfADiagonalizableMatrix;
        },
        callback: function(printOptions, matrix) {
            //TODO: ?
            return i18n.calculatingTheLogarithmOfADiagonalizableMatrixLink;
        }
    });
    Expression.Details.add({
        type: "logarithm-using-Jordan-canonical-form",
        minRows: 2,
        i18n: function() {
            return i18n.theLogarithmOfANonDiagonalizableMatrix;
        },
        callback: function(printOptions, matrix) {
            //TODO: ?
            return i18n.theLogarithmOfANonDiagonalizableMatrixLink;
        }
    });
    var getAdjugateByDefinition = function(printOptions, matrix) {
        var result = "";
        var cofactors = new Array(matrix.rows());
        for (var i = 0; i < matrix.rows(); i += 1) {
            cofactors[i] = new Array(matrix.cols());
            for (var j = 0; j < matrix.cols(); j += 1) {
                result += "<div>"; // TODO: <ul> - ?
                result += "<math>";
                result += Expression.p('C_(' + (i + 1) + ',' + (j + 1) + ')');
                result += '<mo>=</mo>';
                result += '<mrow>';
                result += Expression.p("(-1)^(i+j)", {
                    i: Expression.Integer.fromNumber(i + 1),
                    j: Expression.Integer.fromNumber(j + 1)
                }, printOptions);
                result += "<mo>&sdot;</mo>";
                result += new Expression.Minor(new Expression.Matrix(matrix), i, j).toMathML(printOptions);
                result += '</mrow>';
                var minorMatrix = matrix.minorMatrix(i, j);
                var minor = minorMatrix.determinant();
                var isOdd = i + j - 2 * Math.floor((i + j) / 2);
                var n = isOdd === 1 ? Expression.ONE.negate() : Expression.ONE;
                var c = n.multiply(minor);
                if (minorMatrix.rows() === 2) {
                    //!
                    result += "<munder accentunder=\"true\"><mo>=</mo><mtext>" + i18n.determinant2x2Link + "</mtext></munder>";
                    result += Expression.p("n*(a*d-b*c)", {
                        n: n,
                        a: minorMatrix.e(0, 0),
                        b: minorMatrix.e(0, 1),
                        c: minorMatrix.e(1, 0),
                        d: minorMatrix.e(1, 1)
                    }, printOptions);
                }
                if (isOdd === 1) {
                    result += "<mo>=</mo>";
                    result += Expression.p("n*(d)", {
                        n: n,
                        d: minor
                    }, printOptions);
                }
                result += "<mo>=</mo>";
                result += Expression.p("c", {
                    c: c
                }, printOptions);
                result += "</math>";
                if (minorMatrix.rows() !== 2) {
                    //!
                    result += createDetailsSummary(printOptions.idPrefix, [{
                        type: minorMatrix.getDeterminantEventType("determinant").type,
                        matrix: minorMatrix.toString(),
                        second: undefined
                    }]);
                }
                cofactors[i][j] = c;
                result += "</div>";
            }
        }
        var CT = new Expression.Matrix(new Matrix(cofactors).transpose());
        return {
            result: result,
            CT: CT
        };
    };
    Expression.Details.add({
        type: "adjugate-by-definition",
        i18n: undefined,
        minRows: 2,
        //?
        priority: -1,
        callback: function(printOptions, matrix) {
            var tmp = getAdjugateByDefinition(printOptions, matrix);
            var result = tmp.result;
            var CT = tmp.CT;
            result += "<div>";
            result += "<math>";
            result += Expression.p("adjugate(A)=C^T=Y", {
                A: new Expression.Matrix(matrix),
                Y: CT
            }, printOptions);
            result += "</math>";
            result += " ";
            result += i18n.adjugateMatrixLink; //TODO:
            result += "</div>";
            return result;
        }
    });
    Expression.Details.add({
        type: "inverse-adjugate",
        i18n: function() {
            return i18n.inverse.inverseDetailsUsingAdjugateMatrix;
        },
        minRows: 3,
        priority: -1,
        callback: function(printOptions, matrix) {
            var result = "";
            result += "<div>";
            result += "<math>";
            result += Expression.p("A^-1=1/determinant(A)*C^T=1/determinant(A)*X", {
                X: new Expression.Matrix(matrix.map(function(e, i, j) {
                    return new Expression.Symbol('C_(' + (j + 1) + ',' + (i + 1) + ')');
                }))
            }, printOptions);
            result += "</math>";
            result += " ";
            result += i18n.inverseDetailsUsingAdjugateMatrixLink; //TODO
            result += "</div>";
            // https://upload.wikimedia.org/math/e/f/0/ef0d68882204598592f50ba054e9951e.png
            var determinant = matrix.determinant();
            result += "<div>";
            result += "<math>";
            result += Expression.p("determinant(A)=X=y", {
                X: new Expression.Determinant(new Expression.Matrix(matrix)),
                y: determinant
            }, printOptions);
            result += "</math>";
            result += createDetailsSummary(printOptions.idPrefix, [{
                type: matrix.getDeterminantEventType("determinant").type,
                matrix: matrix.toString(),
                second: undefined
            }]);
            result += "</div>";
            if (determinant.equals(Expression.ZERO)) {
                //TODO: ?
            } else {
                //!
                var tmp = getAdjugateByDefinition(printOptions, matrix);
                result += tmp.result;
                var CT = tmp.CT;
                // TODO: linkes
                // http://en.wikipedia.org/wiki/Cramer%27s_rule#Finding_inverse_matrix
                result += "<div>";
                result += "<math>";
                result += Expression.p("A^-1=1/determinant(A)*C^T=1/x*Y=Z", {
                    x: determinant,
                    Y: CT,
                    Z: determinant.inverse().multiply(CT)
                }, printOptions);
                result += "</math>";
                result += "</div>";
            }
            return result;
        }
    });

    // new Intl.NumberFormat("it-u-nu-roman").format(n);
    var roman = function(n) {
        var digits = "IVXLCDM";
        var i = digits.length + 1;
        var result = "";
        var value = 1000;
        while ((i -= 2) >= 0) {
            var v = Math.floor(value / 10);
            var j = -1;
            while (++j < 2) {
                while (n >= value) {
                    n -= value;
                    result += digits.slice(i - j, i - j + 1);
                }
                value -= v;
                while (n >= value) {
                    n -= value;
                    result += digits.slice(i - 2, i - 2 + 1) + digits.slice(i - j, i - j + 1);
                }
                value -= 4 * v;
            }
            value = v;
        }
        return result;
    };

    // use default locale (as it may be better for the end user and numbering system can depend on the region)
    // TODO: localeString() outside of MathML, Expression.p() in mscript.js for <mn>_number_</mn>

    var numberFormat1 = null;
    var initNumberFormat = function(event) {
        Expression.numberFormat = {
            format: function(number) {
                // lazy initialization
                if (numberFormat1 == null) {
                    numberFormat1 = new Intl.NumberFormat(undefined, {
                        useGrouping: false
                    });
                }
                return numberFormat1.format(number);
            }
        };
    };
    globalThis.addEventListener('languagechange', initNumberFormat);
    initNumberFormat();
    var numberFormat = null;
    globalThis.addEventListener('languagechange', function(event) {
        numberFormat = null;
    });
    var localeString = function(number) {
        console.assert(Math.floor(number) === number && number >= 0 && number <= Number.MAX_SAFE_INTEGER);
        if (numberFormat == null) {
            numberFormat = new Intl.NumberFormat(undefined, {
                useGrouping: false
            });
        }
        return numberFormat.format(number);
    };

    //TODO: remove
    var getMatrixRowDenotation = function(i) {
        return i18n.matrixRowDenotation.replace(/\$\{i\}/g, localeString(i)).replace(/\$\{i\:roman\}/g, roman(i));
    };
    Matrix.prototype.getDeterminantEventType = function(base) {
        for (var i = 0; i < this.rows(); i += 1) {
            var isZero = true;
            for (var j = 0; j < this.cols(); j += 1) {
                var e = this.e(i, j);
                if (!e.equals(Expression.ZERO)) {
                    isZero = false;
                }
            }
            if (isZero) {
                return {
                    type: "special-determinant",
                    row: i,
                    col: -1
                };
            }
        }
        for (var j = 0; j < this.cols(); j += 1) {
            var isZero = true;
            for (var i = 0; i < this.rows(); i += 1) {
                var e = this.e(i, j);
                if (!e.equals(Expression.ZERO)) {
                    isZero = false;
                }
            }
            if (isZero) {
                return {
                    type: "special-determinant",
                    row: -1,
                    col: j
                };
            }
        }
        return {
            type: base,
            row: -1,
            col: -1
        };
    };

    //!new
    Expression.Details.add({
        type: "special-determinant",
        i18n: undefined,
        priority: 1 / 0,
        minRows: 1,
        //TODO: add a test
        callback: function(printOptions, matrix) {
            var html = "";
            var x = matrix.getDeterminantEventType();
            html += "<div>";
            html += "<math>";
            html += new Expression.Determinant(new Expression.Matrix(matrix)).toMathML(Object.assign({}, printOptions, {
                highlightRow: x.row !== -1 ? x.row : undefined,
                highlightCol: x.col !== -1 ? x.col : undefined
            }));
            html += "<mo>=</mo>";
            html += Expression.p(0);
            html += "</math>";
            if (x.row !== -1 || x.col !== -1) {
                html += "<div>" + i18n.determinant.zeroRowColumn + "</div>";
            }
            html += "</div>";
            return html;
        }
    });
    Expression.Details.add({
        type: "add",
        i18n: function() {
            return i18n.add.matrixAddition;
        },
        minRows: 2,
        callback: function(printOptions, matrixA, matrixB) {
            return "<p>" + i18n.add.matrixAdditionInfo + "</p>" + getMatrixOperationDetails(printOptions, matrixA, matrixB, function(a, b) {
                return a.add(b);
            }, "+");
        }
    });
    Expression.Details.add({
        type: "multiply",
        i18n: function() {
            return i18n.multiply.matrixMultiplication;
        },
        minRows: 2,
        callback: function(printOptions, matrixA, matrixB) {
            return "<p>" + i18n.multiply.matrixMultiplicationInfo + "</p>" + getMatrixOperationDetails(printOptions, matrixA, matrixB, function(a, b) {
                return a.multiply(b);
            }, "&sdot;");
        }
    });
    Expression.Details.add({
        type: "trigonometric-function-of-inverse-trigonometric-function-arg",
        minRows: 1,
        maxRows: 1,
        callback: function(printOptions) {
            //TODO:
            var a = "https://www.rapidtables.com/math/trigonometry/arctan.html#rules";
            var b = "https://en.wikipedia.org/wiki/Inverse_trigonometric_functions#Relationships_between_trigonometric_functions_and_inverse_trigonometric_functions";
            return "see " + a.link(a) + ' and ' + b.link(b);
        }
    });

    function getMatrixOperationDetails(printOptions, matrixA, matrixB, operationFunction, operator) {
        var html = "";
        //TODO: Should matrixA and matrixB already have NonSimplifiedExpressions-elements ???
        var matrixAn = matrixA.map(function(e, i, j) {
            return new NonSimplifiedExpression(e);
        });
        var matrixBn = matrixB.map(function(e, i, j) {
            return new NonSimplifiedExpression(e);
        });
        var matrixAB = operationFunction(matrixAn, matrixBn);
        var result = matrixAB.map(function(e, i, j) {
            return e.simplify();
        });
        html += "<math>";
        html += "<mrow>";
        html += new Expression.Matrix(matrixAn).toMathML(Object.assign({}, printOptions, {
            cellIdGenerator: function(i, j) {
                return matrixAn.e(i, j).getId();
            }
        }));
        html += "<mo>" + operator + "</mo>";
        html += new Expression.Matrix(matrixBn).toMathML(Object.assign({}, printOptions, {
            cellIdGenerator: function(i, j) {
                return matrixBn.e(i, j).getId();
            }
        }));
        html += "</mrow>";
        html += "<mo>=</mo>";
        html += new Expression.Matrix(matrixAB).toMathML(Object.assign({}, printOptions, {
            cellIdGenerator: function(i, j) {
                return matrixAB.e(i, j).getId();
            }
        }));
        html += "<mo>=</mo>";
        html += new Expression.Matrix(result).toMathML(printOptions);
        html += "</math>";
        //TODO: highlight of "same" expression elements, when mouseover an element of matrixAB or matrixA or matrixB
        matrixAB.map(function(e, i, j) {
            html += "<a class=\"a-highlight\" data-for=\"" + e.getId().toString() + "\" data-highlight=\"" + e.unwrap().getIds() + "\"></a>";
            return e;
        });
        return html;
    }
    Expression.Details.add({
        type: "pow",
        i18n: function() {
            return i18n.multiply.matrixMultiplication;
        },
        minRows: 1,
        callback: function(printOptions, matrix, second) {
            var n = Number(second.e(0, 0).toString());
            // n >= 1 (?)
            var i = 0;
            var c = 1;
            var t = [];
            t.push(matrix);
            var html = "<ul>";
            html += "<li>";
            html += "<math>";
            html += Expression.p("A") + "<mo>=</mo>" + new Expression.Matrix(t[i]).toMathML(printOptions);
            html += "</math>";
            html += "</li>";
            while (c * 2 <= n) {
                c *= 2;
                t.push(t[i].multiply(t[i]));
                html += "<li>";
                html += "<math>";
                html += Expression.p("A^" + c) + "<mo>=</mo>" + Expression.p("A^" + Math.floor(c / 2) + "*" + "A^" + Math.floor(c / 2)) + "<mo>=</mo>" + new Expression.Matrix(t[i + 1]).toMathML(printOptions);
                html += "</math>";
                html += "</li>";
                i += 1;
            }
            html += "</ul>";
            var result = undefined;
            var r = undefined;
            var nn = n;
            while (i !== -1 && nn !== 0) {
                if (nn >= c) {
                    nn -= c;
                    result = result == undefined ? t[i] : result.multiply(t[i]);
                    var z = new Expression.NonSimplifiedExpression(new Expression.Symbol("A").pow(Expression.Integer.fromNumber(c)));
                    r = r == undefined ? z : r.multiply(z);
                }
                c = Math.floor(c / 2);
                i -= 1;
            }
            html += "<math>";
            html += Expression.p("A^" + n) + "<mo>=</mo>" + r.toMathML(printOptions) + "<mo>=</mo>" + new Expression.Matrix(result).toMathML(printOptions);
            html += "</math>";
            return html;
        }
    });
    Expression.someDetailsNew = {
        "determinant2x2": "<span data-custom-paint=\"custom-menclose\" data-color=\"0a\" data-cells=\"[[0,0],[1,1]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1a\" data-cells=\"[[0,1],[1,0]]\"><math><mrow><mo>|</mo><mtable rowspacing=\"0ex\"><mtr><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd></mtr><mtr><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd></mtr></mtable><mo>|</mo></mrow><mo>=</mo><mrow><mrow mathcolor=\"#D64040\"><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mrow><mo>&minus;</mo><mrow mathcolor=\"#4040D6\"><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mrow></mrow></math></span></span>${link}",
        "determinant3x3": "<math><mrow><mo>|</mo><mtable rowspacing=\"0ex\"><mtr><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mtd></mtr><mtr><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mtd></mtr><mtr><mtd><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mtd></mtr></mtable><mo>|</mo></mrow></math><math><mo>=</mo></math>",
        "matrix3x3": "<math><mtable rowspacing=\"0ex\"><mtr><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mtd></mtr><mtr><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mtd></mtr><mtr><mtd><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mtd></mtr></mtable></math>",
        "determinantTriangle": "${determinant3x3}<table class=\"some-details-table\"><tr><td><math><mrow><mo>+</mo><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mrow><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></math></td><td><span data-custom-paint=\"custom-menclose\" data-color=\"0a\" data-cells=\"[[0,0],[1,1],[2,2]]\">${matrix3x3}</span></td></tr><tr><td><math><mrow><mo>+</mo><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mrow><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>3</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></math></td><td><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,0],[1,1],[2,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0a\" data-cells=\"[[0,1],[1,2],[2,0]]\">${matrix3x3}</span></span></td></tr><tr><td><math><mrow><mo>+</mo><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mrow><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></math></td><td><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,0],[1,1],[2,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,1],[1,2],[2,0]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0a\" data-cells=\"[[0,2],[1,0],[2,1]]\">${matrix3x3}</span></span></span></td></tr><tr><td><math><mrow><mo>&minus;</mo><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mrow><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></math></td><td><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,0],[1,1],[2,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,1],[1,2],[2,0]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,2],[1,0],[2,1]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1a\" data-cells=\"[[2,0],[1,1],[0,2]]\">${matrix3x3}</span></span></span></span></td></tr><tr><td><math><mrow><mo>&minus;</mo><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mrow><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>3</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></math></td><td><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,0],[1,1],[2,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,1],[1,2],[2,0]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,2],[1,0],[2,1]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1\" data-cells=\"[[2,0],[1,1],[0,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1a\" data-cells=\"[[2,1],[1,2],[0,0]]\">${matrix3x3}</span></span></span></span></span></td></tr><tr><td><math><mrow><mo>&minus;</mo><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mrow><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></math>${link}</td><td><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,0],[1,1],[2,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,1],[1,2],[2,0]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,2],[1,0],[2,1]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1\" data-cells=\"[[2,0],[1,1],[0,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1\" data-cells=\"[[2,1],[1,2],[0,0]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1a\" data-cells=\"[[2,2],[1,0],[0,1]]\">${matrix3x3}</span></span></span></span></span></span></td></tr></table>",
        "matrix5x3": "<math><mtable rowspacing=\"0ex\" columnlines=\"none none dashed none\"><mtr><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mtd><mtd mathcolor=\"#808080\"><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd mathcolor=\"#808080\"><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd></mtr><mtr><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mtd><mtd mathcolor=\"#808080\"><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd mathcolor=\"#808080\"><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd></mtr><mtr><mtd><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mtd><mtd mathcolor=\"#808080\"><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd mathcolor=\"#808080\"><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd></mtr></mtable></math>",
        "determinantSarrus": "${determinant3x3}<table class=\"some-details-table\"><tr><td><math><mrow><mrow><mo>+</mo><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mrow><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mrow><mo>+</mo><mrow><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>3</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mrow><mo>+</mo><mrow><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>3</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mrow></math></td><td><span data-custom-paint=\"custom-menclose\" data-color=\"0a\" data-cells=\"[[0,0],[1,1],[2,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0a\" data-cells=\"[[0,1],[1,2],[2,3]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0a\" data-cells=\"[[0,2],[1,3],[2,4]]\">${matrix5x3}</span></span></span></td></tr><tr><td><math><mrow><mrow><mo>&minus;</mo><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mrow><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mrow><mo>&minus;</mo><mrow><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>3</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mrow><mo>&minus;</mo><mrow><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mrow></math>${link}</td><td><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,0],[1,1],[2,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,1],[1,2],[2,3]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,2],[1,3],[2,4]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1a\" data-cells=\"[[0,2],[1,1],[2,0]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1a\" data-cells=\"[[0,3],[1,2],[2,1]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1a\" data-cells=\"[[0,4],[1,3],[2,2]]\">${matrix5x3}</span></span></span></span></span></span></td></tr></table>",
        "someDetails3": "<span data-custom-paint=\"custom-menclose\" data-color=\"0a\" data-cells=\"[[0,0],[2,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1a\" data-cells=\"[[0,2],[2,0]]\"><math><mtable rowspacing=\"0ex\"><mtr><mtd><mrow style=\"font-weight: bolder\"><menclose notation=\"circle\"><msub><mi>a</mi><mrow><mi>r</mi><mo>,</mo><mi>c</mi></mrow></msub></menclose></mrow></mtd><mtd><mtext>&hellip;</mtext></mtd><mtd><msub><mi>a</mi><mrow><mi>r</mi><mo>,</mo><mi>j</mi></mrow></msub></mtd></mtr><mtr><mtd><mtext>&vellip;</mtext></mtd><mtd></mtd><mtd><mtext>&vellip;</mtext></mtd></mtr><mtr><mtd><msub><mi>a</mi><mrow><mi>i</mi><mo>,</mo><mi>c</mi></mrow></msub></mtd><mtd><mtext>&hellip;</mtext></mtd><mtd><msub><mi>a</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></mtd></mtr></mtable></math></span></span>",
        "": ""
    };
    Expression.getSomeDetails = function(id) {
        var s = Expression.someDetailsNew[id];
        return s.replace(/\$\{determinant3x3\}/g, Expression.someDetailsNew.determinant3x3).replace(/\$\{matrix3x3\}/g, Expression.someDetailsNew.matrix3x3).replace(/\$\{matrix5x3\}/g, Expression.someDetailsNew.matrix5x3).replace(/\<mn>(\d+)\<\/mn>/g, function(p, digits) {
            return Expression.p(Number(digits));
        });
    };
    Expression.Details.add({
        type: "inverse-2x2",
        i18n: undefined,
        minRows: 2,
        maxRows: 2,
        callback: function(printOptions, matrix) {
            var html = "";
            html += "<div>";
            html += i18n.inverse.inverse2x2;
            html += " ";
            html += "<math>";
            html += Expression.p("A^-1={{a, b}, {c, d}}^-1=1/determinant(A)*{{C_11, C_21}, {C_12, C_22}}=1/(a*d-b*c)*{{d, -b}, {-c, a}}");
            html += "</math>";
            html += i18n.inverse2x2Link;
            html += "</div>";
            var det = matrix.e(0, 0).multiply(matrix.e(1, 1)).subtract(matrix.e(0, 1).multiply(matrix.e(1, 0)));
            // TODO: highlight (?)
            html += "<math>";
            html += Expression.p("A^-1=1/(a*d-b*c)*{{d, n}, {m, a}}" + (det.equals(Expression.ZERO) ? "=1/0*{{d, n}, {m, a}}" : "=t"), {
                A: new Expression.Matrix(matrix),
                a: matrix.e(0, 0),
                b: matrix.e(0, 1),
                c: matrix.e(1, 0),
                d: matrix.e(1, 1),
                n: matrix.e(0, 1).negate(),
                m: matrix.e(1, 0).negate(),
                t: det.equals(Expression.ZERO) ? undefined : new Expression.Matrix(matrix.inverse())
            }, printOptions);
            html += "</math>";
            return html;
        }
    });
    Expression.Details.add({
        type: "determinant-2x2",
        i18n: undefined,
        minRows: 2,
        maxRows: 2,
        callback: function(printOptions, matrix) {
            var html = "<div>" + Expression.getSomeDetails("determinant2x2", printOptions).replace(/\$\{link\}/g, i18n.determinant2x2Link) + "</div>";
            var determinantResult = matrix.e(0, 0).multiply(matrix.e(1, 1)).subtract(matrix.e(0, 1).multiply(matrix.e(1, 0)));
            html += "<math>";
            html += Expression.p("determinant(A)=a*d-b*c=r", {
                A: new Expression.Matrix(matrix),
                a: matrix.e(0, 0),
                b: matrix.e(0, 1),
                c: matrix.e(1, 0),
                d: matrix.e(1, 1),
                r: determinantResult
            }, printOptions);
            html += "</math>";
            return html;
        }
    });

    // ---------------------------------------- determinant -----------------------------------------------

    var getDeterminant = function(matrix, k, r, z, coefficient) {
        if (matrix.cols() === 1) {
            return coefficient.multiply(matrix.e(0, 0));
        }
        var o = Expression.ZERO;
        for (var i = 0; i < matrix.cols(); i += 1) {
            // complement matrix for element e(i, k)
            var mx = matrix.minorMatrix(i, k);
            var e = matrix.e(i, k);
            var kk = coefficient.multiply(Expression.ONE.negate().pow((i + k) % 2 !== 0 ? Expression.ONE : Expression.ZERO).multiply(e));
            r.push({
                m: mx,
                a: kk,
                z: z,
                minor: new Expression.Minor(new Expression.Matrix(matrix), i, k),
                e: e
            });
            o = o.add(getDeterminant(mx, 0, r, z + 1, kk));
        }
        return o;
    };
    Expression.expandDeterminant = function(matrix, byRow, number, printOptions) {
        //TODO: highlight same elements
        var r = [];
        var k = Number(number.toString()) - 1;

        //!
        if (!matrix.isSquare()) {
            throw new RangeError("NonSquareMatrixException");
        }
        if (k >= matrix.rows() || k < 0 || k !== Math.floor(k)) {
            // matrix.isSquare() === true
            throw new RangeError("IntegerInputError" + ":" + (byRow ? "rowNumber" : "columnNumber"));
        }
        //!

        var result = null;
        if (byRow) {
            // expansion by row k
            result = getDeterminant(matrix.transpose(), k, r, 1, Expression.ONE);
            var l = -1;
            while (++l < r.length) {
                r[l].m = r[l].m.transpose();
                r[l].minor = new Expression.Minor(new Expression.Matrix(r[l].minor.a.matrix.transpose()), r[l].minor.j, r[l].minor.i);
            }
        } else {
            result = getDeterminant(matrix, k, r, 1, Expression.ONE); // expansion by column k
        }

        var html = "";
        html += "<math>";
        html += new Expression.Determinant(new Expression.Matrix(matrix)).toMathML(printOptions);
        html += "<mo>=</mo>";
        var z = matrix.cols() - 1;
        for (var i = 1; i < z; i += 1) {
            var e = "";
            for (var j = 0; j < r.length; j += 1) {
                if (r[j].z === i && !r[j].a.equals(Expression.ZERO)) {
                    var det = new Expression.Determinant(new Expression.Matrix(r[j].m));
                    var current = new Expression.Multiplication(new NonSimplifiedExpression(r[j].a), det);
                    if (e !== "") {
                        e += "<mo>+</mo>";
                    }
                    if (i !== 1) {
                        e += current.toMathML(printOptions);
                    } else {
                        e += Expression.p("(-1)**(i+j)*e*A", {
                            i: Expression.Integer.fromNumber(r[j].minor.i + 1),
                            j: Expression.Integer.fromNumber(r[j].minor.j + 1),
                            e: r[j].e,
                            A: r[j].minor
                        }, printOptions);
                    }
                }
            }
            if (e != undefined) {
                // all zeros
                html += "<mrow>";
                html += e;
                html += "</mrow>";
                html += "<mo>=</mo>";
            }
        }
        html += result.toMathML(printOptions);
        html += "</math>";
        return html;
    };
    Expression.Details.add({
        type: "eigenvectors",
        minRows: 2,
        callback: function(printOptions, matrix) {
            if (matrix.cols() <= 0) {
                return Expression.Details.getCallback("steps-to-find-eigenvectors")(printOptions, matrix);
            }
            if (!matrix.isSquare()) {
                throw new RangeError("NonSquareMatrixException");
            }
            var html = '';
            html += '<math>' + Expression.p('A=M', {
                M: new Expression.Matrix(matrix)
            }, printOptions) + '</math>';
            var title = i18n.vectors.eigenvectorsForTheMatrixA || ""; //TODO: !?
            html += '<p>' + title.replaceAll('`A`', '<math>' + Expression.p('A') + '</math>') + '</p>';
            html += '<ul>';
            var eigenvalues = Expression.getEigenvalues(matrix);
            var eigenvectors = Expression.getEigenvectors(matrix, eigenvalues);
            var uniqueEigenvalues = Expression.unique(eigenvalues);
            for (var i = 0; i < eigenvectors.length; i += 1) {
                if (eigenvectors[i] != null) {
                    var x = eigenvalues[i];
                    var j = uniqueEigenvalues.indexOf(x);
                    html += '<li>';
                    var v = eigenvectors[i];
                    html += '<math>' + Expression.p('v=x', {
                        v: new Expression.MatrixSymbol('v'),
                        x: new Expression.Matrix(v)
                    }, printOptions) + '</math>' + ', ' + i18n.JordanDecomposition.eigenvalue.toLocaleLowerCase() + ' ' + '<math>' + Expression.p('λ_' + (j + 1) + '=x', {
                        x: x
                    }, printOptions) + '</math>';
                    html += '</li>';
                }
            }
            html += '</ul>';
            var detailsHTML = createDetailsSummary(printOptions.idPrefix, [{
                type: 'steps-to-find-eigenvectors',
                matrix: matrix.toString(),
                second: undefined
            }]);
            html += detailsHTML;
            return html;
        }
    });
    Expression.Details.add({
        type: "steps-to-find-eigenvectors",
        minRows: 1,
        callback: function(printOptions, matrix) {
            if (!matrix.isSquare()) {
                throw new RangeError("NonSquareMatrixException");
            }
            var html = "";
            html += "<ol>";
            var tmp = Expression.getEigenvaluesWithSteps(printOptions, matrix);
            var eigenvalues = tmp.eigenvalues;
            html += "<li>";
            html += tmp.html;
            html += "</li>";
            if (eigenvalues.length > 0) {
                var tmp2 = Expression.getEigenvectorsWithSteps(printOptions, matrix, eigenvalues);
                html += "<li>";
                html += tmp2.html;
                html += "</li>";
            } else {
                html += "<li>";
                html += i18n.eigenvalues.thereAreNoRationalSolutions;
                html += "</li>";
            }
            html += "</ol>";
            return html;
        }
    });
    Expression.Details.add({
        type: "eigenvalues",
        minRows: 2,
        callback: function(printOptions, matrix) {
            if (matrix.cols() <= 0) {
                return Expression.Details.getCallback("steps-to-find-eigenvalues")(printOptions, matrix);
            }
            if (!matrix.isSquare()) {
                throw new RangeError("NonSquareMatrixException");
            }
            var html = '';
            html += '<math>' + Expression.p('A=M', {
                M: new Expression.Matrix(matrix)
            }, printOptions) + '</math>';
            var title = i18n.index.datalist.eigenvaluesOfA || ""; //TODO: !?
            title = title.slice(0, 1).toLocaleUpperCase() + title.slice(1) + (title !== "" ? ":" : "");
            html += '<p>' + title.replaceAll('`A`', '<math>' + Expression.p('A') + '</math>') + '</p>';
            html += '<ul>';
            var eigenvalues = Expression.getEigenvalues(matrix);
            for (var i = 0; i < eigenvalues.length; i += 1) {
                //TODO: unique + multiplicity
                var x = eigenvalues[i];
                html += '<li>';
                html += '<math>' + Expression.p('λ_' + (i + 1) + '=x', {
                    x: x
                }, printOptions) + '</math>';
                html += '</li>';
            }
            html += '</ul>';
            var detailsHTML = createDetailsSummary(printOptions.idPrefix, [{
                type: 'steps-to-find-eigenvalues',
                matrix: matrix.toString(),
                second: undefined
            }]);
            html += detailsHTML;
            return html;
        }
    });
    Expression.Details.add({
        type: "steps-to-find-eigenvalues",
        minRows: 1,
        callback: function(printOptions, matrix) {
            if (!matrix.isSquare()) {
                throw new RangeError("NonSquareMatrixException");
            }
            var html = "";
            html += "<ol>";
            var tmp = Expression.getEigenvaluesWithSteps(printOptions, matrix);
            var eigenvalues = tmp.eigenvalues;
            html += "<li>";
            html += tmp.html;
            html += "</li>";
            if (eigenvalues.length > 0) {
                html += "<li>";
                html += i18n.eigenvalues.thereAreNoRationalSolutions;
                html += "</li>";
            }
            html += "</ol>";
            return html;
        }
    });

    //!
    Expression.Details.add({
        type: "expand-along-column",
        minRows: 3,
        callback: function(printOptions, matrix, columnNumber) {
            return Expression.expandDeterminant(matrix, false, columnNumber, printOptions);
        }
    });
    Expression.Details.add({
        type: "expand-along-row",
        minRows: 3,
        callback: function(printOptions, matrix, rowNumber) {
            return Expression.expandDeterminant(matrix, true, rowNumber, printOptions);
        }
    });
    Expression.Details.add({
        type: "obtain-zeros-in-column",
        minRows: 3,
        callback: function(printOptions, matrix, columnNumber) {
            return Expression.getZero(matrix, false, columnNumber, printOptions);
        }
    });
    Expression.Details.add({
        type: "obtain-zeros-in-row",
        minRows: 3,
        callback: function(printOptions, matrix, rowNumber) {
            return Expression.getZero(matrix, true, rowNumber, printOptions);
        }
    });
    var determinant3x3 = function(printOptions, matrix, text) {
        var containerId = printOptions.idPrefix + "-" + Expression.id();
        if (matrix.cols() !== 3 || matrix.rows() !== 3) {
            throw new RangeError("NonSquareMatrixException:" + i18n.determinant.theRuleOfSarrusCanBeUsedOnlyWith3x3Matrices);
        }
        //TODO: replace
        var matrixId = containerId;
        var cellId = function(i, j) {
            return matrixId + "_" + i.toString() + "_" + j.toString();
        };
        var higlights = "";
        var html = "";
        //html += "<div>" + text + "</div>";
        html += "<div class=\"math-block\">" + text + "</div>";
        html += "<math>";
        html += new Expression.Determinant(new Expression.Matrix(matrix)).toMathML(Object.assign({}, printOptions, {
            cellIdGenerator: function(i, j) {
                return cellId(i, j);
            }
        }));
        html += "<mo>=</mo>";
        html += "<mrow>";
        // TODO: clickable highlight with initially selected group
        var z = ["a_11*a_22*a_33", "a_12*a_23*a_31", "a_13*a_21*a_32", "a_31*a_22*a_13", "a_32*a_23*a_11", "a_33*a_21*a_12"];
        var context = new ExpressionParser.Context(function(id) {
            return matrix.e(Number(id.slice(2, 3)) - 1, Number(id.slice(3, 4)) - 1);
        });
        var determinant = undefined;
        for (var i = 0; i < z.length; i += 1) {
            var e = ExpressionParser.parse(z[i], context);
            if (i !== 0) {
                var sign = i < 3 ? "+" : "&minus;";
                html += "<mo>" + sign + "</mo>";
            }
            var highlight = z[i].replace(/a_(\d)(\d)\*?/g, function(x, si, sj) {
                var i = Number(si) - 1;
                var j = Number(sj) - 1;
                return "#" + cellId(i, j) + ", ";
            }).slice(0, -2);
            html += "<mrow id=\"" + (matrixId + "_x" + i.toString()) + "\">";
            html += e.toMathML(Object.assign({}, printOptions, {
                isTopLevel: false
            }));
            html += "</mrow>";
            higlights += "<a class=\"a-highlight\" data-for=\"" + (matrixId + "_x" + i.toString()) + "\" data-highlight=\"" + highlight + "\"></a>";
            determinant = i === 0 ? e : i < 3 ? determinant.add(e) : determinant.subtract(e);
        }
        html += "</mrow>";
        html += "<mo>=</mo>";
        html += determinant.simplify().toMathML(printOptions);
        html += "</math>";
        html += '<div hidden>' + higlights + '</div>';
        return html;
    };

    //TODO: fix - i18n.unused.determinant.usingSarrusRule
    Expression.Details.add({
        type: "determinant-Sarrus",
        i18n: function() {
            return i18n.det.ruleOfSarrus;
        },
        minRows: 3,
        maxRows: 3,
        priority: 2,
        callback: function(printOptions, matrix) {
            return determinant3x3(printOptions, matrix, Expression.getSomeDetails("determinantSarrus").replace(/\$\{link\}/g, i18n.ruleOfSarrusLink));
        }
    });
    Expression.Details.add({
        type: "determinant-Triangle",
        i18n: function() {
            return i18n.det.ruleOfTriangle;
        },
        minRows: 3,
        maxRows: 3,
        priority: 3,
        callback: function(printOptions, matrix) {
            return determinant3x3(printOptions, matrix, Expression.getSomeDetails("determinantTriangle").replace(/\$\{link\}/g, i18n.ruleOfTriangleLink));
        }
    });

    // https://www.math.susu.ac.ru/193-2.html
    // https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order
    Matrix.permutations = function(n, callback) {
        function reverse(p, from, to, even) {
            for (var i = from; i < to - 1 - (i - from); i += 1) {
                var j = to - 1 - (i - from);
                var tmp = p[j];
                p[j] = p[i];
                p[i] = tmp;
                even = !even;
            }
            return even;
        }
        if (n !== Math.floor(n) || n < 1) {
            throw new RangeError();
        }
        var p = new Array(n);
        var even = true;
        for (var i = 0; i < n; i += 1) {
            p[i] = i;
        }
        while (true) {
            var indexOfZero = callback(p, even);
            even = reverse(p, indexOfZero + 1, n, even);
            var k = n - 2;
            var l = n - 1;
            while (k >= 0 && p[k] > p[k + 1]) {
                k -= 1;
            }
            if (k < 0) {
                return;
            }
            while (p[k] > p[l]) {
                l -= 1;
            }
            var tmp = p[k];
            p[k] = p[l];
            p[l] = tmp;
            even = !even;
            even = reverse(p, k + 1, n, even);
        }
    };
    Matrix.prototype.determinantLeibniz = function() {
        if (!this.isSquare()) {
            throw new RangeError("NonSquareMatrixException");
        }
        //TODO: output (?) + 0 + ... + 0
        var determinant = undefined;
        var bestZeroGroup = null;
        var bestZeroGroupIndexOfZero = 0;
        var matrix = this;
        var n = matrix.cols();
        //TODO: skip iterations when an element is zero
        Matrix.permutations(n, function(p, even) {
            var t = undefined;
            var indexOfZero = n;
            for (var i = 0; i < n; i += 1) {
                var e = matrix.e(i, p[i]);
                if (e.unwrap().equals(Expression.ZERO)) {
                    if (indexOfZero === n) {
                        indexOfZero = i;
                    }
                }
                t = t == undefined ? e : t.multiply(e);
            }
            if (indexOfZero < n && n > 4 && t instanceof NonSimplifiedExpression) {
                //TODO: ?
                //TODO: output 0 + ... + 0
                //t = t instanceof NonSimplifiedExpression ? new NonSimplifiedExpression(Expression.ZERO) : Expression.ZERO;
                //determinant = determinant == undefined ? (even ? t : t.negate()) : (even ? determinant.add(t) : determinant.subtract(t));
                if (bestZeroGroupIndexOfZero < indexOfZero) {
                    bestZeroGroupIndexOfZero = indexOfZero;
                    bestZeroGroup = even ? t : t.negate();
                }
            } else {
                determinant = determinant == undefined ? even ? t : t.negate() : even ? determinant.add(t) : determinant.subtract(t);
            }
            return indexOfZero < n ? indexOfZero : n;
        });
        if (determinant == undefined) {
            determinant = bestZeroGroup;
        }
        console.assert(determinant != undefined);
        return determinant == undefined ? Expression.ZERO : determinant;
    };

    //???
    Expression.Details.add({
        type: "determinant-Leibniz",
        i18n: function() {
            return i18n.det.formulaOfLeibniz;
        },
        minRows: 4,
        //TODO: when a lot of zeros (?): compute the number of permutations (?)
        maxRows: 6,
        //?
        priority: -2,
        callback: function(printOptions, matrix) {
            var highlights = '';
            var html = "";
            html += "<math>";
            if (true) {
                var nsMatrix = matrix.map(function(e, i, j) {
                    return new NonSimplifiedExpression(e);
                });
                html += new Expression.Determinant(new Expression.Matrix(nsMatrix)).toMathML(Object.assign({}, printOptions, {
                    cellIdGenerator: function(i, j) {
                        return nsMatrix.e(i, j).getId();
                    }
                }));
                html += "<mo>=</mo>";
                var e = nsMatrix.determinantLeibniz();
                var elements = [];
                for (var s = e; s != null; s = (s.unwrap() instanceof Expression.Addition || s.unwrap() instanceof Expression.Subtraction) && s.unwrap().a instanceof NonSimplifiedExpression ? s.unwrap().a : null) {
                    var x = (s.unwrap() instanceof Expression.Addition || s.unwrap() instanceof Expression.Subtraction) && s.unwrap().a instanceof NonSimplifiedExpression ? s.unwrap().b : s;
                    elements.push({
                        e: x,
                        sign: s.unwrap() instanceof Expression.Subtraction ? '&minus;' : '+'
                    });
                }
                html += elements.length !== 1 ? '<mrow>' : '';
                for (var i = elements.length - 1; i >= 0; i -= 1) {
                    var x = elements[i].e;
                    var sign = elements[i].sign;
                    if (i !== elements.length - 1 || sign !== '+') {
                        //TODO: some details about sign
                        html += '<mpadded width="+0.8em" lspace="+0.4em">' + '<mo>' + sign + '</mo>' + '</mpadded>';
                    }
                    html += "<mrow id=\"" + x.getId() + "\">";
                    html += x.toMathML(printOptions);
                    html += "</mrow>";
                    var highlight = '<a class="a-highlight" data-for="' + x.getId().toString() + '" data-highlight="' + x.unwrap().getIds() + '"></a>';
                    highlights += highlight;
                }
                html += elements.length !== 1 ? '</mrow>' : '';
            } else {
                html += new Expression.Determinant(new Expression.Matrix(matrix)).toMathML(printOptions);
                //TODO: formula - ?
                //html += "<mo>=</mo>";
                //html += "";
                html += "<mo>=</mo>";
                html += matrix.map(function(e, i, j) {
                    return new NonSimplifiedExpression(e);
                }).determinantLeibniz().toMathML(printOptions);
            }
            if (matrix.cols() > 1) {
                html += "<mo>=</mo>";
                html += matrix.determinantLeibniz().toMathML(printOptions);
            }
            html += "</math>";
            html += " ";
            html += i18n.determinantLeibnizLink;
            html += '<div hidden>' + highlights + '</div>';
            return html;
        }
    });
    Expression.mgetZero = function(m, k, callback) {
        // m == n ; in a column k -- find in k-column non-zero element and ... subtract
        callback = callback || undefined;
        var i = 0;
        while (i < m.rows() && m.e(i, k).equals(Expression.ZERO)) {
            i += 1;
        }
        if (i < m.rows()) {
            // Matrix.toRowEchelonStep - ?
            var j = -1;
            while (++j < m.rows()) {
                if (j !== i) {
                    if (!m.e(j, k).equals(Expression.ZERO)) {
                        var oldMatrix = m;
                        m = m.rowReduce(j, i, k);
                        if (callback != undefined) {
                            callback({
                                previousPivot: undefined,
                                newMatrix: m,
                                oldMatrix: oldMatrix,
                                type: "reduce",
                                targetRow: j,
                                pivotRow: i,
                                pivotColumn: k
                            });
                        }
                    }
                }
            }
            return {
                B: m,
                c: {
                    e: m.e(i, k),
                    i: i,
                    j: k
                }
            }; // r?
        }

        return {
            B: m,
            c: null
        };
    };

    //TODO: better details
    Expression.getZero = function(matrix, atRow, number, printOptions) {
        var k = Number(number.toString()) - 1;
        //!
        if (!matrix.isSquare()) {
            throw new RangeError("NonSquareMatrixException");
        }
        if (k >= matrix.rows() || k < 0 || k !== Math.floor(k)) {
            // matrix.isSquare() === true
            throw new RangeError("IntegerInputError" + ":" + (atRow ? "rowNumber" : "columnNumber"));
        }
        //!
        var containerId = printOptions.idPrefix; //?

        var text = "";
        var html = "";
        if (atRow) {
            html += "<math>";
        }
        var step = 1;
        var tmp = Expression.mgetZero(atRow ? matrix.transpose() : matrix, k, function(change) {
            if (atRow) {
                //TODO:
                html += new Expression.Determinant(new Expression.Matrix(change.oldMatrix.transpose())).toMathML(printOptions);
                var jT = "<code>" + localeString(change.targetRow + 1) + "</code>";
                var iT = "<code>" + localeString(change.pivotRow + 1) + "</code>";
                //TODO: why English is not used as fallback ?
                var multiplier = change.oldMatrix.e(change.targetRow, change.pivotColumn).divide(change.oldMatrix.e(change.pivotRow, change.pivotColumn));
                var areBracketsRequired = multiplier.getPrecedence() !== Expression.ZERO.getPrecedence(); //? not simple
                var questionId = containerId + "-" + step + "-" + "question-mark";
                var tooltip = (i18n.eliminationDetails.columnSubtraction || '').replace(/\$\{a\}/g, "<code>" + "<math>" + (areBracketsRequired ? "<mrow><mo>(</mo>" : "") + multiplier.toMathML(printOptions) + (areBracketsRequired ? "<mo>)</mo></mrow>" : "") + "</math>" + "</code>").replace(/\$\{j\}/g, jT).replace(/\$\{i\}/g, iT).replace(/\$\{someDetails3\}/g, Expression.getSomeDetails("someDetails3"));
                tooltip += '';
                //TODO: class
                html += '<mpadded width="+0.8em" lspace="+0.4em">';
                html += '<mover accent="true"><mo>=</mo><mtext><a class="question-icon-new" id="' + questionId + '">?</a><a class="a-tooltip" data-for="' + questionId + '" hidden>' + tooltip + '</a></mtext></mover>';
                html += '</mpadded>';
            } else {
                html += Expression.rowReduceChangeToHTML(change, Object.assign({}, printOptions, {
                    _isDeterminant: true
                }), containerId, step, Condition.TRUE);
            }
            step += 1;
        });
        var B = tmp.B;
        var c = tmp.c;
        if (atRow) {
            B = B.transpose();
            c = c == null ? null : {
                e: c.e,
                i: c.j,
                j: c.i
            };
        }
        if (!atRow) {
            html += "<math>";
        }
        //TODO: share with the `Expression.rowReduceChangeToHTML` !!!
        var cellId = function(k, i, j) {
            return containerId + "-" + k.toString() + "-" + i.toString() + "-" + j.toString();
        };
        html += new Expression.Determinant(new Expression.Matrix(B)).toMathML(Object.assign({}, printOptions, {
            cellIdGenerator: function(i, j) {
                return cellId(step, i, j);
            }
        }));
        html += "<mo>=</mo>";
        var result = null;
        if (c == null) {
            result = Expression.ZERO;
        } else {
            var t = B.minorMatrix(c.i, c.j);
            if (t.cols() === 0) {
                result = c.e;
            } else {
                var n = Expression.Integer.fromNumber(Math.pow(-1, c.i + c.j));
                result = n.multiply(c.e).multiply(t.determinant());
                var ie = new NonSimplifiedExpression(Expression.Integer.fromNumber(c.i + 1));
                var je = new NonSimplifiedExpression(Expression.Integer.fromNumber(c.j + 1));
                html += Expression.p('(-1)**(i+j)*e*D', {
                    i: ie,
                    j: je,
                    e: c.e,
                    // TODO: link the element
                    D: new Expression.Minor(new Expression.Matrix(B), c.i, c.j)
                }, Object.assign({}, printOptions, {
                    printId: true
                }));

                // TODO: share with expansion
                text += '<a class="a-tooltip" data-for="' + ie.getId() + '" hidden>';
                text += '<math>' + '<msub><mi>a</mi><mrow><mrow style="font-weight: bolder">' + Expression.p(c.i + 1) + '</mrow><mo>,</mo>' + Expression.p(c.j + 1) + '</mrow></msub>' + '</math>';
                text += '</a>';
                text += '<a class="a-tooltip" data-for="' + je.getId() + '" hidden>';
                text += '<math>' + '<msub><mi>a</mi><mrow>' + Expression.p(c.i + 1) + '<mo>,</mo><mrow style="font-weight: bolder">' + Expression.p(c.j + 1) + '</mrow></mrow></msub>' + '</math>';
                text += '</a>';
                html += "<mo>=</mo>";
            }
        }
        html += result.toMathML(printOptions);
        html += "</math>";
        html += "<span hidden>" + text + "</span>";
        return html;
    };
    // --------------------------------------------- end ----------------------------------------------
    // ---------------------------------------- sle -----------------------------------------------

    Matrix.trimRight = function(x) {
        var lastColumn = -1;
        x.map(function(e, i, j) {
            if (lastColumn < j && !e.equals(Expression.ZERO)) {
                lastColumn = j;
            }
            return e;
        });
        return x.slice(0, x.rows(), 0, lastColumn + 1);
    };
    var testSLECompatibility = function(printOptions, fullMatrix) {
        if (fullMatrix.cols() < 1) {
            throw new RangeError("ValueMissingError:A-textarea"); //TODO: fix
        }

        var st = "<h4>" + i18n.consistency.analyseCompatibilityOfTheSystem + "</h4>";
        //TODO: fix i18n
        st += "<p>" + i18n.consistency.analyseCompatibilityIntroduction + "</p>";
        var m = Matrix.trimRight(fullMatrix.slice(0, fullMatrix.rows(), 0, fullMatrix.cols() - 1));
        var b = fullMatrix.slice(0, fullMatrix.rows(), fullMatrix.cols() - 1, fullMatrix.cols());
        var augmented = m.augment(b);
        var results = [];
        Matrix.toRowEchelonWithCallback(augmented, Matrix.GaussMontante, "", null, function(result) {
            results.push(result);
        });
        if (results.length > 1) {
            st += "<ol>";
        }
        for (var i = 0; i < results.length; i += 1) {
            st += results.length > 1 ? "<li><div>" + "<math>" + results[i].condition.toMathML(printOptions) + "</math>" : "";
            var t = results[i].matrix;
            var mRank = t.slice(0, t.rows(), 0, t.cols() - 1).rank();
            var augmentedRank = t.rank();
            //var mRank = m.rank();
            //var augmentedRank = augmented.rank();
            st += "<div>";
            st += "<math>";
            st += new Expression.Rank(new Expression.Matrix(augmented)).toMathML(Object.assign({}, printOptions, {
                columnlines: -1
            })) + "<mo>=</mo>" + Expression.p(augmentedRank);
            st += "</math>";
            st += "</div>";
            //st += createDetailsSummary(printOptions.idPrefix, [{type: "rank", matrix: augmented.toString(), second: undefined}]);
            st += "<div>";
            st += "<math>";
            st += new Expression.Rank(new Expression.Matrix(m)).toMathML(printOptions) + "<mo>=</mo>" + Expression.p(mRank);
            st += "</math>";
            st += "</div>";
            //st += createDetailsSummary(printOptions.idPrefix, [{type: "rank", matrix: m.toString(), second: undefined}]);
            st += "<div>";
            if (mRank === augmentedRank) {
                if (m.cols() === mRank) {
                    st += i18n.consistency.theSystemIsConsistentAndItHasAUniqueSolution;
                } else {
                    st += i18n.consistency.theSystemIsConsistentAndItHasInfiniteNumberOfSolutions;
                }
            } else {
                st += i18n.consistency.theSystemIsInconsistent;
            }
            st += "</div>";
            st += results.length > 1 ? "</div></li>" : "";
        }
        if (results.length > 1) {
            st += "</ol>";
        }

        //!new
        st += createDetailsSummary(printOptions.idPrefix, [{
            type: "rank",
            matrix: augmented.toString(),
            second: undefined
        }]);
        //!new
        return st;
    };
    Expression.Details.add({
        type: "analyse-compatibility",
        i18n: function() {
            return i18n.slu.testForConsistency; //?
        },

        minRows: 1,
        callback: function(printOptions, matrix) {
            return testSLECompatibility(printOptions, matrix);
        }
    });

    //TODO: move
    var outSystem = function(printOptions, matrix, variableNames) {
        return new Expression.Matrix(matrix).toMathML(Object.assign({}, printOptions, {
            variableNames: variableNames,
            useBraces: ["{", " "]
        }));
    };
    //! TODO: (!)

    var makeDefaultVariableNames = function(count) {
        var variableNames = new Array(count);
        for (var i = 0; i < count; i += 1) {
            variableNames[i] = "x_" + (i + 1).toString();
        }
        return variableNames;
    };
    var solveUsingCramersRule = function(printOptions, fullMatrix, variableNames) {
        if (fullMatrix.cols() < 2) {
            throw new RangeError("ValueMissingError:A-textarea"); //TODO: fix
        }

        // TODO: fix
        //!hack
        if (variableNames == undefined) {
            variableNames = makeDefaultVariableNames(fullMatrix.cols() - 1);
        }
        var m = Matrix.trimRight(fullMatrix.slice(0, fullMatrix.rows(), 0, fullMatrix.cols() - 1));
        var b = fullMatrix.slice(0, fullMatrix.rows(), fullMatrix.cols() - 1, fullMatrix.cols());
        if (!m.isSquare()) {
            throw new RangeError("NonSquareMatrixException:" + i18n.systems.forSolutionUsingCramersRuleNumberOfEquationsShouldBeEqualNumberOfVariables);
        }
        var D0 = m.determinant();
        var mstr = "";
        mstr = "<h4>" + i18n.systems.solutionByRuleOfCramer + "</h4>";
        mstr += "<div>";
        mstr += "<math>";
        mstr += outSystem(printOptions, fullMatrix, variableNames);
        mstr += "</math>";
        mstr += "</div>";
        mstr += "<div>";
        mstr += "<math>";
        mstr += "<mi>Δ</mi>";
        mstr += "<mo>=</mo>" + new Expression.Determinant(new Expression.Matrix(m)).toMathML(printOptions);
        mstr += "<mo>=</mo>" + D0.toMathML(printOptions);
        mstr += "</math>";
        mstr += "</div>";
        mstr += createDetailsSummary(printOptions.idPrefix, [{
            type: m.getDeterminantEventType("determinant").type,
            matrix: m.toString(),
            second: undefined
        }]);
        if (D0.equals(Expression.ZERO)) {
            //TODO: fix text
            mstr += "<div>";
            mstr += i18n.systems.forSolutionUsingCramersRuleCoefficientMatrixShouldHaveNonZeroDeterminant;
            mstr += "</div>";
            return mstr;
        }
        var d = new Array(m.cols());
        mstr += '<ul class="list-unstyled">';
        for (var i = 0; i < m.cols(); i += 1) {
            mstr += "<li>";
            var m1 = m.map(function(e, row, col) {
                return col === i ? b.e(row, 0) : e;
            });
            d[i] = m1.determinant();
            mstr += "<math>";
            mstr += "<msub><mi>Δ</mi>" + Expression.p(i + 1) + "</msub>" + "<mo>=</mo>" + new Expression.Determinant(new Expression.Matrix(m1)).toMathML(printOptions) + "<mo>=</mo>" + d[i].toMathML(printOptions);
            mstr += "</math>";
            mstr += ";";
            mstr += createDetailsSummary(printOptions.idPrefix, [{
                type: m1.getDeterminantEventType("determinant").type,
                matrix: m1.toString(),
                second: undefined
            }]);
            mstr += "</li>";
        }
        mstr += '</ul>';
        mstr += '<ul class="list-unstyled">';
        for (var i = 0; i < m.cols(); i += 1) {
            mstr += "<li>";
            mstr += "<math>";
            mstr += new Expression.Symbol(variableNames[i]).toMathML(printOptions);
            var deltaI = new NonSimplifiedExpression(d[i]).divide(new NonSimplifiedExpression(D0));
            var deltaISimplified = deltaI.simplify();
            mstr += "<mo>=</mo>" + "<mrow><msub><mi>Δ</mi>" + Expression.p(i + 1) + "</msub><mo>&#x2215;</mo><mi>Δ</mi></mrow>";
            mstr += "<mo>=</mo>" + deltaI.toMathML(printOptions);
            if (deltaI.toString() !== deltaISimplified.toString()) {
                //?
                mstr += "<mo>=</mo>" + deltaISimplified.toMathML(printOptions);
            }
            mstr += "</math>";
            mstr += "</li>";
        }
        mstr += "</ul>";
        mstr += "<div>" + i18n.systems.answer + "</div>";
        mstr += '<ul class="list-unstyled">';
        for (var i = 0; i < m.cols(); i += 1) {
            mstr += "<li>";
            mstr += "<math>";
            mstr += new Expression.Symbol(variableNames[i]).toMathML(printOptions) + "<mo>=</mo>" + d[i].divide(D0).toMathML(printOptions);
            mstr += "</math>";
            mstr += "</li>";
        }
        mstr += '</ul>';

        //TODO: ? use cases ? t*x=t - ?
        var condition = Condition.TRUE.andNotZero(D0);
        if (!condition.isTrue()) {
            mstr += "<div>";
            mstr += "<math>";
            mstr += "<mrow><mo>(</mo>";
            mstr += condition.toMathML(printOptions);
            mstr += "<mo>)</mo></mrow>";
            mstr += "</math>";
            mstr += "</div>";
        }

        //TODO: some text about solution when !condition.isFalse()

        return mstr;
    };

    // SLE solution with inverse matrix
    var solveUsingInverseMatrixMethod = function(printOptions, fullMatrix, variableNames) {
        if (fullMatrix.cols() < 2) {
            throw new RangeError("ValueMissingError:A-textarea"); //TODO: fix
        }

        //TODO: use variableNames (?)

        var m = Matrix.trimRight(fullMatrix.slice(0, fullMatrix.rows(), 0, fullMatrix.cols() - 1));
        var b = fullMatrix.slice(0, fullMatrix.rows(), fullMatrix.cols() - 1, fullMatrix.cols());
        var mstr = "";
        var c = undefined;
        if (!m.isSquare()) {
            throw new RangeError("NonSquareMatrixException:" + i18n.systems.toSolveSystemByInverseMatrixMethodNumberOfEquationsShouldBeEqualNumberOfVariables);
        }
        try {
            c = m.inverse();
        } catch (error) {
            if (error instanceof RangeError && error.message.indexOf("SingularMatrixException") === 0) {
                //mstr = i18n.systems.toSolveSystemByInverseMatrixMethodCoefficientMatrixShouldHaveNonZeroDeterminant;
            } else {
                throw error;
            }
        }
        mstr += "<h4>" + i18n.systems.solutionByInverseMatrixMethod + "</h4>";
        mstr += "<div>";
        mstr += "<math>";
        mstr += "<mrow><mi>A</mi><mo>&sdot;</mo><mi>X</mi></mrow><mo>=</mo><mi>B</mi>";
        mstr += "</math>";
        mstr += "</div>";
        mstr += "<div>";
        mstr += "<math>";
        mstr += "<mi>A</mi><mo>=</mo>" + new Expression.Matrix(m).toMathML(printOptions);
        mstr += "</math>";
        mstr += "</div>";
        mstr += "<div>";
        mstr += "<math>";
        mstr += "<mi>B</mi><mo>=</mo>" + new Expression.Matrix(b).toMathML(printOptions);
        mstr += "</math>";
        mstr += "</div>";
        if (c != undefined) {
            mstr += "<div>";
            mstr += "<math>";
            mstr += "<msup><mi>A</mi><mrow><mo>&minus;</mo>" + Expression.p(1) + "</mrow></msup><mo>=</mo>" + new Expression.Matrix(c).toMathML(printOptions);
            mstr += "</math>";
            mstr += "</div>";
            mstr += createDetailsSummary(printOptions.idPrefix, [{
                type: m.getDeterminantEventType("inverse").type,
                matrix: m.toString(),
                second: undefined
            }]);
            mstr += "<div>";
            mstr += "<math>";
            //TODO: multiplicaiton details (?)
            mstr += "<mi>X</mi><mo>=</mo><mrow><msup><mi>A</mi><mrow><mo>&minus;</mo>" + Expression.p(1) + "</mrow></msup><mo>&sdot;</mo><mi>B</mi></mrow><mo>=</mo><mrow>" + new Expression.Matrix(c).toMathML(printOptions) + "<mo>&sdot;</mo>" + new Expression.Matrix(b).toMathML(printOptions) + "</mrow><mo>=</mo>" + new Expression.Matrix(c.multiply(b)).toMathML(printOptions);
            mstr += "</math>";
            mstr += "</div>";
        } else {
            mstr += i18n.systems.toSolveSystemByInverseMatrixMethodCoefficientMatrixShouldHaveNonZeroDeterminant;
            mstr += createDetailsSummary(printOptions.idPrefix, [{
                type: m.getDeterminantEventType("inverse").type,
                matrix: m.toString(),
                second: undefined
            }]);
            mstr += "<div class=\"for-details\"></div>";
        }
        return mstr;
    };

    //----------Gauss
    // getting row echelon form without columns swapping

    Expression.rowReduceChangeToHTML = function(change, printOptions, containerId, k, stepCondition) {
        var multiplier = change.type === "reduce" ? change.oldMatrix.e(change.targetRow, change.pivotColumn).divide(change.oldMatrix.e(change.pivotRow, change.pivotColumn)) : undefined;
        var areBracketsRequired = change.type === "reduce" ? multiplier.getPrecedence(multiplier) !== Expression.ZERO.getPrecedence() : undefined; //? not simple
        var jT = "<code>" + localeString(change.targetRow + 1) + "</code>";
        var iT = "<code>" + localeString(change.pivotRow + 1) + "</code>";
        var tooltip = (change.type === "swap-negate" ? i18n.eliminationDetails.rowSwapNegate.replace(/\$\{\-1\}/g, "<math>" + "<mo>&minus;</mo>" + Expression.p(1) + "</math>").replace(/\$\{j\}/g, jT).replace(/\$\{i\}/g, iT) : "") + (change.type === "swap" ? i18n.eliminationDetails.rowSwap.replace(/\$\{j\}/g, jT).replace(/\$\{i\}/g, iT) : "") + (change.type === "divide" ? i18n.eliminationDetails.rowDivision.replace(/\$\{a\}/g, "<code>" + "<math>" + change.oldMatrix.e(change.pivotRow, change.pivotColumn).toMathML(printOptions) + "</math>" + "</code>").replace(/\$\{j\}/g, jT).replace(/\$\{i\}/g, iT) : "") + (change.type === "reduce" ? i18n.eliminationDetails.rowSubtraction.replace(/\$\{a\}/g, "<code>" + "<math>" + (areBracketsRequired ? "<mrow><mo>(</mo>" : "") + multiplier.toMathML(printOptions) + (areBracketsRequired ? "<mo>)</mo></mrow>" : "") + "</math>" + "</code>").replace(/\$\{j\}/g, jT).replace(/\$\{i\}/g, iT) : "");
        var text = "";
        var cellId = function(k, i, j) {
            return containerId + "-" + k.toString() + "-" + i.toString() + "-" + j.toString();
        };
        var questionId = containerId + "-" + k.toString() + "-" + "question-mark";
        k += 1; //!
        for (var i = 0; i < change.oldMatrix.cols(); i += 1) {
            if (change.type === "reduce" || change.type === "divide") {
                var highlight = "<a class=\"a-highlight\" data-for=\"" + cellId(k, change.targetRow, i) + "\" data-highlight=\"" + "#" + cellId(k - 1, change.pivotRow, change.pivotColumn) + ", " + "#" + cellId(k - 1, change.targetRow, i) + ", " + (change.type === "reduce" ? "#" + cellId(k - 1, change.targetRow, change.pivotColumn) + ", " : "") + (change.type === "reduce" ? "#" + cellId(k - 1, change.pivotRow, i) + ", " : "") + "#" + cellId(k, change.targetRow, i) + "\"></a>";
                text += "<a class=\"a-tooltip\" data-for=\"" + cellId(k, change.targetRow, i) + "\" hidden>" + "<math>" + Expression.p("a_(" + (change.targetRow + 1) + "," + (i + 1) + ")=" + (change.type === "reduce" ? "(b-(c/a)*d)" : "(b*(1/a))") + "=r", {
                    a: change.oldMatrix.e(change.pivotRow, change.pivotColumn),
                    b: change.oldMatrix.e(change.targetRow, i),
                    c: change.oldMatrix.e(change.targetRow, change.pivotColumn),
                    d: change.oldMatrix.e(change.pivotRow, i),
                    r: change.newMatrix.e(change.targetRow, i)
                }, printOptions) + "</math>" + "</a>" + highlight;
            } else if (change.type === "swap" || change.type === "swap-negate") {
                text += "<a class=\"a-highlight\" data-for=\"" + cellId(k, change.targetRow, i) + "\" data-highlight=\"" + "#" + cellId(k - 1, change.pivotRow, i) + ", " + "#" + cellId(k - 1, change.targetRow, i) + ", " + "#" + cellId(k, change.targetRow, i) + "\"></a>";
                text += "<a class=\"a-highlight\" data-for=\"" + cellId(k, change.pivotRow, i) + "\" data-highlight=\"" + "#" + cellId(k - 1, change.targetRow, i) + ", " + "#" + cellId(k - 1, change.pivotRow, i) + ", " + "#" + cellId(k, change.pivotRow, i) + "\"></a>";
            }
        }
        var M = new Expression.Matrix(change.oldMatrix);
        return "<span class=\"nowrap\">" + "<math>" + (printOptions._isDeterminant ? new Expression.Determinant(M) : M).toMathML(Object.assign({}, printOptions, {
            columnlines: printOptions.columnlines,
            cellIdGenerator: function(i, j) {
                return cellId(k - 1, i, j);
            },
            pivotCell: change.type === "swap" || change.type === "swap-negate" ? undefined : {
                i: change.pivotRow,
                j: change.pivotColumn
            }
        })) + "</math>" + "<span class=\"arrow-with-label\" data-custom-paint=\"arrow-with-label\" data-type=\"" + change.type + "\" data-start=\"" + change.pivotRow + "\" data-end=\"" + change.targetRow + "\">" + "<div role=\"img\" class=\"arrow\" aria-label=\"" + (change.type === "swap" || change.type === "swap-negate" ? i18n.misc.swapLabelTitle : i18n.misc.labelTitle).replace(/\$\{x\}/g, change.pivotRow + 1).replace(/\$\{y\}/g, change.targetRow + 1) + "\">" + (change.type === "swap" || change.type === "swap-negate" || change.pivotRow < change.targetRow ? "<div class=\"arrow-head-bottom\"></div>" : "") + (change.type === "swap" || change.type === "swap-negate" || change.pivotRow > change.targetRow ? "<div class=\"arrow-head-top\"></div>" : "") + (change.type !== "divide" ? "<div class=\"arrow-line\"></div>" : "") + "</div>" + "<div class=\"label\">" + (change.type === "swap" ? "" : change.type === "swap-negate" ? "" : "<math>" + (change.type === "divide" ? "<mo>&times;</mo>" + "<mrow><mo>(</mo>" + Expression.ONE.divide(change.oldMatrix.e(change.targetRow, change.pivotColumn)).toMathML(printOptions) + "<mo>)</mo></mrow>" : "<mo>&times;</mo>" + "<mrow><mo>(</mo>" + multiplier.negate().toMathML(printOptions) + "<mo>)</mo></mrow>") + "</math>") + "</div>" + "</span>" + "</span>" + "<math>" + "<mpadded width=\"+0.8em\" lspace=\"+0.4em\">" + "<mover accent=\"true\">" + (printOptions._isDeterminant ? "<mo>=</mo>" : "<munder accentunder=\"true\">" + "<mo stretchy=\"false\">" + "~" + "</mo>" + (stepCondition.isTrue() ? "" : "<munder accentunder=\"true\">") + "<mrow>" + ((change.type === "swap-negate" ? "${i}<mo>&harr;</mo><mrow><mo>&minus;</mo>${j}</mrow>" : "") + (change.type === "swap" ? "${i}<mo>&harr;</mo>${j}" : "") + (change.type === "divide" ? "${j}<mo>&#x2215;</mo><mrow><mo>(</mo>${a}<mo>)</mo></mrow><mo>&rarr;</mo>${j}".replace(/\$\{a\}/g, change.oldMatrix.e(change.pivotRow, change.pivotColumn).toMathML(printOptions)) : "") + (change.type === "reduce" ? "<mrow>${j}<mo>&minus;</mo><mrow>${a}<mo>&sdot;</mo>${i}</mrow></mrow><mo>&rarr;</mo>${j}".replace(/\$\{a\}/g, (areBracketsRequired ? "<mrow><mo>(</mo>" : "") + (printOptions.isLUDecomposition != undefined ? "<mrow mathbackground=\"#80FF80\" mathcolor=\"#3C78C2\">" : "") + multiplier.toMathML(printOptions) + (printOptions.isLUDecomposition != undefined ? "</mrow>" : "") + (areBracketsRequired ? "<mo>)</mo></mrow>" : "")) : "")).replace(/\$\{j\}/g, getMatrixRowDenotation(change.targetRow + 1)).replace(/\$\{i\}/g, getMatrixRowDenotation(change.pivotRow + 1)) + "</mrow>" + (stepCondition.isTrue() ? "" : stepCondition.toMathML(printOptions)) + (stepCondition.isTrue() ? "" : "</munder>") + "</munder>" + "") + "<mtext>" + (
            // Note: <a> is not allowed in <a>
            tooltip !== "" ? "<a class=\"question-icon-new\" id=\"" + questionId + "\">?</a><span class=\"a-tooltip\" data-for=\"" + questionId + "\" hidden>" + tooltip + "</span>" : "") + (text !== "" ? "<span hidden>" + text + "</span>" : "") + "</mtext>" + "</mover>" + "</mpadded>" + "</math>";
    };
    Expression.rowReductionGaussJordanMontante = function(matrix, method, usage, printOptions, resultCallback, flag0) {
        flag0 = flag0 == undefined ? false : flag0;
        var containerId = printOptions.idPrefix + "-" + Expression.id();
        var html = "";
        var k = 0;
        html += "<div class=\"math-block\">";
        var outputTailMatrix = function(stoppedAtRow, matrix) {
            html += "<math>";
            html += new Expression.Matrix(matrix).toMathML(Object.assign({}, printOptions, {
                cellIdGenerator: function(i, j) {
                    return containerId + "-" + k.toString() + "-" + i.toString() + "-" + j.toString();
                },
                highlightRow: stoppedAtRow
            }));
            html += "</math>";
            html += "</div>";
            k += 1;
        };
        //2017-01-04:
        var oldCondition = Condition.TRUE;
        //---
        var result = matrix.toRowEchelonXXX(method, usage, function(change) {
            //2017-09-29:
            var stepCondition = Condition.TRUE;
            if (usage !== "determinant" && usage !== "inverse") {
                // not a "determinant" or a "inverse" calculation
                //2017-01-04:
                var pivot = change.oldMatrix.e(change.pivotRow, change.pivotColumn);
                stepCondition = Condition.TRUE.andNotZero(pivot);
                if (!stepCondition.isTrue()) {
                    //?
                    oldCondition = oldCondition.andNotZero(pivot);
                }
            }
            //---
            // TODO: remove stepCondition - ?
            var rowReduceChangeToHTML = method === Matrix.GaussMontante ? Expression.rowReduceChangeToHTMLMontante : Expression.rowReduceChangeToHTML;
            html += rowReduceChangeToHTML(change, printOptions, containerId, k, stepCondition);
            k += 1;
        }, usage !== "determinant" && usage !== "inverse" && !flag0 ? Condition.TRUE : undefined);
        var w = function(result) {
            if (result.c1 == undefined && result.c2 == undefined) {
                outputTailMatrix(result.stoppedAtRow, result.matrix);
                html += resultCallback({
                    matrix: result.matrix,
                    stoppedAtRow: result.stoppedAtRow,
                    condition: flag0 ? oldCondition : result.condition // TODO: use or remove ?
                });
            } else {
                outputTailMatrix(-1, result.matrix);
                html += "<ol>";
                html += "<li>";
                html += "<div>";
                html += "<math>";
                html += result.c1.toMathML(printOptions);
                html += "</math>";
                html += "</div>";
                html += "<div>";
                w(result.a1());
                html += "</li>";
                html += "<li>";
                html += "<div>";
                html += "<math>";
                html += result.c2.toMathML(printOptions);
                html += "</math>";
                html += "</div>";
                html += "<div>";
                w(result.a2());
                html += "</li>";
                html += "</ol>";
            }
        };
        w(result);
        return html;
    };
    Expression.solveByGaussNext = function(ms, printOptions, variableNames) {
        var condition = ms.condition; //?
        var m = ms.matrix;

        //!?
        if (condition != undefined) {
            m = m.map(function(e, i, j) {
                //return condition.andNotZero(e).isFalse() ? Expression.ZERO : e;
                return condition.updateExpression(e, {
                    flag1: true
                });
            });
        }

        // 1. Throwing of null strings - they will be below, but checking: if we find a zero, which at the end has a non-zero, then there are no solutions!;
        var noSolutions = ms.stoppedAtRow !== -1;
        //!hack
        if (variableNames == undefined) {
            variableNames = makeDefaultVariableNames(m.cols() - 1);
        }
        if (noSolutions) {
            return {
                html: "<div>" + "<math>" + outSystem(printOptions, m, variableNames) + "</math>" + "</div>" + "<div>" + i18n.systems.thereAreNoSolutions + "</div>"
            };
        }
        var isHomogeneous = function(m) {
            for (var i = 0; i < m.rows(); i += 1) {
                if (!m.e(i, m.cols() - 1).equals(Expression.ZERO)) {
                    return false;
                }
            }
            return true;
        };

        // (?) TODO: allow users to specify "free" variables

        var containerId = printOptions.idPrefix + "-" + Expression.id();
        var systemId = containerId + "-" + "system_1";
        var mstr = "";
        if (!m.eql(Matrix.Zero(m.rows(), m.cols()))) {
            mstr += "<div class=\"anchor\" id=\"" + systemId + "\">" + "<table role=\"presentation\" class=\"system-table\">" + "<tr>" + "<td>" + "<math>" + outSystem(printOptions, m, variableNames) + "</math>" + "</td>" + "<td>" + "<a href=\"#" + systemId + "\">(" + localeString(1) + ")</a>" + "</td>" + "</tr>" + "</table>" + "</div>";
        }
        var isEquals = function(a, b) {
            if (a.length !== b.length) {
                return false;
            }
            for (var i = 0; i < a.length; i += 1) {
                if (!(a[i] instanceof NonSimplifiedExpression) || !(b[i] instanceof NonSimplifiedExpression)) {
                    throw new TypeError();
                }
                if (!a[i].e.equals(b[i].e)) {
                    // comparision without "simplification"
                    return false;
                }
            }
            return true;
        };
        var nsVariableNames = new Array(m.cols() - 1);
        for (var i = 0; i < m.cols() - 1; i += 1) {
            nsVariableNames[i] = new NonSimplifiedExpression(new Expression.Symbol(variableNames[i]));
        }
        mstr += "<ul>";
        m = Matrix.solveByGaussNext(m, function(m, oldMatrix1, oldMatrix2, i, j) {
            //?
            //if (condition != undefined) {
            //condition = condition.andNotZero(oldMatrix1.e(i, j));
            //}
            //?

            mstr += "<li>";
            mstr += "<div>";
            mstr += i18n.systems.fromEquationIFindVariable.replace(/\$\{i\}/g, "<math>" + Expression.p(i + 1) + "</math>").replace(/\$\{x\}/g, "<math>" + new Expression.Symbol(variableNames[j]).toMathML(printOptions) + "</math>").replace(/\$\{#system_1\}/g, "<a href=\"#" + systemId + "\">(" + localeString(1) + ")</a>");
            mstr += "</div>";
            mstr += "<div>";

            // We need to wrap using NonSimplifiedExpression to use in `isEquals`
            var equationSymbols1 = new Array(m.cols() - 1);
            var equationSymbols2 = new Array(m.cols() - 1);
            for (var k = 0; k < m.cols() - 1; k += 1) {
                var v = new NonSimplifiedExpression(nsVariableNames[k].e);
                equationSymbols1[k] = v;
                equationSymbols2[k] = v;
                if (k > j && !oldMatrix1.e(i, k).equals(Expression.ZERO)) {
                    var pivotRowK = Matrix.getPivotRow(oldMatrix1, k);
                    var y = pivotRowK === -1 ? v : new NonSimplifiedExpression(polynomialToExpression3(oldMatrix1, pivotRowK, nsVariableNames));
                    equationSymbols2[k] = y;
                }
            }
            mstr += "<math>";
            var leftPartCoefficient = oldMatrix1.e(i, j);
            var leftPartVariable = new Expression.Symbol(variableNames[j]);
            var leftPart = leftPartCoefficient.equals(Expression.ONE) ? leftPartVariable : new Expression.Multiplication(leftPartCoefficient, leftPartVariable);
            mstr += leftPart.toMathML(printOptions);
            mstr += "<mo>=</mo>";
            var beforeSubstitution = polynomialToExpression3(oldMatrix1, i, equationSymbols1).toMathML(Object.assign({}, printOptions, {
                printId: true
            }));
            mstr += beforeSubstitution;
            var afterSubstitution = polynomialToExpression3(oldMatrix1, i, equationSymbols2).toMathML(Object.assign({}, printOptions, {
                printId: true
            }));
            if (!isEquals(equationSymbols1, equationSymbols2)) {
                mstr += "<mo>=</mo>";
                mstr += afterSubstitution;
            }
            var afterSimplification = polynomialToExpression3(oldMatrix2, i, nsVariableNames).toMathML(printOptions);
            if (!isEquals(equationSymbols2, nsVariableNames)) {
                mstr += "<mo>=</mo>";
                mstr += afterSimplification;
            }
            mstr += "</math>";
            mstr += "<div hidden>";
            for (var k = 0; k < nsVariableNames.length; k += 1) {
                if (!equationSymbols2[k].e.equals(nsVariableNames[k].e)) {
                    mstr += "<a class=\"a-highlight\" data-for=\"" + equationSymbols2[k].getId() + "\" data-highlight=\"" + equationSymbols1[k].getId() + "\"></a>";
                }
            }
            mstr += "</div>";
            var afterDivision = polynomialToExpression3(m, i, nsVariableNames).toMathML(printOptions);
            if (!oldMatrix2.e(i, j).equals(Expression.ONE)) {
                mstr += "<div>";
                //mstr += "<b>"; // does not work in Firefox 52 (Windows XP) with MathML
                mstr += "<math>";
                mstr += "<mrow style=\"font-weight: bolder\">";
                mstr += new Expression.Symbol(variableNames[j]).toMathML(printOptions);
                mstr += "<mo>=</mo>";
                mstr += afterDivision;
                mstr += "</mrow>";
                mstr += "</math>";
                //mstr += "</b>";
                mstr += "</div>";
            }
            mstr += "</div>";
            mstr += "</li>";
        });
        mstr += "</ul>";
        var solutionsExpressions = new Array(m.cols() - 1);
        for (var i = 0; i < m.cols() - 1; i += 1) {
            solutionsExpressions[i] = Matrix.getPivotRow(m, i) === -1 ? nsVariableNames[i] : new NonSimplifiedExpression(polynomialToExpression3(m, Matrix.getPivotRow(m, i), nsVariableNames));
        }
        var solutionsExpressionsData = new Array(1);
        solutionsExpressionsData[0] = solutionsExpressions;
        var solutionsExpressionsMatrix = new Matrix(solutionsExpressionsData).transpose();
        if (true) {
            mstr += "<div>" + i18n.systems.answer + "</div>";
            if (condition != undefined && !condition.isTrue()) {
                mstr += "<div class=\"like-table\">";
            }
            mstr += "<ul class=\"list-unstyled\">";
            for (var i = 0; i < m.cols() - 1; i += 1) {
                mstr += "<li>";
                mstr += "<math>";
                mstr += new Expression.Symbol(variableNames[i]).toMathML(printOptions) + "<mo>=</mo>" + solutionsExpressions[i].toMathML(printOptions);
                mstr += "</math>";
                mstr += "</li>";
            }
            mstr += "</ul>";
            //?
            if (condition != undefined && !condition.isTrue()) {
                mstr += "<math>";
                mstr += "<mrow><mo>(</mo>";
                mstr += condition.toMathML(printOptions);
                mstr += "<mo>)</mo></mrow>";
                mstr += "</math>";
                if (typeof hit === "function") {
                    hit({
                        condition: condition.toString() + "::" + m.toString()
                    });
                }
                mstr += "</div>";
            }
            //?
        }

        if (true) {
            //TODO: remove - ?
            mstr += "<div>" + i18n.systems.generalSolution + " " + "<math>" + "<mi>X</mi><mo>=</mo>" + new Expression.Matrix(solutionsExpressionsMatrix).toMathML(printOptions) + "</math>" + "</div>";
        }
        if (isHomogeneous(m)) {
            var solutionSet = Matrix.getSolutionSet(m);
            if (solutionSet.basisVectors.length > 0) {
                var fundamentalSystemHTML = '';
                fundamentalSystemHTML += '<math>';
                fundamentalSystemHTML += '<mrow>';
                fundamentalSystemHTML += '<mo stretchy="false">{</mo>';
                fundamentalSystemHTML += solutionSet.basisVectors.length !== 1 ? '<mrow>' : '';
                for (var i = 0; i < solutionSet.basisVectors.length; i += 1) {
                    var basisVector = new Expression.Matrix(solutionSet.basisVectors[i]);
                    var freeVariable = nsVariableNames[solutionSet.variables[i]];
                    fundamentalSystemHTML += i !== 0 ? '<mo>+</mo>' : '';
                    fundamentalSystemHTML += '<mrow>' + freeVariable.toMathML(printOptions) + '<mo>&sdot;</mo>' + basisVector.toMathML(printOptions) + '</mrow>';
                }
                fundamentalSystemHTML += solutionSet.basisVectors.length !== 1 ? '</mrow>' : '';
                fundamentalSystemHTML += '<mo stretchy="false">}</mo>';
                fundamentalSystemHTML += '</mrow>';
                fundamentalSystemHTML += '</math>';
                mstr += '<div>' + i18n.systems.fundamentalSystem + ' ' + fundamentalSystemHTML + '</div>';
            }
        }
        return {
            html: mstr
        };
    };
    Expression.Details.add({
        type: "solve-using-Cramer's-rule",
        i18n: function() {
            return i18n.slu.solveByCrammer;
        },
        minRows: 1,
        callback: function(printOptions, matrix, variableNames) {
            return solveUsingCramersRule(printOptions, matrix, variableNames);
        }
    });
    Expression.Details.add({
        type: "solve-using-inverse-matrix-method",
        i18n: function() {
            return i18n.slu.solveByInverse;
        },
        minRows: 1,
        callback: function(printOptions, matrix, variableNames) {
            return solveUsingInverseMatrixMethod(printOptions, matrix, variableNames);
        }
    });

    //TODO: ?
    Polynomial.toM1 = function(c, np, roots) {
        var e = undefined;
        if (!c.equals(Expression.ONE)) {
            if (!c.equals(Expression.ONE.negate())) {
                c = new NonSimplifiedExpression(c);
            }
            e = e != undefined ? new Expression.Multiplication(e, c) : c;
        }
        if (np.getDegree() === 0) {
            var x = np.getCoefficient(0);
            if (!x.equals(Expression.ONE)) {
                e = e != undefined ? new Expression.Multiplication(x, e) : x;
            }
        }
        //TODO: fix
        var multiplicity = 1;
        for (var i = 0; i < roots.length; i += 1) {
            var next = i < roots.length ? roots[i + 1] : null;
            if (roots[i] !== next) {
                var p = Polynomial.of(roots[i].negate(), Expression.ONE);
                var w = new Expression.Polynomial(p);
                if (multiplicity !== 1) {
                    w = new Expression.Exponentiation(w, Expression.Integer.fromNumber(multiplicity));
                }
                e = e != undefined ? new Expression.Multiplication(e, w) : w;
                multiplicity = 1;
            } else {
                multiplicity += 1;
            }
        }
        if (roots.length === 0 || np.getDegree() !== 0) {
            //TODO: remove brackets
            var w = new Expression.Polynomial(np);
            e = e != undefined ? new Expression.Multiplication(e, w) : w;
            //html += "<mrow><mo>(</mo>" + np.toMathML(printOptions) + "<mo>)</mo></mrow>";
        }

        return e;
    };

    // -------------------------------------------- vectors -------------------------------------------

    var polynomialRootsCallback = function(info, printOptions) {
        var result = "";
        var link = "";
        if (info.type === "useTheRationalRootTest") {
            link = i18n.useTheRationalRootTestLink;
        } else if (info.type === "solveQuadraticEquation") {
            link = i18n.solveQuadraticEquationLink;
        } else if (info.type === "solvePalindromicEquaion") {
            link = i18n.solvePalindromicEquaionLink;
        } else if (info.type === "(ax+b)**n") {
            link = i18n.binomialTheoremLink;
        } else if (info.type === "solveCubicEquation") {
            //?
            //TODO:
            link = i18n.solveCubicEquationLink;
        } else if (info.type === "solveQuarticEcuation") {
            //TODO: move
            link = i18n.solveQuarticEquationLink;
        } else if (info.type === "methodOfKronecker") {
            //?
            link = i18n.methodOfKroneckerLink;
        } else if (info.type === "applyDifferenceOfSquaresRule") {
            link = i18n.applyDifferenceOfSquaresRuleLink;
        } else if (info.type === "applyDifferenceOfCubesRule") {
            link = i18n.applyDifferenceOfCubesRuleLink;
        } else if (info.type === "applyDifferenceOfNthPowersRule") {
            link = i18n.applyDifferenceOfNthPowersRuleLink;
        } else if (info.type === "methodOfIntroducingANewVariable") {
            //TODO: ?
            link = '<math><mi>t</mi><mo>=</mo>' + info.t.toMathML() + '</math> - <a href="https://www.youtube.com/watch?v=_ou4r21swX4" title="Метод введения новой переменной">(?)</a>';
        } else if (info.type === "factorOutTheGreatestCommonFactor") {
            //TODO: ?
        } else if (info.type === "solveLinearEquation") {
            return ""; //!?
        } else if (info.type === "squareFreeFactorization") {
            link = i18n.squareFreeFactorizationLink;
        } else if (info.type === "eliminationOfTheSubDominantTerm") {
            link = "https://en.wikipedia.org/wiki/Algebraic_equation#Elimination_of_the_sub-dominant_term"; //TODO: ?
            var title = "Elimination of the sub-dominant term";
            //TODO: variable names
            var tmp = Expression.p("x=t-b/(n*a)", {
                b: info.b,
                n: Expression.Integer.fromNumber(info.n),
                a: info.a
            }, printOptions);
            result = '<munder accentunder="true"><mo>=</mo><munder accentunder="true"><mrow>' + tmp + '</mrow><mtext><a href="' + link + '" title="' + title + '">(?)</a></mtext></munder></munder>';
        } else if (info.type === "realRootIsolationAndNewton'sMethod") {
            //TODO: "Используем численные методы (метод на основе правила знаков Декарта и метод Ньютона)"
            //TODO: what about complex roots - ?
            link = i18n.realRootIsolationAndNewtonsMethod;
            link = '<span style="max-width:9em;max-width:min-content;display:block;min-width:5em;">' + link + '</span>';
            result = link === "" ? "<mo>&asymp;</mo>" : "<munder accentunder=\"true\"><mo>&asymp;</mo><mtext>" + link + "</mtext></munder>";
        } else {
            //?
            //TODO: fix
            if (info.type !== "t = x^g") {
                console.assert(false);
            }
        }
        if (result === "") {
            if (info.type === "t = x^g" || link === "" && (info.type === "applyDifferenceOfSquaresRule" || info.type === "applyDifferenceOfCubesRule" || info.type === "applyDifferenceOfNthPowersRule")) {
                var variableName = printOptions.polynomialVariable;
                result += "<munder accentunder=\"true\"><mo>=</mo><mrow><mi>t</mi><mo>=</mo><msup><mi>${x}</mi><mn>${g}</mn></msup></mrow></munder>".replace(/\$\{x\}/g, variableName).replace(/\$\{g\}/g, localeString(info.g));
            } else {
                result += link === "" ? "<mo>=</mo>" : "<munder accentunder=\"true\"><mo>=</mo><mtext>" + link + "</mtext></munder>";
            }
        }
        result += Polynomial.toM1(info.content, info.newPolynomial, info.roots).toMathML(Object.assign({}, printOptions, info.newPolynomialVariable != undefined ? {
            polynomialVariable: info.newPolynomialVariable
        } : {}));
        return result;
    };
    Expression.getEigenvaluesWithSteps = function(printOptions, matrix) {
        var variableName = "λ";
        var lambda = new Expression.Symbol(variableName);
        printOptions = Object.assign({}, printOptions, {
            polynomialVariable: lambda
        });
        var characteristicPolynomial = null;
        var steps = "";
        var eigenvalues = Expression.getEigenvalues(matrix, function(info) {
            if (characteristicPolynomial == null) {
                characteristicPolynomial = info;
            } else {
                steps += polynomialRootsCallback(info, printOptions);
            }
        });

        //?
        var html = "";
        //TODO: improve i18n (links to Wikipedia)
        var matrixWithLambdas = matrix.map(function(element, i, j) {
            return new NonSimplifiedExpression(i === j ? new Expression.Addition(new NonSimplifiedExpression(element), new Expression.Negation(lambda)) : element);
        });
        var args = {
            v: new Expression.MatrixSymbol('v'),
            A: new Expression.MatrixSymbol('A')
        };
        var mathml = function(s) {
            return s.replace(/\$\{([^\}]+)\}/g, function(p, s) {
                return '<math' + (/[\*\-]/.test(s) ? ' display="block"' : '') + '>' + Expression.p(s.replace(/I/g, i18n.identityMatrixDenotation), args, {}) + '</math>';
            });
        };
        html += "<div>";
        html += mathml(i18n.eigenvalues.byDefinition);
        html += "</div>";
        html += "<div>";
        html += i18n.exponential.then;
        html += mathml("${A*v-λ*v=(A-λI)*v=0}");
        html += "</div>";
        html += "<div>";
        html += mathml(i18n.eigenvalues.equationHasNonZeroSolution);
        html += "</div>";
        //html += "<div>";
        //html += i18n.eigenvalues.findEigenvaluesFromTheCharacteristicPolynomial;
        //html += "</div>";
        html += "<div>";
        html += "<math>";
        html += Expression.p("|(A-λI)|".replace(/I/g, i18n.identityMatrixDenotation), args, {});
        html += "<mo>=</mo>";
        html += new Expression.Determinant(new Expression.Matrix(matrixWithLambdas)).toMathML(printOptions) + "<mo>=</mo>" + characteristicPolynomial.toMathML(printOptions);
        html += steps;
        html += "<mo>=</mo>";
        html += Expression.p(0);
        html += "</math>";
        html += "</div>";
        //?
        //TODO: fix
        html += createDetailsSummary(printOptions.idPrefix, [{
            type: "determinant",
            matrix: matrixWithLambdas.toString(),
            second: undefined
        }]);
        //?
        html += "<ol>";
        var n = -1;
        var uniqueEigenvalues = Expression.unique(eigenvalues);
        while (++n < uniqueEigenvalues.length) {
            var eigenvalue = uniqueEigenvalues[n];
            var equalsMathML = "<mo>" + (eigenvalue.isExact() ? "=" : "&asymp;") + "</mo>";
            //TODO: output algebraic multiplicity

            html += "<li>";
            html += "<math>";
            html += Expression.p("λ_" + (n + 1));
            html += equalsMathML;
            html += eigenvalue.toMathML(printOptions);
            html += "</math>";
            html += "</li>";
        }
        html += "</ol>";
        return {
            eigenvalues: eigenvalues,
            html: html
        };
    };
    Expression.getEigenvectorsWithSteps = function(printOptions, matrix, eigenvalues) {
        var eigenvectors = [];
        var html = "";
        html += "<div>";
        html += i18n.eigenvalues.findEigenvectorsForEveryEigenvalue.replaceAll('${λ}', '<math>' + Expression.p('λ') + '</math>');
        html += "</div>";
        html += "<ol>";
        for (var i = 0; i < eigenvalues.length; i += 1) {
            html += "<li>";
            var mm = matrix.subtract(Matrix.I(matrix.cols()).scale(eigenvalues[i])); // matrix - E * eigenvalue
            var fullMatrix = mm.augment(Matrix.Zero(mm.cols(), 1));
            var equalsMathML = "<mo>" + (eigenvalues[i].isExact() ? "=" : "&asymp;") + "</mo>";
            var args = {
                v: new Expression.MatrixSymbol('v'),
                A: new Expression.MatrixSymbol('A')
            };

            // TODO: fix output for diagonalization - instead of `X = {{0}, {c_1}, {0}}` should be `... var c_1 = 1, then X = {{0}, {1}, {0}}`
            html += "<div class=\"anchor\" id=\"" + (printOptions.idPrefix + "-eigenvalue-" + (i + 1)) + "\">";
            html += "<math>";
            html += new Expression.Symbol('λ_' + (i + 1)).toMathML(printOptions);
            html += equalsMathML;
            html += eigenvalues[i].toMathML(printOptions);
            html += "</math>";
            html += "</div>";

            //TODO: syncronize the ExpressionParser with i18n.identityMatrixDenotation
            //TODO: a tooltip for identityMatrixDenotation - identity Matrix
            //TODO: invisible times (&it;) -> middle dot - ?

            html += "<div>";
            html += "<math>";
            html += Expression.p("A-λ_i*I".replace(/i/g, (i + 1).toString()).replace(/I/g, i18n.identityMatrixDenotation), args, {}).replace(/&times;/g, '&sdot;');
            html += equalsMathML;
            html += new Expression.Matrix(mm).toMathML(printOptions);
            html += "</math>";
            html += "</div>";

            // Av=\lambda v
            html += "<div>";
            html += "<math>" + Expression.p("A*v=λ*v", args, {}) + "</math>";
            html += " ";
            html += i18n.eigenvalueEquationLink; //TODO: remove the link - ?
            html += "</div>";
            // (A-\lambda E)v=0
            html += "<div>";
            html += "<math>" + Expression.p("(A-λ*I)*v=0".replace(/I/g, i18n.identityMatrixDenotation), args, {}).replace(/&times;/g, '&sdot;') + "</math>";
            html += "</div>";
            html += "<div>";
            //TODO: text says by "Gaussian Elimination", but really we solve it by Gauss-Jordan elimination...
            html += i18n.eigenvalues.letsSolveHomogeneouseSystem;
            html += "</div>";

            //TODO:
            //html += createDetailsSummary(printOptions.idPrefix, [{type: "solve", matrix: fullMatrix.toString(), second: undefined}]);

            //TODO: Matrix.GaussMontante

            var variableNames = makeDefaultVariableNames(fullMatrix.cols() - 1);
            var solutionSet = undefined;
            var solutionHTML = "";
            solutionHTML += Expression.rowReductionGaussJordanMontante(fullMatrix, Matrix.GaussJordan, "solving", Object.assign({}, printOptions, {
                columnlines: -1
            }), function(result) {
                var tmp = Expression.solveByGaussNext(result, printOptions, variableNames);
                solutionSet = Matrix.getSolutionSet(result.matrix);
                return tmp.html;
            }, true);
            html += "<div>" + solutionHTML + "</div>";
            html += "<div>";
            for (var j = 0; j < solutionSet.basisVectors.length; j += 1) {
                var eigenvector = solutionSet.basisVectors[j];
                eigenvectors.push(eigenvector);
                var index = eigenvectors.length;
                //TODO: <li> - ?
                html += j !== 0 ? "; " : "";
                html += i18n.eigenvalues.Let;
                html += " ";
                for (var k = 0; k < solutionSet.variables.length; k += 1) {
                    html += k !== 0 ? ", " : "";
                    html += "<math>";
                    html += new Expression.Symbol(variableNames[solutionSet.variables[k]]).toMathML(printOptions) + "<mo>=</mo>" + Expression.p(k === j ? 1 : 0);
                    html += "</math>";
                }
                html += ", ";
                html += "<span class=\"inline-block anchor\" id=\"" + (printOptions.idPrefix + "-eigenvector-" + index) + "\">";
                html += "<math>";
                html += "<mrow style=\"font-weight: bolder\">";
                html += Expression.p("v_0=V", {
                    v_0: new Expression.MatrixSymbol('v_' + index),
                    V: new Expression.Matrix(eigenvector)
                }, printOptions);
                html += "</mrow>";
                html += "</math>";
                html += "</span>";
            }
            html += "</div>";
            html += "</li>";
        }
        html += "</ol>";
        return {
            html: html,
            eigenvectors: eigenvectors
        };
    };

    // --------------------------------------------- end ----------------------------------------------

    // --------------------------------------------- end ----------------------------------------------

    // 1286

    //TODO: remove ?
    var polyfromtable = function(m) {
        var coefficients = new Array(m.cols());
        for (var i = 0; i < m.cols(); i += 1) {
            coefficients[i] = m.e(0, m.cols() - 1 - i);
        }
        return Polynomial.from(coefficients);
    };
    Expression.Details.add({
        type: "polynomial-roots",
        minRows: 1,
        callback: function(printOptions, matrix, second) {
            var polynomial = polyfromtable(matrix);
            var variable = second == undefined ? undefined : second.variable;
            variable = variable == undefined ? new Expression.Symbol("x") : variable;
            printOptions = Object.assign({}, printOptions, {
                polynomialVariable: variable
            });
            var steps = "";
            var roots = Expression.getPolynomialRootsWithSteps(polynomial, function(info) {
                steps += polynomialRootsCallback(info, printOptions);
            });
            var html = "";
            html += "<div>";
            html += "<math>";
            var p = polynomial.toMathML(printOptions);
            html += p;
            if (steps !== '<mo>=</mo>' + p) {
                html += steps;
            }
            html += "<mo>=</mo>";
            html += Expression.p(0);
            html += "</math>";
            html += "</div>";
            html += "<div>";
            html += i18n.misc.roots;
            if (roots.length === 0) {
                html += " ? ";
            }
            var totalRoots = 0;
            html += "<ul>";
            var uniqueRoots = Expression.unique(roots);
            for (var k = 0; k < uniqueRoots.length; k += 1) {
                var root = uniqueRoots[k];
                var multiplicity = roots.reduce(function(count, e) {
                    return count + (e === root ? 1 : 0);
                }, 0);
                for (var j = 0; j < multiplicity; j += 1) {
                    html += "<li>" + "<math>" + (root.isExact() ? "" : "<mo>&asymp;</mo>") + root.toMathML(printOptions) + "</math>" + "</li>";
                    totalRoots += 1;
                }
            }
            if (totalRoots < polynomial.getDegree()) {
                html += "<em>" + i18n.notAllRootsHaveBeenFound + "</em>"; //TODO: ?
            }

            html += "</ul>";
            html += "</div>";
            return html;
        }
    });
    Expression.Details.add({
        type: "polynomial-multiply",
        minRows: 1,
        callback: function(printOptions, matrix, second) {
            var pA = polyfromtable(matrix);
            var pB = polyfromtable(second.matrix);
            var result = pA.multiply(pB);
            return "<math>" + "<mrow>" + "<mrow><mo>(</mo>" + pA.toMathML(printOptions) + "<mo>)</mo></mrow>" + "<mo>&sdot;</mo>" + "<mrow><mo>(</mo>" + pB.toMathML(printOptions) + "<mo>)</mo></mrow>" + "</mrow>" + "<mo>=</mo>" + result.toMathML(printOptions) + "</math>";
        }
    });
    RPN.getPositionInfo = function() {
        return {
            input: ExpressionParser.input,
            startPosition: ExpressionParser.startPosition,
            endPosition: ExpressionParser.endPosition,
            p: RPN.p
        };
    };
    RPN.getMatrix = function(s) {
        // TODO: insertion with drag and drop should not freeze all because of calculations
        var matrix = undefined;
        if (matrix == undefined) {
            //TODO: fix or remove - ?
            if (/\=/.test(s)) {
                //?
                try {
                    var tmp = getAugmentedSystemMatrix(s);
                    //if (tmp != undefined) {
                    //  matrix = Matrix.toMatrix(tmp.elements);
                    //}
                    var elements = tmp.elements;
                    var variableNames = tmp.variableNames; //TODO: test
                    return {
                        elements: elements,
                        variableNames: variableNames
                    };
                } catch (error) {
                    console.log(error);
                }
            }
        }
        if (matrix == undefined) {
            if (/[\t\n\r]/.test(s.trim().replace(/([\}\\])\s*\n/g, '$1').replace(/\n\s*([\\])/g, '$1'))) {
                //try {
                //TODO: should it throw in case of errors?
                var elements = Matrix.split(s.trim());
                try {
                    matrix = Matrix.toMatrix(elements);
                    if (matrix.rows() === 1 && matrix.cols() === 1 && matrix.e(0, 0).unwrap() instanceof Expression.Matrix) {
                        matrix = matrix.e(0, 0);
                        elements = elements[0][0]; //TODO: test
                    }
                } catch (error) {
                    console.error(error);
                }
                //!new 2020-04-06
                //TODO:
                return {
                    elements: elements,
                    variableNames: undefined
                };
                //} catch (error) {
                //  console.log(error);
                //}
            }
        }

        //!new 2020-07-04
        var table = getTableFromAsciiMathMatrix(s);
        if (table != null) {
            return {
                elements: table,
                variableNames: undefined
            };
        }
        //!

        //!!!!
        if (matrix == undefined) {
            var result = undefined;
            try {
                result = ExpressionParser.parse(s, new ExpressionParser.Context()); // to avoid simplification ({{cos(x),sin(x)},{-sin(x),cos(x)}}*{{cos(x),-sin(x)},{sin(x),cos(x)}})
                //result = ExpressionParser.parse(s);
            } catch (error) {
                // TODO: handle errors (?)
                // ???
                throw error;
            }
            //TODO: system of equations (?)
            matrix = result instanceof Matrix ? result : result instanceof Expression.Matrix ? result.matrix : result instanceof NonSimplifiedExpression && result.e instanceof Expression.Matrix ? result.e.matrix : undefined;
        }
        //!!!

        // TODO: fix: the input should match the raw input
        var elements = null;
        if (matrix != null) {
            elements = [];
            for (var i = 0; i < matrix.rows(); i += 1) {
                var row = [];
                for (var j = 0; j < matrix.cols(); j += 1) {
                    row.push(matrix.e(i, j).toString());
                }
                elements.push(row);
            }
        }
        return {
            elements: elements,
            variableNames: undefined
        };
    };
    RPN.p = 0; //!
    RPN.checkExpressions = function(textareaValue, type) {
        var resultRows = undefined;
        //?
        //!!!
        if (type === "system") {
            // to support custom input in SLE: 3x+y-2z=2; 2x+y-1=3; ...
            resultRows = getAugmentedSystemMatrix(textareaValue);
        }
        //!!!
        if (resultRows == undefined) {
            resultRows = Matrix.split(textareaValue);
        }
        var elements = resultRows;
        RPN.p = 0;
        for (var i = 0; i < elements.length; i += 1) {
            for (var j = 0; j < elements[i].length; j += 1) {
                var value = elements[i][j];
                //TODO: fix
                var isValid = RPN.checkExpression(value || "0");
                if (!isValid) {
                    return false;
                }
                RPN.p += value.length;
            }
        }
        return true;
    };
    RPN.checkExpression = function(input) {
        //return ExpressionParser.parse(input) != undefined;
        return ExpressionParser.parse(input, new ExpressionParser.Context()) != undefined;
    };
    RPN.runExpression = function(input, kInputValue, kInputId, matrixTableStates, printOptions) {
        //!TODO: Details?
        var details = [];
        var listener = function(e) {
            details.push({
                type: e.type,
                matrix: e.data.matrix.toString(),
                second: e.second == undefined ? undefined : e.second.matrix.toString()
            });
        };
        Expression.callback = listener;
        var x = undefined;
        //HACK
        var variableNames = undefined;
        var resultError = undefined;
        var expressionString = undefined;
        var resultHTML = undefined;
        var resultMatrix = undefined;
        try {
            //TODO: fix
            var test = input.replace(/\s+/g, "");
            if (test === "A*X=B" || test === "AX=B" || test === "Ax=b") {
                test = "A*X=B";
            }
            if (test === "A*X=0" || test === "AX=0") {
                test = "A*X=0";
            }
            var matrixTableAState = matrixTableStates != undefined ? matrixTableStates["A"] : undefined;
            var matrixTableBState = matrixTableStates != undefined ? matrixTableStates["B"] : undefined;
            if (test === "A*X=B" && matrixTableAState != undefined && matrixTableBState != undefined || test === "A*X=0" && matrixTableAState != undefined) {
                //TODO: type !== "system" - ?
                var a0 = Matrix.toMatrix(RPN.getElementsArray(matrixTableAState).elements);
                var b0 = test !== "A*X=B" ? Matrix.Zero(a0.rows(), 1) : Matrix.toMatrix(RPN.getElementsArray(matrixTableBState).elements);
                //hit({click: test  + "-" + a0.rows().toString() + "x" + a0.cols().toString() + "-" + b0.rows().toString() + "x" + b0.cols().toString()});
                if (b0.rows() === a0.rows() && b0.cols() === 1) {
                    input = "solve-using-Montante-method(" + a0.augment(b0).toString() + ")";
                }
            }
            if (input.replace(/^\s+|\s+$/g, "") === "") {
                throw new RangeError("ValueMissingError:" + "expression");
            }
            x = ExpressionParser.parse(input, new ExpressionParser.Context(function(id) {
                if ((id === "k" || id === "K") && kInputValue != undefined) {
                    var value = kInputValue;
                    if (value.replace(/^\s+|\s+$/g, "") === "") {
                        throw new RangeError("ValueMissingError:" + kInputId);
                    }
                    return ExpressionParser.parse(value, new ExpressionParser.Context());
                }
                if (id === "X" || id === "Y") {
                    return new Expression.MatrixSymbol(id);
                }
                var matrixTableState = matrixTableStates != undefined && Object.prototype.hasOwnProperty.call(matrixTableStates, id) ? matrixTableStates[id] : undefined;
                if (matrixTableState == undefined) {
                    return undefined;
                }
                var tmp = RPN.getElementsArray(matrixTableState);
                if (tmp.elements.length === 0) {
                    throw new RangeError("ValueMissingError:" + matrixTableState.firstInputElementId);
                }
                var names = tmp.variableNames;
                var matrix = Matrix.toMatrix(tmp.elements);
                variableNames = names; //!
                return new Expression.Matrix(matrix);
            }));

            //TODO: remove

            var tmp = getResultAndHTML(x, variableNames, x.simplify(), printOptions);
            var result = tmp.result;
            resultHTML = tmp.html;
            var matrix = undefined;
            if (result instanceof Matrix) {
                matrix = result;
            } else if (result instanceof Expression.Matrix) {
                matrix = result.matrix;
            } else if (result instanceof NonSimplifiedExpression && result.e instanceof Expression.Matrix) {
                matrix = result.e.matrix;
            } else if (result instanceof Expression.Equality && result.b instanceof Expression.Matrix) {
                //!new 2018-12-29
                matrix = result.b.matrix;
            }
            resultMatrix = matrix != undefined ? matrix.toString() : "";
            expressionString = x.toString();
        } catch (error) {
            resultError = error;
        }
        Expression.callback = undefined;
        var detailsHTML = createDetailsSummary(printOptions == null ? "g" : printOptions.idPrefix, details, details.length === 1 ? 100 : 1);
        return {
            resultError: resultError,
            details: details,
            expressionString: expressionString,
            resultHTML: resultHTML,
            resultMatrix: resultMatrix,
            detailsHTML: detailsHTML
        };
    };
    RPN.getDetails = function(data, printOptions) {
        var callback = Expression.Details.getCallback(data.type);
        if (callback == undefined) {
            throw new Error(data.type);
        }
        var matrix = ExpressionParser.parse(data.matrix).matrix; //?
        var second = data.second != undefined ? ExpressionParser.parse(data.second).matrix : undefined;
        var html = callback(printOptions, matrix, second);
        return html;
    };

    // TODO: fix?

    //export createDetailsSummary;
    //TODO: remove createDetailsSummary

    RPN.createDetailsSummary = createDetailsSummary;
    globalThis.RPN = RPN;
    Expression.Details.add({
        type: "system-of-equations",
        minRows: 1,
        //?
        callback: function(printOptions, nothing, system) {
            var equations = system.equations;
            if (equations == null) {
                // backward-compatibility //TODO: ?
                equations = [{
                    left: system.s,
                    right: system.b
                }];
            }
            var html = "";

            //TODO: move
            var rows = null;
            var cols = null;
            var getNumberSolutionFor = function(condition, variable) {
                var s = condition.getSolutionFor(variable);
                return s instanceof Expression.Integer ? s.toNumber() : null;
            };

            // TODO: ???
            if (equations.length === 1 && (equations[0].sign || "=") == "=") {
                //TODO: ?
                var s = equations[0].left;
                var b = equations[0].right;
                html += "<div>";
                html += "<math>";
                html += s.toMathML(printOptions) + "<mo>=</mo>" + b.toMathML(printOptions);
                html += "</math>";
                html += "</div>";
                if (s instanceof Expression.Exponentiation && Expression.has(s, Expression.MatrixSymbol) && b instanceof Expression.Matrix) {
                    //TODO: ?
                    s = s.inverse();
                    b = b.inverse(); //TODO: condition
                }

                //!new 2019-12-08
                if (Expression.has(b, Expression.MatrixSymbol)) {
                    //?TODO: ?
                    s = s.subtract(b);
                    //b = b.subtract(b); TODO: fix when X*{{1}}-X*{{1}}
                    b = Expression.ZERO;
                }

                //!new 2020-14-06
                if (Expression.has(s, Expression.MatrixSymbol)) {
                    //?TODO: ?
                    s = s.subtract(b);
                    b = Expression.ZERO;
                }
                if (!(s.subtract(b) instanceof Expression.Division)) {
                    var tmp = Expression.splitX(s.subtract(b));
                    if (tmp != null && tmp.x instanceof Expression.Exponentiation && tmp.x.b.isNegative()) {
                        if (!Expression.has(s, Expression.Determinant)) {
                            //TODO: FIX Expression.splitX(...) instead - ?
                            //?
                            //TODO: test, fix, remove(in case Condition will work better)
                            s = s.multiply(tmp.x.inverse());
                            b = b.multiply(tmp.x.inverse());
                        }
                    }
                }
                if ((s instanceof Expression.Addition || s instanceof Expression.Multiplication) && Expression.has(s, Expression.MatrixSymbol)) {
                    //TODO: FIX BUGS!!!
                    //var tmp = Expression.splitX(s);
                    //cols = tmp.l != null && tmp.r != null ? tmp.l.matrix.rows() : null;
                    //rows = tmp.l != null && tmp.r != null ? tmp.r.matrix.rows() : null;
                    if (cols == null || rows == null) {
                        var c = Condition.TRUE;
                        var size = function(e) {
                            if (e instanceof Expression.Addition) {
                                var a = size(e.a);
                                var b = size(e.b);
                                if (a == null || b == null) {
                                    return a || b;
                                }
                                c = c.andZero(a.rows.subtract(b.rows));
                                c = c.andZero(a.cols.subtract(b.cols));
                                return a;
                            }
                            if (e instanceof Expression.Multiplication) {
                                var a = size(e.a);
                                var b = size(e.b);
                                if (a == null || b == null) {
                                    return a || b;
                                }
                                c = c.andZero(a.cols.subtract(b.rows));
                                return {
                                    rows: a.rows,
                                    cols: b.cols
                                };
                            }
                            if (e instanceof Expression.Exponentiation) {
                                var a = size(e.a);
                                if (a == null) {
                                    return a;
                                }
                                c = c.andZero(a.cols.subtract(a.rows));
                                return a;
                            }
                            if (e instanceof Expression.MatrixSymbol) {
                                return {
                                    rows: new Expression.Symbol("rows" + e.symbol),
                                    cols: new Expression.Symbol("cols" + e.symbol)
                                };
                            }
                            if (e instanceof Expression.Matrix) {
                                return {
                                    rows: Expression.Integer.fromNumber(e.matrix.rows()),
                                    cols: Expression.Integer.fromNumber(e.matrix.cols())
                                };
                            }
                            if (Expression.isScalar(e)) {
                                return null;
                            }
                            if (e instanceof Expression.Determinant) {
                                //TODO: ?
                                return null;
                            }
                            throw new TypeError("NotSupportedError");
                        };
                        var tmp0 = size(s);
                        //TODO: ?
                        //console.log(c + '');
                        //TODO: for all matrix symbols do the replacement,
                        // then back (?)
                        if (c.isFalse()) {
                            throw new RangeError("DimensionMismatchException"); //TODO: ?
                        }

                        rows = getNumberSolutionFor(c, new Expression.Symbol('rows' + 'X'));
                        cols = getNumberSolutionFor(c, new Expression.Symbol('cols' + 'X'));
                        if (rows != null && cols == null && tmp0.rows instanceof Expression.Integer) {
                            //!2021-11-04 (hack), as for square matrices the right part is lost:
                            cols = tmp0.rows.toNumber();
                        }
                    }
                    if (cols != null && rows != null) {
                        var X = new Expression.Matrix(Matrix.Zero(rows, cols).map(function(e, i, j) {
                            //TODO use unique symbol names (?)
                            return new Expression.Symbol('x' + '_(' + (i + 1) + ',' + (j + 1) + ')');
                        }));
                        html += '<math>' + Expression.p("X=A", {
                            A: X
                        }, {}) + '</math>';
                        //s = RPN(s.toString(), new RPN.Context(function (id) {
                        //  return id === "X" ? X : null;
                        //}));
                        s = Expression._map(function(something) {
                            return something instanceof Expression.Symbol && something.symbol === "X" ? X : something;
                        }, s);
                        s = s.simplify();
                    }
                }
                equations = [];
                if (s instanceof Expression.Matrix) {
                    var m = s.matrix;
                    var bb = new Expression.Matrix(Matrix.Zero(m.rows(), m.cols()));
                    if (!b.equals(Expression.ZERO)) {
                        bb = bb.add(b);
                    }
                    bb = bb.matrix;
                    for (var i = 0; i < m.rows(); i += 1) {
                        for (var j = 0; j < m.cols(); j += 1) {
                            equations.push({
                                left: m.e(i, j),
                                right: bb.e(i, j)
                            });
                        }
                    }
                } else {
                    equations.push({
                        left: s,
                        right: b
                    });
                }
            }
            var getX = function(rows, cols, condition) {
                var NULL = new Expression.Symbol("NULL");
                var X = Matrix.Zero(rows, cols).map(function(e, i, j) {
                    //TODO use unique symbol names (?)
                    var s = new Expression.Symbol('x' + '_(' + (i + 1) + ',' + (j + 1) + ')');
                    var q = condition.getSolutionFor(s);
                    //TODO: with symbols (!!!)
                    return q != null && !Expression.has(q, Expression.Symbol) ? q : NULL;
                });
                for (var i = 0; i < rows; i += 1) {
                    for (var j = 0; j < cols; j += 1) {
                        if (X.e(i, j) === NULL) {
                            return null;
                        }
                    }
                }
                return new Expression.Matrix(X);
            };

            //TODO: fix
            html += "<div>";
            html += "<math>";
            html += "<mrow><mo>{</mo>";
            html += '<mtable rowspacing="0ex" columnalign="left">';
            var signs = {
                '=': '=',
                '!=': '≠',
                '>': '>',
                '<': '<'
            };
            for (var i = 0; i < equations.length; i += 1) {
                html += "<mtr><mtd>" + equations[i].left.toMathML(printOptions) + "<mo>" + signs[equations[i].sign || "="] + "</mo>" + equations[i].right.toMathML(printOptions) + "</mtd></mtr>";
            }
            html += '</mtable>';
            html += "</mrow>";
            html += "</math>";
            html += "</div>";

            //TODO: is linear - ?
            //TODO: matrices - ?
            var c = Condition.TRUE;
            for (var i = 0; i < equations.length; i += 1) {
                var x = equations[i].left.subtract(equations[i].right);
                var sign = equations[i].sign || "=";
                if (sign === "=") {
                    c = c.andZero(x);
                } else if (sign === '!=') {
                    c = c.andNotZero(x);
                } else if (sign === '>') {
                    c = c.andGreaterZero(x);
                } else if (sign === '<') {
                    c = c.andGreaterZero(x.negate());
                } else {
                    throw new TypeError();
                }
            }
            html += "<p>" + i18n.systems.answer + "</p>";
            html += "<p>";
            if (c.isFalse()) {
                html += i18n.systems.thereAreNoSolutions; // "&minus;";//TODO: ?
            } else if (c.isTrue()) {
                html += "✓"; //TODO: ?
            } else {
                var X = cols != null && rows != null ? getX(rows, cols, c) : null;
                if (X != null) {
                    html += "<math>" + Expression.p("X=A", {
                        A: X
                    }, printOptions) + "</math>";
                } else {
                    html += "<math>" + c.toMathML(printOptions) + "</math>";
                }
            }
            html += "</p>";
            return html;
        }
    });

    // SLE solution with inverse matrix
    var solveUsingLeastSquaresMethod = function(printOptions, fullMatrix, variableNames) {
        if (fullMatrix.cols() < 2) {
            throw new RangeError("ValueMissingError:A-textarea"); //TODO: fix
        }

        //TODO: use variableNames (?)

        var m = Matrix.trimRight(fullMatrix.slice(0, fullMatrix.rows(), 0, fullMatrix.cols() - 1));
        var b = fullMatrix.slice(0, fullMatrix.rows(), fullMatrix.cols() - 1, fullMatrix.cols());
        var X = m;
        var y = b;
        var beta1 = X.transpose().multiply(X).inverse().multiply(X.transpose()).multiply(y);

        //TODO: details from inverse method
        var s = '';
        s += "<div>";
        s += "<math>";
        s += outSystem(printOptions, fullMatrix, variableNames);
        s += "</math>";
        s += "</div>";

        //s += "<h4>" + i18n.systems.solutionByLinearLeastSquaresMethod + "</h4>";
        s += "<div>";
        s += "<math>";
        s += "<mrow><mi>A</mi><mo>&sdot;</mo><mi>X</mi></mrow><mo>=</mo><mi>B</mi>";
        s += "</math>";
        s += "</div>";
        s += "<div>";
        s += "<math>";
        s += "<mi>A</mi><mo>=</mo>" + new Expression.Matrix(m).toMathML(printOptions);
        s += "</math>";
        s += ', ';
        s += "<math>";
        s += "<mi>B</mi><mo>=</mo>" + new Expression.Matrix(b).toMathML(printOptions);
        s += "</math>";

        //s += '<math>' + Expression.p('A^T*A*X=A^T*B') + '</math>';
        s += '<div>';
        //TODO: explanation, i18n
        s += 'The solution can be found by formula <a href="https://en.wikipedia.org/wiki/Overdetermined_system#Approximate_solutions">(*)</a>:';
        s += '<div>';
        s += '<math>' + Expression.p('X=(A^T*A)^-1*(A^T*B)') + '</math>';
        s += '</div>';
        s += '</div>';
        s += 'Solution: ';
        s += '<math>' + Expression.p('X=x', {
            x: new Expression.Matrix(beta1)
        }, printOptions);
        if (printOptions.rounding == null) {
            s += '<mo>≈</mo>' + new Expression.Matrix(beta1).toMathML({
                rounding: {
                    fractionDigits: 3
                }
            });
        }
        s += '</math>';
        s += ', ';
        s += 'Residual: ' + '<math>';
        var r = y.subtract(X.multiply(beta1));
        s += Expression.p('R=B-A*X=r', {
            r: new Expression.Matrix(r)
        }, printOptions);
        if (printOptions.rounding == null) {
            s += '<mo>≈</mo>' + new Expression.Matrix(r).toMathML({
                rounding: {
                    fractionDigits: 3
                }
            });
        }
        s += '</math>';
        return s;
    };
    Expression.Details.add({
        type: "solve-using-least-squares-method",
        //i18n: function () {
        //  return i18n.slu.methodOfMontante;
        //},
        //minRows: 2,
        //priority: 2,//TODO: ?
        callback: function(printOptions, matrix, variableNames) {
            return solveUsingLeastSquaresMethod(printOptions, matrix, variableNames);
        }
    });
})();
(function() {
    "use strict";
    /*global i18n, Expression, Matrix, NonSimplifiedExpression*/


    var getSolveDetails = function(printOptions, matrix, variableNames, title, method) {
        if (matrix.cols() < 1) {
            //?
            throw new RangeError("ValueMissingError:A-textarea"); //TODO: fix
        }
        //if (variableNames == undefined) {
        var m = matrix.slice(0, matrix.rows(), 0, matrix.cols() - 1);
        var b = matrix.slice(0, matrix.rows(), matrix.cols() - 1, matrix.cols());
        matrix = Matrix.trimRight(m).augment(b);
        //}
        var html = "";
        html += "<h4>" + title + "</h4>";
        //html += "<div>" + i18n.unused.systems.augmentedMatrixOfTheSystem + "</div>";
        html += "<div>" + i18n.systems.convertTheAugmentedMatrixIntoTheRowEchelonForm + "</div>";
        html += Expression.rowReductionGaussJordanMontante(matrix, method, "solving", Object.assign({}, printOptions, {
            columnlines: -1
        }), function(result) {
            var tmp = Expression.solveByGaussNext(result, printOptions, variableNames);
            return tmp.html;
        });
        return html;
    };
    Expression.Details.add({
        type: "solve-using-Gaussian-elimination",
        i18n: function() {
            return i18n.slu.solveByGauss;
        },
        minRows: 1,
        callback: function(printOptions, matrix, variableNames) {
            return getSolveDetails(printOptions, matrix, variableNames, i18n.systems.solutionByGaussianElimination, Matrix.Gauss);
        }
    });
    Expression.Details.add({
        type: "solve-using-Gauss-Jordan-elimination",
        i18n: function() {
            return i18n.slu.solveByJordanGauss;
        },
        minRows: 1,
        callback: function(printOptions, matrix, variableNames) {
            return getSolveDetails(printOptions, matrix, variableNames, i18n.systems.solutionByGaussJordanElimination, Matrix.GaussJordan);
        }
    });
    Expression.Details.add({
        type: "solve-using-Montante-method",
        i18n: function() {
            return i18n.det.methodOfMontante;
        },
        minRows: 1,
        priority: 1,
        //TODO: ?
        callback: function(printOptions, matrix, variableNames) {
            return getSolveDetails(printOptions, matrix, variableNames, i18n.systems.solutionByMethodOfMontante, Matrix.GaussMontante);
        }
    });
    Expression.rowReduceChangeToHTMLMontante = function(args, printOptions, containerId, k, stepCondition) {
        var tooltipId = 'tooltip-' + containerId + '-' + k;
        var t = function(r, c, k) {
            var matrix = [
                ['a_(pivotRow,pivotColumn)', 'a_(pivotRow,j)'],
                ['a_(i,pivotColumn)', 'a_(i,j)']
            ];
            var det = new Expression.Determinant(new Expression.Matrix(Matrix.I(2).map(function(e, i, j) {
                return new Expression.Symbol(matrix[i][j].replaceAll('pivotRow', r + 1).replaceAll('pivotColumn', c + 1));
            }))).toMathML({
                useMatrixContainer: false
            });
            return "<mrow>" + "<mfrac>" + '<mrow id="' + tooltipId + '">' + det + '</mrow>' + new Expression.Symbol('p_${k}'.replaceAll('${k}', k + 1).replaceAll('p_0', '1')).toMathML() + "</mfrac>" + "<mo>&rarr;</mo>" + new Expression.Symbol('a_(i,j)').toMathML() + "</mrow>";
        };
        var cellId = function(matrixId, i, j) {
            return containerId + "-" + matrixId + "-" + i + "-" + j;
        };
        var html = "";
        if (true) {
            if (args.type === "swap" || args.type === "swap-negate") {
                html += Expression.rowReduceChangeToHTML(args, printOptions, containerId, k, stepCondition);
            } else if (args.type === "pivot") {
                var a0 = new Expression.Matrix(args.oldMatrix).toMathML(Object.assign({}, printOptions, {
                    columnlines: printOptions.columnlines,
                    cellIdGenerator: function(i, j) {
                        return cellId(k, i, j);
                    },
                    pivotCell: {
                        i: args.pivotRow,
                        j: args.pivotColumn
                    }
                }));
                var pivotElementText = "<mpadded width=\"+0.8em\" lspace=\"+0.4em\">" + "<munder accentunder=\"true\">" + "<mo stretchy=\"false\">~</mo>" + "<munder accentunder=\"true\">" + "<mtext>" + i18n.eliminationDetails.pivotElement + "</mtext>" + "<munder accentunder=\"true\">" + "<mrow>" + new Expression.Symbol("p_" + (k + 1)).toMathML() + "<mo>=</mo>" + new Expression.Symbol("a_(" + (args.pivotRow + 1) + "," + (args.pivotColumn + 1) + ")").toMathML() + "<mo>=</mo>" + args.oldMatrix.e(args.pivotRow, args.pivotColumn).toMathML(printOptions) + "</mrow>" + (stepCondition.isTrue() ? "" : "<munder accentunder=\"true\">") + t(args.pivotRow, args.pivotColumn, k - 1) + (stepCondition.isTrue() ? "" : stepCondition.toMathML(printOptions)) + (stepCondition.isTrue() ? "" : "</munder>") + "</munder>" + "</munder>" + "</munder>" + "</mpadded>";
                html += "<math>";
                html += a0 + pivotElementText;
                html += "</math>";
                k += 1;
                var text = "";
                var tooltip = '<a class="a-tooltip" data-for="' + tooltipId + '" hidden>' + "<math>" + Expression.p("(a_(pivotRow,pivotColumn)*a_(i,j)-a_(i,pivotColumn)*a_(pivotRow,j))".replaceAll('pivotRow', (args.pivotRow + 1).toString()).replaceAll('pivotColumn', (args.pivotColumn + 1).toString())) + "</math>" + '</a>';
                text += tooltip;
                for (var targetRow = 0; targetRow < args.oldMatrix.rows(); targetRow += 1) {
                    if (targetRow !== args.pivotRow) {
                        text += "<div>";
                        for (var i = 0; i < args.oldMatrix.cols(); i += 1) {
                            var highlight = "<a class=\"a-highlight\" data-for=\"" + cellId(k, targetRow, i) + "\" data-highlight=\"" + "#" + cellId(k - 1, args.pivotRow, args.pivotColumn) + ", " + "#" + cellId(k - 1, targetRow, i) + ", " + "#" + cellId(k - 1, targetRow, args.pivotColumn) + ", " + "#" + cellId(k - 1, args.pivotRow, i) + ", " + "#" + cellId(k, targetRow, i) + "\"></a>";
                            text += "<a class=\"a-tooltip\" data-for=\"" + cellId(k, targetRow, i) + "\" hidden>" + "<math>" + Expression.p("a_(" + (targetRow + 1) + "," + (i + 1) + ")=(a*b-c*d)/p=r", {
                                a: args.oldMatrix.e(args.pivotRow, args.pivotColumn),
                                b: args.oldMatrix.e(targetRow, i),
                                c: args.oldMatrix.e(targetRow, args.pivotColumn),
                                d: args.oldMatrix.e(args.pivotRow, i),
                                p: args.previousPivot,
                                r: args.newMatrix.e(targetRow, i)
                            }, printOptions) + "</math>" + "</a>" + highlight;
                        }
                        text += "</div>";
                    }
                }
                html += "<span hidden>" + text + "</span>";
            } else {
                throw new TypeError(args.type);
            }
        }
        //TODO: mathml, not html, no internal <math></math>
        return html;
    };
    var getDeterminantDetails = function(printOptions, matrix, method, title, header) {
        if (!matrix.isSquare()) {
            throw new RangeError("NonSquareMatrixException");
        }
        var html = "";
        html += "<div>";
        html += "<math>";
        html += new Expression.Determinant(new Expression.Matrix(matrix)).toMathML(printOptions) + "<mo>=</mo><mi>?</mi>";
        html += "</math>";
        html += "</div>";

        //?
        if (header != undefined) {
            html += "<h4>";
            html += header;
            html += "</h4>";
        }
        html += "<p>" + title + "</p>";
        html += Expression.rowReductionGaussJordanMontante(matrix, method, "determinant", printOptions, function(tmp) {
            var rowEchelonMatrix = tmp.matrix;
            var html = "";
            html += "<div>";
            html += "<math>";
            html += new Expression.Determinant(new Expression.Matrix(matrix)).toMathML(printOptions);
            html += "<mo>=</mo>";
            if (method === Matrix.Gauss) {
                html += new Expression.Determinant(new Expression.Matrix(rowEchelonMatrix)).toMathML(printOptions);
                html += "<mo>=</mo>";
                var result = rowEchelonMatrix.determinant();
                if (!result.equals(Expression.ZERO)) {
                    var det = rowEchelonMatrix.e(0, 0);
                    det = new NonSimplifiedExpression(det);
                    for (var j = 1; j < rowEchelonMatrix.rows(); j += 1) {
                        det = new Expression.Multiplication(det, rowEchelonMatrix.e(j, j)); //? usage of Expression.Multiplication to get 4 * 5 * 6 ...
                        det = new NonSimplifiedExpression(det);
                    }
                    html += det.toMathML(printOptions);
                    html += "<mo>=</mo>";
                }
                html += result.toMathML(printOptions);
            } else {
                var result = tmp.stoppedAtRow !== -1 ? Expression.ZERO : rowEchelonMatrix.e(rowEchelonMatrix.rows() - 1, rowEchelonMatrix.cols() - 1);
                html += result.toMathML(printOptions);
            }
            html += "</math>";
            html += "</div>";
            return html;
        });
        return html;
    };
    Expression.Details.add({
        type: "determinant-Gauss",
        i18n: function() {
            return i18n.det.methodOfGauss;
        },
        minRows: 3,
        callback: function(printOptions, matrix) {
            return getDeterminantDetails(printOptions, matrix, Matrix.Gauss, i18n.determinantDetails.start, undefined);
        }
    });
    Expression.Details.add({
        type: "determinant-Montante",
        i18n: function() {
            return i18n.det.methodOfMontante;
        },
        minRows: 3,
        priority: 1,
        //TODO: ?
        callback: function(printOptions, matrix) {
            var title = i18n.methodOfMontanteDetails.determinantDetails.start.replace(/\$\{someDetails3\}/g, Expression.getSomeDetails("someDetails3")).replace(/\$\{a_\(i,j\)\=\(a_\(r,c\)\*a_\(i,j\)\-a_\(i,c\)\*a_\(r,j\)\)\/p\}/g, "<math>" + Expression.p("a_(i,j)=(a_(r,c)*a_(i,j)-a_(i,c)*a_(r,j))/p") + "</math>").replace(/\$\{a_\(r,c\)\}/g, "<math>" + Expression.p("a_(r,c)") + "</math>").replace(/\$\{r\}/g, "<math>" + "<mi>r</mi>" + "</math>").replace(/\$\{c\}/g, "<math>" + "<mi>c</mi>" + "</math>").replace(/\$\{p\}/g, "<math>" + "<mi>p</mi>" + "</math>");
            return getDeterminantDetails(printOptions, matrix, Matrix.GaussMontante, title, i18n.methodOfMontanteDetails.determinantDetails.header);
        }
    });
    var getRankDetails = function(printOptions, matrix, method, title) {
        var html = "";
        html += "<div>";
        html += "<math>";
        html += new Expression.Rank(new Expression.Matrix(matrix)).toMathML(printOptions) + "<mo>=</mo><mi>?</mi>";
        html += "</math>";
        html += "</div>";
        if (title != undefined) {
            //TODO: remove
            html += "<p>" + title + "</p>";
        }
        html += Expression.rowReductionGaussJordanMontante(matrix, method, "", printOptions, function(tmp) {
            var rowEchelonMatrix = tmp.matrix;
            var html = "";
            html += "<div>";
            html += "<math>";
            html += new Expression.Rank(new Expression.Matrix(matrix)).toMathML(printOptions);
            html += "<mo>=</mo>";
            html += new Expression.Rank(new Expression.Matrix(rowEchelonMatrix)).toMathML(printOptions);
            html += "<mo>=</mo>";
            html += Expression.Integer.fromNumber(rowEchelonMatrix.rank()).toMathML();
            html += "</math>";
            html += "</div>";
            return html;
        }); //?
        return html;
    };
    Expression.Details.add({
        type: "rank-Gauss",
        i18n: function() {
            return i18n.det.methodOfGauss;
        },
        minRows: 2,
        callback: function(printOptions, matrix) {
            return getRankDetails(printOptions, matrix, Matrix.Gauss, i18n.rankDetails.start);
        }
    });
    Expression.Details.add({
        type: "rank-Montante",
        i18n: function() {
            return i18n.det.methodOfMontante;
        },
        minRows: 2,
        priority: 1,
        //TODO: ?
        callback: function(printOptions, matrix) {
            //TODO:
            //i18n.methodOfMontanteDetails.rankDetails.start
            return getRankDetails(printOptions, matrix, Matrix.GaussMontante, undefined);
        }
    });

    // TODO:
    // http://www.mathsisfun.com/algebra/matrix-inverse-row-operations-gauss-jordan.html
    // i18n.inverseDetails.rowSwapNegate = "- Trocamos o linha {s} e o linha {c}:, ...";

    var getInverseDetails = function(printOptions, matrix, method, title) {
        var html = "";
        html += "<div>";
        html += "<math>";
        html += new Expression.Exponentiation(new Expression.Matrix(matrix), Expression.ONE.negate()).toMathML(printOptions) + "<mo>=</mo><mi>?</mi>";
        html += "</math>";
        html += "</div>";
        if (title != undefined) {
            //TODO: remove
            html += "<p>" + title + "</p>";
        }
        //TODO: merge (?)
        var augmented = matrix.augment(Matrix.I(matrix.rows()));
        html += Expression.rowReductionGaussJordanMontante(augmented, method, "inverse", Object.assign({}, printOptions, {
            columnlines: -matrix.cols()
        }), function(tmp) {
            var augmentedResult = tmp.matrix;
            var hasZeroElement = false;
            for (var i = 0; i < augmentedResult.rows(); i += 1) {
                if (augmentedResult.e(i, i).equals(Expression.ZERO)) {
                    hasZeroElement = true;
                }
            }
            var html = "";
            if (!hasZeroElement) {
                var result2 = Matrix.Zero(matrix.rows(), matrix.rows()).map(function(element, i, j) {
                    // splitting to get the second half
                    return augmentedResult.e(i, j + augmentedResult.rows());
                });
                var result = result2.map(function(element, i, j) {
                    return element.divide(augmentedResult.e(i, i));
                });
                html += "<div>";
                html += "<math>";
                html += new Expression.Exponentiation(new Expression.Matrix(matrix), Expression.ONE.negate()).toMathML(printOptions);
                if (method === Matrix.GaussMontante) {
                    var c = augmentedResult.e(0, 0); //!
                    html += "<mo>=</mo>";
                    html += new Expression.Multiplication(new Expression.Division(Expression.ONE, c), new Expression.Matrix(result2)).toMathML(printOptions);
                }
                html += "<mo>=</mo>";
                html += new Expression.Matrix(result).toMathML(printOptions);
                html += "</math>";
                html += "</div>";
            } else {
                //TODO: ?
            }
            return html;
        });
        return html;
    };
    Expression.Details.add({
        type: "inverse-Gauss",
        i18n: function() {
            return i18n.inverse.methodOfGaussJordan;
        },
        minRows: 3,
        callback: function(printOptions, matrix) {
            return getInverseDetails(printOptions, matrix, Matrix.GaussJordan, i18n.inverseDetails.start);
        }
    });
    Expression.Details.add({
        type: "inverse-Montante",
        i18n: function() {
            return i18n.det.methodOfMontante;
        },
        minRows: 3,
        priority: 1,
        //TODO: ?
        callback: function(printOptions, matrix) {
            // TODO: i18n.methodOfMontanteDetails.inverseDetails.start
            return getInverseDetails(printOptions, matrix, Matrix.GaussMontante, undefined);
        }
    });
    Expression.Details.add({
        type: "LU-decomposition",
        i18n: function() {
            return i18n.index.LUDecomposition;
        },
        minRows: 2,
        callback: function(printOptions, matrix) {
            var palu = Expression.LUDecomposition(matrix);
            var html = "";
            html += "<div class=\"math-block\">";
            html += "<math>";
            html += Expression.p(palu.swapFlag ? "P*A=L*U" : "A=L*U", palu, printOptions);
            html += "</math>";
            html += "</div>";
            var detailsHTML = RPN.createDetailsSummary(printOptions.idPrefix, [{
                type: 'steps-to-find-LU-decomposition',
                matrix: matrix.toString(),
                second: undefined
            }]);
            return html + detailsHTML;
        }
    });
    Expression.Details.add({
        type: "steps-to-find-LU-decomposition",
        i18n: function() {
            return i18n.index.LUDecomposition;
        },
        minRows: 2,
        callback: function(printOptions, matrix) {
            var palu = Expression.LUDecomposition(matrix);
            var html = "";

            //TODO: fix
            html += Expression.rowReductionGaussJordanMontante(matrix, Matrix.Gauss, "LU-decomposition", Object.assign({}, printOptions, {
                isLUDecomposition: true
            }), function(result) {
                return "";
            });
            html += "<div class=\"math-block\">";
            //TODO: output P
            html += "<math>";
            html += Expression.p("L=M", {
                M: palu.L
            }, Object.assign({}, printOptions, {
                isLUDecomposition2: true
            }));
            html += "</math>";
            html += "<span>, </span>";
            html += "<math>";
            html += Expression.p("U=M", {
                U: new Expression.Symbol("U"),
                M: palu.U
            }, printOptions); // U - is not an IdentityMatrix
            html += "</math>";
            html += "</div>";
            return html;
        }
    });
    Expression.Details.add({
        type: "Gaussian-elimination",
        minRows: 2,
        callback: function(printOptions, matrix) {
            var c = 0;
            var html = "";
            Matrix.toRowEchelonWithCallback(matrix, Matrix.Gauss, "row-reduction", null, function(result) {
                c += 1;
                var condition = result.condition;
                var resultMatrix = result.matrix;
                if (!condition.isTrue()) {
                    html += "<li>";
                    html += "<div class=\"like-table\">";
                }
                html += "<math>";
                html += new Expression.Matrix(matrix).toMathML(printOptions);
                html += "<mo>~</mo>";
                html += new Expression.Matrix(resultMatrix).toMathML(printOptions);
                html += "</math>";
                if (!condition.isTrue()) {
                    html += "<math>";
                    html += "<mrow><mo>(</mo>";
                    html += condition.toMathML(printOptions);
                    html += "<mo>)</mo></mrow>";
                    html += "</math>";
                    html += "</div>";
                    html += "</li>";
                }
            });
            if (c > 1) {
                html = "<ul class=\"list-unstyled\">" + html + "</ul>";
            }
            var detailsHTML = RPN.createDetailsSummary(printOptions.idPrefix, [{
                type: 'steps-to-find-row-echelon-matrix',
                matrix: matrix.toString(),
                second: undefined
            }]);
            return html + detailsHTML;
        }
    });
    Expression.Details.add({
        type: "steps-to-find-row-echelon-matrix",
        minRows: 2,
        callback: function(printOptions, matrix) {
            var html = Expression.rowReductionGaussJordanMontante(matrix, Matrix.Gauss, "row-reduction", printOptions, function(tmp) {
                //var result = tmp.matrix;
                if (tmp.condition.isTrue() && tmp.matrix.eql(matrix)) {
                    return i18n.systems.theMatrixIsInRowEchelonForm;
                }
                return "";
            });
            return html;
        }
    });
})();
(function() {
    "use strict";
    /*global i18n, Expression, Matrix, NonSimplifiedExpression*/
    //TODO:
    //TODO:

    Expression.Details.add({
        type: "Cholesky-decomposition",
        minRows: 2,
        callback: function(printOptions, matrix) {
            var detailsHTML = RPN.createDetailsSummary(printOptions.idPrefix, [{
                type: 'steps-to-find-Cholesky-decomposition',
                matrix: matrix.toString(),
                second: undefined
            }]);
            try {
                var tmp = Expression.CholeskyDecomposition(matrix);
            } catch (error) {
                if (error.message === "NonPositiveDefiniteMatrix") {
                    return "<p>" + i18n.CholeskyDecomposition.theMatrixIsNotPositiveDefinite + "</p>" + detailsHTML;
                }
                throw error;
            }
            var L = tmp.L;
            var A = matrix;
            var html = "";
            html += "<div class=\"math-block\">";
            html += "<math>" + Expression.p("A=L*T", {
                A: new Expression.Matrix(A),
                L: new Expression.Matrix(L),
                T: new Expression.Matrix(L.transpose().map(function(e) {
                    return e.complexConjugate();
                }))
            }, printOptions) + "</math>";
            html += "</div>";
            return html + detailsHTML;
        }
    });
    Expression.Details.add({
        type: "svd",
        minRows: 2,
        callback: function(printOptions, matrix) {
            var detailsHTML = RPN.createDetailsSummary(printOptions.idPrefix, [{
                type: 'steps-to-find-SVD',
                matrix: matrix.toString(),
                second: undefined
            }]);
            var tmp = Expression.SVD(matrix);
            var A = matrix;
            var isReal = Expression.isRealMatrix(A);
            var html = "";
            html += "<div>";
            html += "<math>";
            html += Expression.p(isReal ? "A=U*S*V^T" : "A=U*S*V^{*}", {
                A: new Expression.Matrix(A),
                U: new Expression.Matrix(tmp.U),
                S: new Expression.Matrix(tmp.Sigma),
                V: new Expression.Matrix(tmp.Vstar.conjugateTranspose())
            }, printOptions);
            html += "</math>";
            html += "</div>";
            html += detailsHTML;
            return html;
        }
    });
    Expression.Details.add({
        type: "steps-to-find-SVD",
        //i18n: function () {
        //return i18n.index.SingularValueDecomposition;
        //},
        i18n: null,
        minRows: 2,
        callback: function(printOptions, matrix) {
            //TODO: !?
            var matrixSymbols = 'A:A U:U Σ:S V:V v_i:v_0 σ_i:σ_0 u_i:u_0'.split(' ');
            //runWithConsoleInfoToHTMLConversion(() => Expression.SVD(matrix));

            var html = '';

            //TODO: use ^T - for real, ^{*} - for complex

            var object = {};
            for (var iterators = matrixSymbols[globalThis.Symbol.iterator](), s = iterators.next().value; s != null; s = iterators.next().value) {
                var tmp = s.split(':');
                object[tmp[1]] = new Expression.MatrixSymbol(tmp[0]);
            }
            var replaceSomeSymbols = function(string) {
                for (var iterators = matrixSymbols[globalThis.Symbol.iterator](), s = iterators.next().value; s != null; s = iterators.next().value) {
                    var tmp = s.split(':');
                    string = string.replaceAll(tmp[0], tmp[1]);
                }
                return string;
            };
            for (var key in i18n.SVD) {
                if (Object.prototype.hasOwnProperty.call(i18n.SVD, key)) {
                    i18n.SVD[key] = '<p>' + i18n.SVD[key].replace(/\$\{([^\}]+)\}/g, function(p, e) {
                        return '<math>' + Expression.p(replaceSomeSymbols(e), object, {}) + '</math>';
                    }) + '</p>';
                }
            }
            var tmp = Expression.SVD(matrix);
            var U = tmp.U;
            var Sigma = tmp.Sigma;
            var V = tmp.Vstar.conjugateTranspose(); //TODO: !?

            html += i18n.SVD.definition;
            html += i18n.SVD.howToFind; //TODO: !?
            html += '<p>' + '<math>' + Expression.p('A=M', {
                A: new Expression.MatrixSymbol('A'),
                M: new Expression.Matrix(matrix)
            }, printOptions) + '</math>' + '</p>';
            html += '<ol>';
            html += '<li>';
            html += i18n.SVD.findEigenvaluesAndEigenvectorsOfATA;
            var detailsHTML = RPN.createDetailsSummary(printOptions.idPrefix, [{
                type: 'eigenvectors',
                matrix: matrix.conjugateTranspose().multiply(matrix).toString(),
                second: undefined
            }]);
            html += detailsHTML;
            html += i18n.SVD.orthonormalizedEigenvectors;
            html += '<ul class="list-unstyled">';
            // v_1 = ..., v_2 = ... - column vectors
            for (var i = 0; i < V.cols(); i += 1) {
                html += '<li>';
                html += '<math>' + Expression.p('v=x', {
                    v: new Expression.MatrixSymbol('v_i'.replaceAll('i', i + 1)),
                    x: new Expression.Matrix(V.col(i))
                }, printOptions) + '</math>';
                html += ', ';
                if (i < Sigma.cols() && i < Sigma.rows()) {
                    html += '<math>' + Expression.p('s=x=y', {
                        s: new Expression.Symbol('σ_i'.replaceAll('i', i + 1)),
                        x: new Expression.SquareRoot(Sigma.e(i, i)._pow(2)),
                        y: Sigma.e(i, i)
                    }, printOptions) + '</math>';
                }
                html += '</li>';
            }
            html += '</ul>';
            //TODO: property that distict eigenvalues have orthogonalized eigenvalues for symmetric matrices is used (link)
            html += '</li>';
            html += '<li>';
            html += i18n.SVD.constructSigmaFromSquareRootsOfTheEigenvaluesCorrespondingToEigenvectors;
            html += '<p>';
            html += '<math>' + Expression.p('S=M', {
                S: new Expression.MatrixSymbol('Σ'),
                M: new Expression.Matrix(Sigma)
            }, printOptions) + '</math>'; //TODO: [sqrt(lambda_i)]
            html += '</p>';
            html += '</li>';
            html += '<li>';
            html += i18n.SVD.findColumnVectorsOfU;
            html += i18n.SVD.howToFindUi; //TODO: link to better explanation (or just use the "column" vectors to show better)

            html += '<ul class="list-unstyled">';
            var i = 0;
            while (i < Sigma.rows() && i < Sigma.cols() && !Sigma.e(i, i).equals(Expression.ZERO)) {
                html += '<li>';
                html += '<math>' + Expression.p('u=x', {
                    u: new Expression.MatrixSymbol('u_i'.replaceAll('i', i + 1)),
                    x: new Expression.Matrix(U.col(i))
                }, printOptions) + '</math>';
                html += '</li>';
                i += 1;
            }
            html += '</ul>';
            if (i < matrix.rows()) {
                html += i18n.SVD.weNeedToFindFewMoreVectorsToBuildMatrixU; //?
                html += i18n.SVD.weFindEigenvectorsOfAATForZeroEigenvalue;
                //TODO: details
                html += i18n.SVD.orthonormalizedEigenvectors; // u_1 = ..., u_2 = ... - column vectors
                html += '<ul class="list-unstyled">';
                while (i < U.cols()) {
                    html += '<li>';
                    html += '<math>' + Expression.p('u=x', {
                        u: new Expression.MatrixSymbol('u_i'.replaceAll('i', i + 1)),
                        x: new Expression.Matrix(U.col(i))
                    }, printOptions) + '</math>';
                    html += '</li>';
                    i += 1;
                }
                html += '</ul>';
            }
            html += i18n.SVD.itCanBeShownThatTheVectorsOfUAreOrthonormalized; //?
            html += '</li>';
            html += '</ol>';
            html += '<p>';
            //! Note use direct childs of <math> to have some line-breaking in Firefox (Expression.Comma is not used)
            html += '<math>';
            html += new Expression.Equality(new Expression.MatrixSymbol('U'), new Expression.Matrix(U)).toMathML(printOptions);
            html += '<mo lspace="0em" rspace="0.55em">,</mo>';
            html += new Expression.Equality(new Expression.MatrixSymbol('Σ'), new Expression.Matrix(Sigma)).toMathML(printOptions);
            html += '<mo lspace="0em" rspace="0.55em">,</mo>';
            html += new Expression.Equality(new Expression.MatrixSymbol('V'), new Expression.Matrix(V)).toMathML(printOptions);
            html += '</math>';
            html += '</p>';
            return html;
        }
    });
    Expression.Details.add({
        type: "steps-to-find-QR-decomposition",
        i18n: null,
        minRows: 2,
        callback: function(printOptions, matrix) {
            var vectors = function(A, symbol) {
                var html = '';
                html += '<math>';
                for (var i = 0; i < A.cols(); i += 1) {
                    var v = A.col(i);
                    html += '<mrow>';
                    html += new Expression.MatrixSymbol(symbol + '_' + (i + 1)).toMathML() + '<mo>=</mo>' + new Expression.Matrix(v).toMathML(printOptions);
                    html += '</mrow>';
                    if (i !== A.cols() - 1) {
                        html += '<mo>,</mo>';
                    }
                }
                html += '</math>';
                return html;
            };
            var html = '';
            html += '<p>' + i18n.QRDecomposition.definition.replaceAll('`A = QR`', '<math>' + Expression.p('A = QR') + '</math>').replaceAll('`Q`', '<math>' + Expression.p('Q') + '</math>').replaceAll('`R`', '<math>' + Expression.p('R') + '</math>') + '</p>';
            var A = matrix;
            html += '<div>';
            html += '<math>' + Expression.p('A=M', {
                M: new Expression.Matrix(A)
            }, printOptions) + '</math>';
            html += '</div>';
            html += '<p>' + i18n.QRDecomposition.columnVectorsOfTheMatrixA.replaceAll('`A`', '<math>' + Expression.p('A') + '</math>') + '</p>';
            var columnVectors = new Array(A.cols());
            for (var i = 0; i < A.cols(); i += 1) {
                var v = A.col(i);
                columnVectors[i] = v;
            }
            html += vectors(A, 'v');
            html += '<p>' + i18n.QRDecomposition.GramSchmidtOrthogonalizationProduces + '</p>';
            var U = GramSchmidtOrthogonalization(columnVectors).filter(function(vector) {
                return !vector.eql(Matrix.Vector.Zero(vector.dimensions()));
            });
            html += '<details>';
            html += '<div class="indented">';
            html += '<p>' + i18n.QRDecomposition.GramSchmidtOrthogonalization.replaceAll('`[A^T(A^T)^{*}|A^T]`', '<math>' + Expression.p('[A^T(A^T)^{*}|A^T]', {
                A: new Expression.MatrixSymbol('A')
            }, {}) + '</math>') + '</p>';
            var X = A.transpose().multiply(A.transpose().conjugateTranspose());
            var E = X.augment(A.transpose());
            var Y = E.toRowEchelon(Matrix.Gauss, "row-reduction").matrix;
            html += '<div>';
            html += '<math>';
            html += Expression.p('A^T*(A^T)^{*}=X', {
                X: new Expression.Matrix(X)
            }, printOptions);
            html += '</math>';
            html += '</div>';
            html += '<div>';
            html += '<math>';
            html += new Expression.Matrix(E).toMathML(Object.assign({}, printOptions, {
                columnlines: -A.rows()
            }));
            html += '<mo>~</mo>';
            html += new Expression.Matrix(Y).toMathML(Object.assign({}, printOptions, {
                columnlines: -A.rows()
            }));
            html += '</math>';
            html += '</div>';
            var detailsHTML = RPN.createDetailsSummary(printOptions.idPrefix, [{
                type: 'steps-to-find-row-echelon-matrix',
                matrix: E.toString(),
                second: undefined
            }]);
            html += detailsHTML;
            html += '</div>';
            html += '</details>';
            html += vectors(Matrix.fromVectors(U), 'e');
            html += '<p>' + i18n.QRDecomposition.afterNormalizationWeHave + '</p>';
            var Q = Matrix.fromVectors(U.map(function(vector) {
                return vector.toUnitVector();
            }));
            html += vectors(Q, 'q');
            html += '<p>' + i18n.QRDecomposition.buildTheMatrixQFromThisVectors.replaceAll('`Q`', '<math>' + Expression.p('Q') + '</math>') + '</p>';
            html += '<div>';
            html += '<math>' + Expression.p('Q=M', {
                M: new Expression.Matrix(Q)
            }, printOptions) + '</math>';
            html += '</div>';
            html += '<p>' + i18n.QRDecomposition.howToFindR.replace(/`[^`]+`/g, function(p) {
                return '<math>' + Expression.p(p.slice(1, -1)) + '</math>';
            }) + '</p>';
            html += '<p>' + i18n.QRDecomposition.findR.replaceAll('`R=Q^{*}*A`', '<math>' + Expression.p('R=Q^{*}*A') + '</math>') + '</p>';
            html += '<div>';
            var R = Q.conjugateTranspose().multiply(A);
            html += '<math>' + Expression.p('R=M', {
                M: new Expression.Matrix(R)
            }, printOptions) + '</math>';
            html += '</div>';
            return html;
        }
    });

    //TODO: remove:
    // backward compatibility: 
    Expression.Details.add({
        type: "SVD-decomposition",
        minRows: 2,
        callback: function(printOptions, matrix) {
            return Expression.Details.getCallback("svd")(printOptions, matrix);
        }
    });
    Expression.Details.add({
        type: "QR-decomposition",
        minRows: 2,
        callback: function(printOptions, matrix) {
            var detailsHTML = RPN.createDetailsSummary(printOptions.idPrefix, [{
                type: 'steps-to-find-QR-decomposition',
                matrix: matrix.toString(),
                second: undefined
            }]);
            var tmp = Expression.QRDecomposition(matrix);
            var A = matrix;
            var html = "";
            html += "<div>";
            html += "<math>";
            html += Expression.p("A=Q*R", {
                A: new Expression.Matrix(A),
                Q: new Expression.Matrix(tmp.Q),
                R: new Expression.Matrix(tmp.R)
            }, printOptions);
            html += "</math>";
            html += "</div>";
            html += detailsHTML;
            return html;
        }
    });
    Expression.Details.add({
        type: "steps-to-find-Cholesky-decomposition",
        i18n: function() {
            return i18n.index.CholeskyDecomposition;
        },
        minRows: 2,
        callback: function(printOptions, matrix) {
            //TODO: better details when a lot of zeros - ?
            var A = matrix;

            // check if A is square
            if (!A.isSquare()) {
                throw new RangeError("NonSquareMatrixException");
            }
            var n = A.rows();

            // check if A from R
            var isReal = Expression.isRealMatrix(A);
            var onSymmetricChecking = function(symmetric) {
                var html = "";
                html += "<div>";
                html += "<math>";
                html += Expression.p("A=X", {
                    X: new Expression.Matrix(A)
                }, printOptions);
                html += "</math>";
                html += "</div>";
                html += "<div>";
                html += "<math>";
                //TODO: highlight e(i, j), e(j, i) - ?
                html += (isReal ? Expression.p("A=A^T") : Expression.p("A=A^{*}")).replace(/<mo>=<\/mo>/g, symmetric ? '<mo>=</mo>' : '<mo>&ne;</mo>');
                html += "</math>";
                html += "<span>";
                html += " - ";
                if (isReal) {
                    html += symmetric ? i18n.CholeskyDecomposition.theMatrixIsSymmetric : i18n.CholeskyDecomposition.theMatrixIsNotSymmetric;
                } else {
                    html += symmetric ? i18n.CholeskyDecomposition.theMatrixIsHermitian : i18n.CholeskyDecomposition.theMatrixIsNotHermitian;
                }
                html += "</span>";
                html += "</div>";
                return html;
            };

            // check if A is symmetric
            for (var i = 0; i < n; i += 1) {
                for (var j = i; j < n; j += 1) {
                    if (!A.e(i, j).equals(A.e(j, i).complexConjugate())) {
                        // throw new RangeError("NonSymmetricMatrixException");
                        return onSymmetricChecking(false);
                    }
                }
            }
            var html = "";

            //var tmp = Expression.CholeskyDecomposition(matrix);
            //var L = tmp.L.matrix;

            // The matrix is symmetric
            html += onSymmetricChecking(true);

            // 1.  A = L * L^T
            var nsL = Matrix.Zero(n, n).map(function(e, i, j) {
                return i >= j ? new Expression.Symbol("l_(" + (i + 1).toString() + "," + (j + 1).toString() + ")") : Expression.ZERO;
            });
            html += "<div>";
            html += i18n.CholeskyDecomposition.definition.replaceAll('${A=L*L^T}', '<math>' + (isReal ? Expression.p("A=L*L^T") : Expression.p("A=L*L^{*}")) + '</math>').replaceAll('${L}', '<math>' + Expression.p('L') + '</math>');
            html += " ";
            html += i18n.CholeskyDecompositionLink;
            html += "</div>";
            html += "<div>";

            //TODO: show that conjugate(l_(1,1)) == l_(1, 1) is used
            var M = nsL.multiply(nsL.transpose().map(function(e, i, j) {
                return isReal || i === j ? e : e.complexConjugate();
            }));
            printOptions = Object.assign({}, printOptions, {
                printId: true
            });
            var nsA = A.map(function(e, i, j) {
                return new NonSimplifiedExpression(e);
            });
            nsL = nsL.map(function(e, i, j) {
                return new NonSimplifiedExpression(e);
            });
            M = M.map(function(e, i, j) {
                return new NonSimplifiedExpression(e);
            });
            html += "<math>";
            html += Expression.p("A=L*T=M", {
                A: new Expression.Matrix(nsA),
                L: new Expression.Matrix(nsL),
                T: new Expression.Matrix(nsL.transpose().map(function(e, i, j) {
                    return isReal || i >= j ? e : e.complexConjugate();
                })),
                M: new Expression.Matrix(M)
            }, printOptions);
            html += "</math>";
            html += "</div>";
            html += "<div>";
            html += i18n.CholeskyDecomposition.then; //?
            html += "</div>";
            var L = new Array(n);
            for (var i = 0; i < n; i += 1) {
                L[i] = new Array(n);
                for (var j = 0; j < n; j += 1) {
                    L[i][j] = Expression.ZERO;
                }
            }
            html += '<ul class="list-unstyled">'; //?
            for (var j = 0; j < n; j += 1) {
                for (var i = j; i < n; i += 1) {
                    var nsE = null;
                    var e = null;
                    var radicand = null;
                    if (j === i) {
                        var nsSum = null;
                        var sum = null;
                        for (var k = 0; k < j; k += 1) {
                            var nsS = isReal ? nsL.e(j, k).pow(Expression.TWO) : nsL.e(j, k).multiply(nsL.e(j, k).complexConjugate());
                            nsSum = nsSum == null ? nsS : nsSum.add(nsS);
                            var s = isReal ? L[j][k].pow(Expression.TWO) : L[j][k].multiply(L[j][k].complexConjugate());
                            sum = sum == null ? s : sum.add(s);
                        }
                        var nsX = nsSum == null ? nsA.e(j, j) : nsA.e(j, j).subtract(nsSum);
                        var x = sum == null ? nsA.e(j, j) : nsA.e(j, j).subtract(sum);
                        //?
                        //if (x instanceof Expression.Integer && x.compareTo(Expression.ZERO) < 0) {
                        //  throw new RangeError("NonPositiveDefiniteMatrix");
                        //}
                        radicand = x;
                        nsE = nsX.squareRoot();
                        e = x.squareRoot();
                    } else {
                        var nsSum = null;
                        var sum = null;
                        for (var k = 0; k < j; k += 1) {
                            var nsX = isReal ? nsL.e(i, k).multiply(nsL.e(j, k)) : nsL.e(i, k).multiply(nsL.e(j, k).complexConjugate());
                            var x = isReal ? L[i][k].multiply(L[j][k]) : L[i][k].multiply(L[j][k].complexConjugate());
                            nsSum = nsSum == null ? nsX : nsSum.add(nsX);
                            sum = sum == null ? x : sum.add(x);
                        }
                        nsE = (nsSum == null ? nsA.e(i, j) : nsA.e(i, j).subtract(nsSum)).divide(nsL.e(j, j));
                        e = (sum == null ? nsA.e(i, j) : nsA.e(i, j).subtract(sum)).divide(L[j][j]);
                    }
                    html += "<li>";
                    html += "<math>";
                    var x = new NonSimplifiedExpression(M.e(i, j).unwrap());
                    var y = new NonSimplifiedExpression(nsA.e(i, j).unwrap());
                    html += '<mrow>';
                    html += x.toMathML(printOptions) + '<mo>=</mo>' + y.toMathML(printOptions);
                    html += '</mrow>';
                    var highlights = "";
                    highlights += "<a class=\"a-highlight\" data-for=\"" + x.getId() + "\" data-highlight=\"" + M.e(i, j).getIds() + "\"></a>";
                    highlights += "<a class=\"a-highlight\" data-for=\"" + y.getId() + "\" data-highlight=\"" + nsA.e(i, j).getIds() + "\"></a>";
                    html += '<mo stretchy="false" lspace="0.68em" rspace="0.68em">&rArr;</mo>';
                    html += '<mrow>';
                    html += nsL.e(i, j).toMathML(printOptions);
                    if (i !== 0 || j !== 0) {
                        // nothing to substitute for the first element
                        html += "<mo>=</mo>";
                        html += nsE.toMathML(printOptions); // before substitutions
                        html += "<mo>=</mo>";
                        html += e.toMathML(printOptions); // after substitutions
                    }

                    if (radicand != null) {
                        html += "<mo>=</mo>";
                        radicand = radicand.simplify();
                        html += new NonSimplifiedExpression(radicand).squareRoot().toMathML(printOptions); // after simplification of the expression under the radical symbol
                        nsE = null;
                        try {
                            nsE = radicand.squareRoot();
                        } catch (error) {
                            //TODO: !!!
                            console.log(error);
                        }
                        if (nsE == null || !Expression._isPositive(radicand)) {
                            try {
                                nsE = radicand.negate().squareRoot();
                            } catch (error2) {
                                console.log(error2);
                            }
                            var ok = nsE != null || !Expression._isPositive(radicand);
                            //TODO: fix
                            html += "</mrow>";
                            html += "</math>";
                            html += highlights;
                            html += "<span>";
                            html += " - ";
                            html += !ok ? i18n.CholeskyDecomposition.sorryCannotWork : i18n.CholeskyDecomposition.theMatrixIsNotPositiveDefinite;
                            html += "</span>";
                            html += "</li>";
                            html += '</ul>';
                            return html;
                        }
                    }
                    var r = e.simplify();
                    //TODO: subs
                    if (radicand == null || !r.equals(new Expression.SquareRoot(radicand))) {
                        html += "<mo>=</mo>";
                        html += r.toMathML(printOptions); // after simplification
                    }

                    html += '</mrow>';
                    html += "</math>";
                    html += highlights;
                    html += "</li>";
                    L[i][j] = new NonSimplifiedExpression(r);
                }
            }
            html += '</ul>';
            var LL = Matrix.padRows(L, null);
            html += "<div>";
            html += i18n.CholeskyDecomposition.then; //?
            html += "</div>";
            html += "<div>";
            html += "<math>";
            html += Expression.p("L=X", {
                X: new Expression.Matrix(LL)
            }, printOptions);
            html += "</math>";
            html += "</div>";
            return html;
        }
    });
})();